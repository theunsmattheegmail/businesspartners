(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["FEMockserver"] = factory();
	else
		root["FEMockserver"] = factory();
})(global, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 4350:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(9335), exports);


/***/ }),

/***/ 9335:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.revertTermToGenericType = exports.convertTypes = exports.defaultReferences = void 0;
var Path = /** @class */ (function () {
    function Path(pathExpression, targetName, annotationsTerm, annotationType, term) {
        this.path = pathExpression.Path;
        this.type = "Path";
        this.$target = targetName;
        (this.term = term), (this.annotationType = annotationType), (this.annotationsTerm = annotationsTerm);
    }
    return Path;
}());
var TermToTypes;
(function (TermToTypes) {
    TermToTypes["Org.OData.Authorization.V1.SecuritySchemes"] = "Org.OData.Authorization.V1.SecurityScheme";
    TermToTypes["Org.OData.Authorization.V1.Authorizations"] = "Org.OData.Authorization.V1.Authorization";
    TermToTypes["Org.OData.Core.V1.Revisions"] = "Org.OData.Core.V1.RevisionType";
    TermToTypes["Org.OData.Core.V1.Links"] = "Org.OData.Core.V1.Link";
    TermToTypes["Org.OData.Core.V1.Example"] = "Org.OData.Core.V1.ExampleValue";
    TermToTypes["Org.OData.Core.V1.Messages"] = "Org.OData.Core.V1.MessageType";
    TermToTypes["Org.OData.Core.V1.ValueException"] = "Org.OData.Core.V1.ValueExceptionType";
    TermToTypes["Org.OData.Core.V1.ResourceException"] = "Org.OData.Core.V1.ResourceExceptionType";
    TermToTypes["Org.OData.Core.V1.DataModificationException"] = "Org.OData.Core.V1.DataModificationExceptionType";
    TermToTypes["Org.OData.Core.V1.IsLanguageDependent"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.DereferenceableIDs"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.ConventionalIDs"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.Permissions"] = "Org.OData.Core.V1.Permission";
    TermToTypes["Org.OData.Core.V1.DefaultNamespace"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.Immutable"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.Computed"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.ComputedDefaultValue"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.IsURL"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.IsMediaType"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.ContentDisposition"] = "Org.OData.Core.V1.ContentDispositionType";
    TermToTypes["Org.OData.Core.V1.OptimisticConcurrency"] = "Edm.PropertyPath";
    TermToTypes["Org.OData.Core.V1.AdditionalProperties"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.AutoExpand"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.AutoExpandReferences"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.MayImplement"] = "Org.OData.Core.V1.QualifiedTypeName";
    TermToTypes["Org.OData.Core.V1.Ordered"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.PositionalInsert"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.AlternateKeys"] = "Org.OData.Core.V1.AlternateKey";
    TermToTypes["Org.OData.Core.V1.OptionalParameter"] = "Org.OData.Core.V1.OptionalParameterType";
    TermToTypes["Org.OData.Core.V1.OperationAvailable"] = "Edm.Boolean";
    TermToTypes["Org.OData.Core.V1.SymbolicName"] = "Org.OData.Core.V1.SimpleIdentifier";
    TermToTypes["Org.OData.Capabilities.V1.ConformanceLevel"] = "Org.OData.Capabilities.V1.ConformanceLevelType";
    TermToTypes["Org.OData.Capabilities.V1.AsynchronousRequestsSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.BatchContinueOnErrorSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.IsolationSupported"] = "Org.OData.Capabilities.V1.IsolationLevel";
    TermToTypes["Org.OData.Capabilities.V1.CrossJoinSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.CallbackSupported"] = "Org.OData.Capabilities.V1.CallbackType";
    TermToTypes["Org.OData.Capabilities.V1.ChangeTracking"] = "Org.OData.Capabilities.V1.ChangeTrackingType";
    TermToTypes["Org.OData.Capabilities.V1.CountRestrictions"] = "Org.OData.Capabilities.V1.CountRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.NavigationRestrictions"] = "Org.OData.Capabilities.V1.NavigationRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.IndexableByKey"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.TopSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.SkipSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.ComputeSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.SelectSupport"] = "Org.OData.Capabilities.V1.SelectSupportType";
    TermToTypes["Org.OData.Capabilities.V1.BatchSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.BatchSupport"] = "Org.OData.Capabilities.V1.BatchSupportType";
    TermToTypes["Org.OData.Capabilities.V1.FilterRestrictions"] = "Org.OData.Capabilities.V1.FilterRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.SortRestrictions"] = "Org.OData.Capabilities.V1.SortRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.ExpandRestrictions"] = "Org.OData.Capabilities.V1.ExpandRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.SearchRestrictions"] = "Org.OData.Capabilities.V1.SearchRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.KeyAsSegmentSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.QuerySegmentSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.InsertRestrictions"] = "Org.OData.Capabilities.V1.InsertRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.DeepInsertSupport"] = "Org.OData.Capabilities.V1.DeepInsertSupportType";
    TermToTypes["Org.OData.Capabilities.V1.UpdateRestrictions"] = "Org.OData.Capabilities.V1.UpdateRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.DeepUpdateSupport"] = "Org.OData.Capabilities.V1.DeepUpdateSupportType";
    TermToTypes["Org.OData.Capabilities.V1.DeleteRestrictions"] = "Org.OData.Capabilities.V1.DeleteRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.CollectionPropertyRestrictions"] = "Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.OperationRestrictions"] = "Org.OData.Capabilities.V1.OperationRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.ModificationQueryOptions"] = "Org.OData.Capabilities.V1.ModificationQueryOptionsType";
    TermToTypes["Org.OData.Capabilities.V1.ReadRestrictions"] = "Org.OData.Capabilities.V1.ReadRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.CustomHeaders"] = "Org.OData.Capabilities.V1.CustomParameter";
    TermToTypes["Org.OData.Capabilities.V1.CustomQueryOptions"] = "Org.OData.Capabilities.V1.CustomParameter";
    TermToTypes["Org.OData.Capabilities.V1.MediaLocationUpdateSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Aggregation.V1.ApplySupported"] = "Org.OData.Aggregation.V1.ApplySupportedType";
    TermToTypes["Org.OData.Aggregation.V1.Groupable"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Aggregation.V1.Aggregatable"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Aggregation.V1.ContextDefiningProperties"] = "Edm.PropertyPath";
    TermToTypes["Org.OData.Aggregation.V1.LeveledHierarchy"] = "Edm.PropertyPath";
    TermToTypes["Org.OData.Aggregation.V1.RecursiveHierarchy"] = "Org.OData.Aggregation.V1.RecursiveHierarchyType";
    TermToTypes["Org.OData.Aggregation.V1.AvailableOnAggregates"] = "Org.OData.Aggregation.V1.AvailableOnAggregatesType";
    TermToTypes["Org.OData.Validation.V1.Minimum"] = "Edm.PrimitiveType";
    TermToTypes["Org.OData.Validation.V1.Maximum"] = "Edm.PrimitiveType";
    TermToTypes["Org.OData.Validation.V1.Exclusive"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Validation.V1.AllowedValues"] = "Org.OData.Validation.V1.AllowedValue";
    TermToTypes["Org.OData.Validation.V1.MultipleOf"] = "Edm.Decimal";
    TermToTypes["Org.OData.Validation.V1.Constraint"] = "Org.OData.Validation.V1.ConstraintType";
    TermToTypes["Org.OData.Validation.V1.ItemsOf"] = "Org.OData.Validation.V1.ItemsOfType";
    TermToTypes["Org.OData.Validation.V1.OpenPropertyTypeConstraint"] = "Org.OData.Core.V1.QualifiedTypeName";
    TermToTypes["Org.OData.Validation.V1.DerivedTypeConstraint"] = "Org.OData.Core.V1.QualifiedTypeName";
    TermToTypes["Org.OData.Validation.V1.AllowedTerms"] = "Org.OData.Core.V1.QualifiedTermName";
    TermToTypes["Org.OData.Validation.V1.ApplicableTerms"] = "Org.OData.Core.V1.QualifiedTermName";
    TermToTypes["Org.OData.Validation.V1.MaxItems"] = "Edm.Int64";
    TermToTypes["Org.OData.Validation.V1.MinItems"] = "Edm.Int64";
    TermToTypes["Org.OData.Measures.V1.Scale"] = "Edm.Byte";
    TermToTypes["Org.OData.Measures.V1.DurationGranularity"] = "Org.OData.Measures.V1.DurationGranularityType";
    TermToTypes["com.sap.vocabularies.Analytics.v1.Dimension"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.Measure"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.AccumulativeMeasure"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount"] = "Edm.Int16";
    TermToTypes["com.sap.vocabularies.Analytics.v1.PlanningAction"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.AggregatedProperties"] = "com.sap.vocabularies.Analytics.v1.AggregatedPropertyType";
    TermToTypes["com.sap.vocabularies.Common.v1.ServiceVersion"] = "Edm.Int32";
    TermToTypes["com.sap.vocabularies.Common.v1.ServiceSchemaVersion"] = "Edm.Int32";
    TermToTypes["com.sap.vocabularies.Common.v1.TextFor"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.IsLanguageIdentifier"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.TextFormat"] = "com.sap.vocabularies.Common.v1.TextFormatType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDigitSequence"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsUpperCase"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCurrency"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsUnit"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.UnitSpecificScale"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.UnitSpecificPrecision"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.SecondaryKey"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.MinOccurs"] = "Edm.Int64";
    TermToTypes["com.sap.vocabularies.Common.v1.MaxOccurs"] = "Edm.Int64";
    TermToTypes["com.sap.vocabularies.Common.v1.AssociationEntity"] = "Edm.NavigationPropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.DerivedNavigation"] = "Edm.NavigationPropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.Masked"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.MaskedAlways"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.SemanticObjectMapping"] = "com.sap.vocabularies.Common.v1.SemanticObjectMappingType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsInstanceAnnotation"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.FilterExpressionRestrictions"] = "com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType";
    TermToTypes["com.sap.vocabularies.Common.v1.FieldControl"] = "com.sap.vocabularies.Common.v1.FieldControlType";
    TermToTypes["com.sap.vocabularies.Common.v1.Application"] = "com.sap.vocabularies.Common.v1.ApplicationType";
    TermToTypes["com.sap.vocabularies.Common.v1.Timestamp"] = "Edm.DateTimeOffset";
    TermToTypes["com.sap.vocabularies.Common.v1.ErrorResolution"] = "com.sap.vocabularies.Common.v1.ErrorResolutionType";
    TermToTypes["com.sap.vocabularies.Common.v1.Messages"] = "Edm.ComplexType";
    TermToTypes["com.sap.vocabularies.Common.v1.numericSeverity"] = "com.sap.vocabularies.Common.v1.NumericMessageSeverityType";
    TermToTypes["com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity"] = "com.sap.vocabularies.Common.v1.NumericMessageSeverityType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsActionCritical"] = "Edm.Boolean";
    TermToTypes["com.sap.vocabularies.Common.v1.Attributes"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy"] = "Edm.AnnotationPath";
    TermToTypes["com.sap.vocabularies.Common.v1.Interval"] = "com.sap.vocabularies.Common.v1.IntervalType";
    TermToTypes["com.sap.vocabularies.Common.v1.ResultContext"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.WeakReferentialConstraint"] = "com.sap.vocabularies.Common.v1.WeakReferentialConstraintType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsNaturalPerson"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueList"] = "com.sap.vocabularies.Common.v1.ValueListType";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers"] = "com.sap.vocabularies.Common.v1.SimpleIdentifier";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueListWithFixedValues"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueListMapping"] = "com.sap.vocabularies.Common.v1.ValueListMappingType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarHalfyear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarMonth"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDayOfCalendarYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearMonth"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarDate"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalPeriod"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearPeriod"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDayOfFiscalYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearVariant"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.DraftRoot"] = "com.sap.vocabularies.Common.v1.DraftRootType";
    TermToTypes["com.sap.vocabularies.Common.v1.DraftNode"] = "com.sap.vocabularies.Common.v1.DraftNodeType";
    TermToTypes["com.sap.vocabularies.Common.v1.DraftActivationVia"] = "com.sap.vocabularies.Common.v1.SimpleIdentifier";
    TermToTypes["com.sap.vocabularies.Common.v1.EditableFieldFor"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.SemanticKey"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.SideEffects"] = "com.sap.vocabularies.Common.v1.SideEffectsType";
    TermToTypes["com.sap.vocabularies.Common.v1.DefaultValuesFunction"] = "com.sap.vocabularies.Common.v1.QualifiedName";
    TermToTypes["com.sap.vocabularies.Common.v1.FilterDefaultValue"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.FilterDefaultValueHigh"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.SortOrder"] = "com.sap.vocabularies.Common.v1.SortOrderType";
    TermToTypes["com.sap.vocabularies.Common.v1.RecursiveHierarchy"] = "com.sap.vocabularies.Common.v1.RecursiveHierarchyType";
    TermToTypes["com.sap.vocabularies.Common.v1.CreatedAt"] = "Edm.DateTimeOffset";
    TermToTypes["com.sap.vocabularies.Common.v1.CreatedBy"] = "com.sap.vocabularies.Common.v1.UserID";
    TermToTypes["com.sap.vocabularies.Common.v1.ChangedAt"] = "Edm.DateTimeOffset";
    TermToTypes["com.sap.vocabularies.Common.v1.ChangedBy"] = "com.sap.vocabularies.Common.v1.UserID";
    TermToTypes["com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.CodeList.v1.CurrencyCodes"] = "com.sap.vocabularies.CodeList.v1.CodeListSource";
    TermToTypes["com.sap.vocabularies.CodeList.v1.UnitsOfMeasure"] = "com.sap.vocabularies.CodeList.v1.CodeListSource";
    TermToTypes["com.sap.vocabularies.CodeList.v1.StandardCode"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.CodeList.v1.ExternalCode"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode"] = "Edm.Boolean";
    TermToTypes["com.sap.vocabularies.Communication.v1.Contact"] = "com.sap.vocabularies.Communication.v1.ContactType";
    TermToTypes["com.sap.vocabularies.Communication.v1.Address"] = "com.sap.vocabularies.Communication.v1.AddressType";
    TermToTypes["com.sap.vocabularies.Communication.v1.IsEmailAddress"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Communication.v1.IsPhoneNumber"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Communication.v1.Event"] = "com.sap.vocabularies.Communication.v1.EventData";
    TermToTypes["com.sap.vocabularies.Communication.v1.Task"] = "com.sap.vocabularies.Communication.v1.TaskData";
    TermToTypes["com.sap.vocabularies.Communication.v1.Message"] = "com.sap.vocabularies.Communication.v1.MessageData";
    TermToTypes["com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy"] = "com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.EntitySemantics"] = "com.sap.vocabularies.PersonalData.v1.EntitySemanticsType";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.FieldSemantics"] = "com.sap.vocabularies.PersonalData.v1.FieldSemanticsType";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Session.v1.StickySessionSupported"] = "com.sap.vocabularies.Session.v1.StickySessionSupportedType";
    TermToTypes["com.sap.vocabularies.UI.v1.HeaderInfo"] = "com.sap.vocabularies.UI.v1.HeaderInfoType";
    TermToTypes["com.sap.vocabularies.UI.v1.Identification"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.Badge"] = "com.sap.vocabularies.UI.v1.BadgeType";
    TermToTypes["com.sap.vocabularies.UI.v1.LineItem"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.StatusInfo"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.FieldGroup"] = "com.sap.vocabularies.UI.v1.FieldGroupType";
    TermToTypes["com.sap.vocabularies.UI.v1.ConnectedFields"] = "com.sap.vocabularies.UI.v1.ConnectedFieldsType";
    TermToTypes["com.sap.vocabularies.UI.v1.GeoLocations"] = "com.sap.vocabularies.UI.v1.GeoLocationType";
    TermToTypes["com.sap.vocabularies.UI.v1.GeoLocation"] = "com.sap.vocabularies.UI.v1.GeoLocationType";
    TermToTypes["com.sap.vocabularies.UI.v1.Contacts"] = "Edm.AnnotationPath";
    TermToTypes["com.sap.vocabularies.UI.v1.MediaResource"] = "com.sap.vocabularies.UI.v1.MediaResourceType";
    TermToTypes["com.sap.vocabularies.UI.v1.DataPoint"] = "com.sap.vocabularies.UI.v1.DataPointType";
    TermToTypes["com.sap.vocabularies.UI.v1.KPI"] = "com.sap.vocabularies.UI.v1.KPIType";
    TermToTypes["com.sap.vocabularies.UI.v1.Chart"] = "com.sap.vocabularies.UI.v1.ChartDefinitionType";
    TermToTypes["com.sap.vocabularies.UI.v1.ValueCriticality"] = "com.sap.vocabularies.UI.v1.ValueCriticalityType";
    TermToTypes["com.sap.vocabularies.UI.v1.CriticalityLabels"] = "com.sap.vocabularies.UI.v1.CriticalityLabelType";
    TermToTypes["com.sap.vocabularies.UI.v1.SelectionFields"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.UI.v1.Facets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.HeaderFacets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.QuickViewFacets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.QuickCreateFacets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.FilterFacets"] = "com.sap.vocabularies.UI.v1.ReferenceFacet";
    TermToTypes["com.sap.vocabularies.UI.v1.SelectionPresentationVariant"] = "com.sap.vocabularies.UI.v1.SelectionPresentationVariantType";
    TermToTypes["com.sap.vocabularies.UI.v1.PresentationVariant"] = "com.sap.vocabularies.UI.v1.PresentationVariantType";
    TermToTypes["com.sap.vocabularies.UI.v1.SelectionVariant"] = "com.sap.vocabularies.UI.v1.SelectionVariantType";
    TermToTypes["com.sap.vocabularies.UI.v1.ThingPerspective"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.IsSummary"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.PartOfPreview"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.Map"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.Gallery"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.IsImageURL"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.IsImage"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.MultiLineText"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.TextArrangement"] = "com.sap.vocabularies.UI.v1.TextArrangementType";
    TermToTypes["com.sap.vocabularies.UI.v1.Importance"] = "com.sap.vocabularies.UI.v1.ImportanceType";
    TermToTypes["com.sap.vocabularies.UI.v1.Hidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.CreateHidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.UpdateHidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.DeleteHidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.HiddenFilter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.DataFieldDefault"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.Criticality"] = "com.sap.vocabularies.UI.v1.CriticalityType";
    TermToTypes["com.sap.vocabularies.UI.v1.CriticalityCalculation"] = "com.sap.vocabularies.UI.v1.CriticalityCalculationType";
    TermToTypes["com.sap.vocabularies.UI.v1.Emphasized"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.OrderBy"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.UI.v1.ParameterDefaultValue"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.UI.v1.RecommendationState"] = "com.sap.vocabularies.UI.v1.RecommendationStateType";
    TermToTypes["com.sap.vocabularies.UI.v1.RecommendationList"] = "com.sap.vocabularies.UI.v1.RecommendationListType";
    TermToTypes["com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.HTML5.v1.CssDefaults"] = "com.sap.vocabularies.HTML5.v1.CssDefaultsType";
})(TermToTypes || (TermToTypes = {}));
exports.defaultReferences = [
    { alias: "Capabilities", namespace: "Org.OData.Capabilities.V1", uri: "" },
    { alias: "Aggregation", namespace: "Org.OData.Aggregation.V1", uri: "" },
    { alias: "Validation", namespace: "Org.OData.Validation.V1", uri: "" },
    { namespace: "Org.OData.Core.V1", alias: "Core", uri: "" },
    { namespace: "Org.OData.Measures.V1", alias: "Measures", uri: "" },
    { namespace: "com.sap.vocabularies.Common.v1", alias: "Common", uri: "" },
    { namespace: "com.sap.vocabularies.UI.v1", alias: "UI", uri: "" },
    { namespace: "com.sap.vocabularies.Session.v1", alias: "Session", uri: "" },
    { namespace: "com.sap.vocabularies.Analytics.v1", alias: "Analytics", uri: "" },
    { namespace: "com.sap.vocabularies.CodeList.v1", alias: "CodeList", uri: "" },
    { namespace: "com.sap.vocabularies.PersonalData.v1", alias: "PersonalData", uri: "" },
    { namespace: "com.sap.vocabularies.Communication.v1", alias: "Communication", uri: "" },
    { namespace: "com.sap.vocabularies.HTML5.v1", alias: "HTML5", uri: "" }
];
function alias(references, unaliasedValue) {
    if (!references.reverseReferenceMap) {
        references.reverseReferenceMap = references.reduce(function (map, reference) {
            map[reference.namespace] = reference;
            return map;
        }, {});
    }
    if (!unaliasedValue) {
        return unaliasedValue;
    }
    var lastDotIndex = unaliasedValue.lastIndexOf(".");
    var namespace = unaliasedValue.substr(0, lastDotIndex);
    var value = unaliasedValue.substr(lastDotIndex + 1);
    var reference = references.reverseReferenceMap[namespace];
    if (reference) {
        return reference.alias + "." + value;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (unaliasedValue.indexOf("@") !== -1) {
            var _a = unaliasedValue.split("@"), preAlias = _a[0], postAlias = _a.slice(1);
            return preAlias + "@" + alias(references, postAlias.join("@"));
        }
        else {
            return unaliasedValue;
        }
    }
}
function unalias(references, aliasedValue) {
    if (!references.referenceMap) {
        references.referenceMap = references.reduce(function (map, reference) {
            map[reference.alias] = reference;
            return map;
        }, {});
    }
    if (!aliasedValue) {
        return aliasedValue;
    }
    var _a = aliasedValue.split("."), alias = _a[0], value = _a.slice(1);
    var reference = references.referenceMap[alias];
    if (reference) {
        return reference.namespace + "." + value.join(".");
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (aliasedValue.indexOf("@") !== -1) {
            var _b = aliasedValue.split("@"), preAlias = _b[0], postAlias = _b.slice(1);
            return preAlias + "@" + unalias(references, postAlias.join("@"));
        }
        else {
            return aliasedValue;
        }
    }
}
function buildObjectMap(parserOutput) {
    var objectMap = {};
    if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
        objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
    }
    parserOutput.schema.entitySets.forEach(function (entitySet) {
        objectMap[entitySet.fullyQualifiedName] = entitySet;
    });
    parserOutput.schema.actions.forEach(function (action) {
        objectMap[action.fullyQualifiedName] = action;
        if (action.isBound) {
            var unBoundActionName = action.fullyQualifiedName.split("(")[0];
            if (!objectMap[unBoundActionName]) {
                objectMap[unBoundActionName] = {
                    _type: "UnboundGenericAction",
                    actions: []
                };
            }
            objectMap[unBoundActionName].actions.push(action);
        }
        action.parameters.forEach(function (parameter) {
            objectMap[parameter.fullyQualifiedName] = parameter;
        });
    });
    parserOutput.schema.complexTypes.forEach(function (complexType) {
        objectMap[complexType.fullyQualifiedName] = complexType;
        complexType.properties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
        });
    });
    parserOutput.schema.entityTypes.forEach(function (entityType) {
        objectMap[entityType.fullyQualifiedName] = entityType;
        entityType.entityProperties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
            if (property.type.indexOf("Edm") === -1) {
                // Handle complex types
                var complexTypeDefinition = objectMap[property.type];
                if (complexTypeDefinition && complexTypeDefinition.properties) {
                    complexTypeDefinition.properties.forEach(function (complexTypeProp) {
                        var complexTypePropTarget = Object.assign(complexTypeProp, {
                            _type: "Property",
                            fullyQualifiedName: property.fullyQualifiedName + "/" + complexTypeProp.name
                        });
                        objectMap[complexTypePropTarget.fullyQualifiedName] = complexTypePropTarget;
                    });
                }
            }
        });
        entityType.navigationProperties.forEach(function (navProperty) {
            objectMap[navProperty.fullyQualifiedName] = navProperty;
        });
    });
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            annotationList.annotations.forEach(function (annotation) {
                var annotationFQN = currentTargetName + "@" + unalias(parserOutput.references, annotation.term);
                if (annotation.qualifier) {
                    annotationFQN += "#" + annotation.qualifier;
                }
                if (typeof annotation !== "object") {
                    debugger;
                }
                objectMap[annotationFQN] = annotation;
                annotation.fullyQualifiedName = annotationFQN;
            });
        });
    });
    return objectMap;
}
function combinePath(currentTarget, path) {
    if (path.startsWith("@")) {
        return currentTarget + unalias(exports.defaultReferences, path);
    }
    else {
        return currentTarget + "/" + path;
    }
}
function addAnnotationErrorMessage(path, oErrorMsg) {
    if (!ALL_ANNOTATION_ERRORS[path]) {
        ALL_ANNOTATION_ERRORS[path] = [oErrorMsg];
    }
    else {
        ALL_ANNOTATION_ERRORS[path].push(oErrorMsg);
    }
}
function resolveTarget(objectMap, currentTarget, path, pathOnly, includeVisitedObjects, annotationType, annotationsTerm) {
    if (pathOnly === void 0) { pathOnly = false; }
    if (includeVisitedObjects === void 0) { includeVisitedObjects = false; }
    if (!path) {
        return undefined;
    }
    //const propertyPath = path;
    var aVisitedObjects = [];
    if (currentTarget && currentTarget._type === "Property") {
        currentTarget = objectMap[currentTarget.fullyQualifiedName.split("/")[0]];
    }
    path = combinePath(currentTarget.fullyQualifiedName, path);
    var pathSplit = path.split("/");
    var targetPathSplit = [];
    pathSplit.forEach(function (pathPart) {
        // Separate out the annotation
        if (pathPart.indexOf("@") !== -1) {
            var _a = pathPart.split("@"), path_1 = _a[0], annotationPath = _a[1];
            targetPathSplit.push(path_1);
            targetPathSplit.push("@" + annotationPath);
        }
        else {
            targetPathSplit.push(pathPart);
        }
    });
    var currentPath = path;
    var currentContext = currentTarget;
    var target = targetPathSplit.reduce(function (currentValue, pathPart) {
        if (pathPart === "$Type" && currentValue._type === "EntityType") {
            return currentValue;
        }
        if (pathPart.length === 0) {
            // Empty Path after an entitySet means entityType
            if (currentValue && currentValue._type === "EntitySet" && currentValue.entityType) {
                if (includeVisitedObjects) {
                    aVisitedObjects.push(currentValue);
                }
                currentValue = currentValue.entityType;
            }
            if (currentValue && currentValue._type === "NavigationProperty" && currentValue.targetType) {
                if (includeVisitedObjects) {
                    aVisitedObjects.push(currentValue);
                }
                currentValue = currentValue.targetType;
            }
            return currentValue;
        }
        if (includeVisitedObjects && currentValue !== null && currentValue !== undefined) {
            aVisitedObjects.push(currentValue);
        }
        if (!currentValue) {
            currentPath = pathPart;
        }
        else if (currentValue._type === "EntitySet" && pathPart === "$Type") {
            currentValue = currentValue.targetType;
            return currentValue;
        }
        else if (currentValue._type === "EntitySet" && currentValue.entityType) {
            currentPath = combinePath(currentValue.entityTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
            currentPath = combinePath(currentValue.targetTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
            currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
        }
        else if (currentValue._type === "Property") {
            // ComplexType or Property
            if (currentValue.targetType) {
                currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
            }
            else {
                currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            }
        }
        else if (currentValue._type === "Action" && currentValue.isBound) {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (!objectMap[currentPath]) {
                currentPath = combinePath(currentValue.sourceType, pathPart);
            }
        }
        else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
            currentPath = combinePath(currentValue.type, pathPart);
        }
        else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
            currentPath = combinePath(currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")), pathPart);
            if (!objectMap[currentPath]) {
                var lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
                if (lastIdx === -1) {
                    lastIdx = currentTarget.fullyQualifiedName.length;
                }
                currentPath = combinePath(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)].sourceType, pathPart);
            }
        }
        else {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (pathPart !== "name" && currentValue[pathPart] !== undefined) {
                return currentValue[pathPart];
            }
            else if (pathPart === "$AnnotationPath" && currentValue.$target) {
                var currentContext_1 = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
                var subTarget = resolveTarget(objectMap, currentContext_1, currentValue.value, false, true);
                subTarget.visitedObjects.forEach(function (visitedSubObject) {
                    if (aVisitedObjects.indexOf(visitedSubObject) === -1) {
                        aVisitedObjects.push(visitedSubObject);
                    }
                });
                return subTarget.target;
            }
            else if (pathPart === "$Path" && currentValue.$target) {
                currentContext = aVisitedObjects
                    .concat()
                    .reverse()
                    .find(function (obj) {
                    return obj._type === "EntityType" ||
                        obj._type === "EntitySet" ||
                        obj._type === "NavigationProperty";
                });
                if (currentContext) {
                    var subTarget = resolveTarget(objectMap, currentContext, currentValue.path, false, true);
                    subTarget.visitedObjects.forEach(function (visitedSubObject) {
                        if (aVisitedObjects.indexOf(visitedSubObject) === -1) {
                            aVisitedObjects.push(visitedSubObject);
                        }
                    });
                    return subTarget.target;
                }
                return currentValue.$target;
            }
            else if (pathPart.startsWith("$Path") && currentValue.$target) {
                var intermediateTarget = currentValue.$target;
                currentPath = combinePath(intermediateTarget.fullyQualifiedName, pathPart.substr(5));
            }
            else if (currentValue.hasOwnProperty("$Type") && !objectMap[currentPath]) {
                // This is now an annotation value
                var entityType = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
                if (entityType) {
                    currentPath = combinePath(entityType.fullyQualifiedName, pathPart);
                }
            }
        }
        return objectMap[currentPath];
    }, null);
    if (!target) {
        if (annotationsTerm && annotationType) {
            var oErrorMsg = {
                message: "Unable to resolve the path expression: " +
                    "\n" +
                    path +
                    "\n" +
                    "\n" +
                    "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                    "<Annotation Term = " +
                    annotationsTerm +
                    ">" +
                    "\n" +
                    "<Record Type = " +
                    annotationType +
                    ">" +
                    "\n" +
                    "<AnnotationPath = " +
                    path +
                    ">"
            };
            addAnnotationErrorMessage(path, oErrorMsg);
        }
        else {
            var oErrorMsg = {
                message: "Unable to resolve the path expression: " +
                    path +
                    "\n" +
                    "\n" +
                    "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                    "<Annotation Term = " +
                    pathSplit[0] +
                    ">" +
                    "\n" +
                    "<PropertyValue  Path= " +
                    pathSplit[1] +
                    ">"
            };
            addAnnotationErrorMessage(path, oErrorMsg);
        }
        // console.log("Missing target " + path);
    }
    if (pathOnly) {
        return currentPath;
    }
    if (includeVisitedObjects) {
        return {
            visitedObjects: aVisitedObjects,
            target: target
        };
    }
    return target;
}
function isAnnotationPath(pathStr) {
    return pathStr.indexOf("@") !== -1;
}
function parseValue(propertyValue, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm) {
    if (propertyValue === undefined) {
        return undefined;
    }
    switch (propertyValue.type) {
        case "String":
            return propertyValue.String;
        case "Int":
            return propertyValue.Int;
        case "Bool":
            return propertyValue.Bool;
        case "Decimal":
            return propertyValue.Decimal;
        case "Date":
            return propertyValue.Date;
        case "EnumMember":
            return alias(parserOutput.references, propertyValue.EnumMember);
        case "PropertyPath":
            return {
                type: "PropertyPath",
                value: propertyValue.PropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.PropertyPath, false, false, annotationType, annotationsTerm)
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                value: propertyValue.NavigationPropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.NavigationPropertyPath, false, false, annotationType, annotationsTerm)
            };
        case "AnnotationPath":
            var annotationTarget = resolveTarget(objectMap, currentTarget, unalias(parserOutput.references, propertyValue.AnnotationPath), true, false, annotationType, annotationsTerm);
            var annotationPath = {
                type: "AnnotationPath",
                value: propertyValue.AnnotationPath,
                fullyQualifiedName: valueFQN,
                $target: annotationTarget,
                annotationType: annotationType,
                annotationsTerm: annotationsTerm,
                term: "",
                path: ""
            };
            toResolve.push({ inline: false, toResolve: annotationPath });
            return annotationPath;
        case "Path":
            var $target = resolveTarget(objectMap, currentTarget, propertyValue.Path, true, false, annotationType, annotationsTerm);
            var path = new Path(propertyValue, $target, annotationsTerm, annotationType, "");
            toResolve.push({
                inline: isAnnotationPath(propertyValue.Path),
                toResolve: path
            });
            return path;
        case "Record":
            return parseRecord(propertyValue.Record, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
        case "Collection":
            return parseCollection(propertyValue.Collection, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
        case "Apply":
        case "Not":
        case "Eq":
        case "Ne":
        case "Gt":
        case "Ge":
        case "Lt":
        case "Le":
        case "If":
        case "And":
        case "Or":
            return propertyValue;
    }
}
function inferTypeFromTerm(annotationsTerm, parserOutput, annotationTarget) {
    var targetType = TermToTypes[annotationsTerm];
    var oErrorMsg = {
        isError: false,
        message: "The type of the record used within the term " + annotationsTerm + " was not defined and was inferred as " + targetType + ".\nHint: If possible, try to maintain the Type property for each Record.\n<Annotations Target=\"" + annotationTarget + "\">\n\t<Annotation Term=\"" + annotationsTerm + "\">\n\t\t<Record>...</Record>\n\t</Annotation>\n</Annotations>"
    };
    addAnnotationErrorMessage(annotationTarget + "/" + annotationsTerm, oErrorMsg);
    return targetType;
}
function parseRecord(recordDefinition, currentFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm) {
    var targetType;
    if (!recordDefinition.type && annotationsTerm) {
        targetType = inferTypeFromTerm(annotationsTerm, parserOutput, currentTarget.fullyQualifiedName);
    }
    else {
        targetType = unalias(parserOutput.references, recordDefinition.type);
    }
    var annotationTerm = {
        $Type: targetType,
        fullyQualifiedName: currentFQN
    };
    var annotationContent = {};
    if (recordDefinition.annotations && Array.isArray(recordDefinition.annotations)) {
        var subAnnotationList = {
            target: currentFQN,
            annotations: recordDefinition.annotations,
            __source: annotationSource
        };
        unresolvedAnnotations.push(subAnnotationList);
    }
    if (recordDefinition.propertyValues) {
        recordDefinition.propertyValues.forEach(function (propertyValue) {
            annotationContent[propertyValue.name] = parseValue(propertyValue.value, currentFQN + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
            if (propertyValue.annotations && Array.isArray(propertyValue.annotations)) {
                var subAnnotationList = {
                    target: currentFQN + "/" + propertyValue.name,
                    annotations: propertyValue.annotations,
                    __source: annotationSource
                };
                unresolvedAnnotations.push(subAnnotationList);
            }
            if (annotationContent.hasOwnProperty("Action") &&
                (annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                    annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
                annotationContent.ActionTarget =
                    (currentTarget.actions && currentTarget.actions[annotationContent.Action]) ||
                        objectMap[annotationContent.Action];
                if (!annotationContent.ActionTarget) {
                    // Add to diagnostics debugger;
                    ANNOTATION_ERRORS.push({
                        message: "Unable to resolve the action " +
                            annotationContent.Action +
                            " defined for " +
                            annotationTerm.fullyQualifiedName
                    });
                }
            }
        });
    }
    return Object.assign(annotationTerm, annotationContent);
}
function getOrInferCollectionType(collectionDefinition) {
    var type = collectionDefinition.type;
    if (type === undefined && collectionDefinition.length > 0) {
        var firstColItem = collectionDefinition[0];
        if (firstColItem.hasOwnProperty("PropertyPath")) {
            type = "PropertyPath";
        }
        else if (firstColItem.hasOwnProperty("Path")) {
            type = "Path";
        }
        else if (firstColItem.hasOwnProperty("AnnotationPath")) {
            type = "AnnotationPath";
        }
        else if (firstColItem.hasOwnProperty("NavigationPropertyPath")) {
            type = "NavigationPropertyPath";
        }
        else if (typeof firstColItem === "object" &&
            (firstColItem.hasOwnProperty("type") || firstColItem.hasOwnProperty("propertyValues"))) {
            type = "Record";
        }
        else if (typeof firstColItem === "string") {
            type = "String";
        }
    }
    else if (type === undefined) {
        type = "EmptyCollection";
    }
    return type;
}
function parseCollection(collectionDefinition, parentFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm) {
    var collectionDefinitionType = getOrInferCollectionType(collectionDefinition);
    switch (collectionDefinitionType) {
        case "PropertyPath":
            return collectionDefinition.map(function (propertyPath, propertyIdx) {
                return {
                    type: "PropertyPath",
                    value: propertyPath.PropertyPath,
                    fullyQualifiedName: parentFQN + "/" + propertyIdx,
                    $target: resolveTarget(objectMap, currentTarget, propertyPath.PropertyPath, false, false, annotationType, annotationsTerm)
                };
            });
        case "Path":
            return collectionDefinition.map(function (pathValue) {
                var $target = resolveTarget(objectMap, currentTarget, pathValue.Path, true, false, annotationType, annotationsTerm);
                var path = new Path(pathValue, $target, annotationsTerm, annotationType, "");
                toResolve.push({
                    inline: isAnnotationPath(pathValue.Path),
                    toResolve: path
                });
                return path;
            });
        case "AnnotationPath":
            return collectionDefinition.map(function (annotationPath, annotationIdx) {
                var annotationTarget = resolveTarget(objectMap, currentTarget, annotationPath.AnnotationPath, true, false, annotationType, annotationsTerm);
                var annotationCollectionElement = {
                    type: "AnnotationPath",
                    value: annotationPath.AnnotationPath,
                    fullyQualifiedName: parentFQN + "/" + annotationIdx,
                    $target: annotationTarget,
                    annotationType: annotationType,
                    annotationsTerm: annotationsTerm,
                    term: "",
                    path: ""
                };
                toResolve.push({
                    inline: false,
                    toResolve: annotationCollectionElement
                });
                return annotationCollectionElement;
            });
        case "NavigationPropertyPath":
            return collectionDefinition.map(function (navPropertyPath, navPropIdx) {
                return {
                    type: "NavigationPropertyPath",
                    value: navPropertyPath.NavigationPropertyPath,
                    fullyQualifiedName: parentFQN + "/" + navPropIdx,
                    $target: resolveTarget(objectMap, currentTarget, navPropertyPath.NavigationPropertyPath, false, false, annotationType, annotationsTerm)
                };
            });
        case "Record":
            return collectionDefinition.map(function (recordDefinition, recordIdx) {
                return parseRecord(recordDefinition, parentFQN + "/" + recordIdx, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
            });
        case "Apply":
        case "If":
        case "Eq":
        case "Ne":
        case "Lt":
        case "Gt":
        case "Le":
        case "Ge":
        case "Not":
        case "And":
        case "Or":
            return collectionDefinition.map(function (ifValue) {
                return ifValue;
            });
        case "String":
            return collectionDefinition.map(function (stringValue) {
                if (typeof stringValue === "string") {
                    return stringValue;
                }
                else if (stringValue === undefined) {
                    return stringValue;
                }
                else {
                    return stringValue.String;
                }
            });
        default:
            if (collectionDefinition.length === 0) {
                return [];
            }
            throw new Error("Unsupported case");
    }
}
function convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations) {
    if (annotation.record) {
        var annotationType_1 = annotation.record.type
            ? unalias(parserOutput.references, annotation.record.type)
            : inferTypeFromTerm(annotation.term, parserOutput, currentTarget.fullyQualifiedName);
        var annotationTerm_1 = {
            $Type: annotationType_1,
            fullyQualifiedName: annotation.fullyQualifiedName,
            qualifier: annotation.qualifier
        };
        var annotationContent_1 = {};
        annotation.record.propertyValues.forEach(function (propertyValue) {
            annotationContent_1[propertyValue.name] = parseValue(propertyValue.value, annotation.fullyQualifiedName + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType_1, annotation.term);
            if (annotationContent_1.hasOwnProperty("Action") &&
                (!annotation.record ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
                annotationContent_1.ActionTarget =
                    (currentTarget.actions && currentTarget.actions[annotationContent_1.Action]) ||
                        objectMap[annotationContent_1.Action];
                if (!annotationContent_1.ActionTarget) {
                    ANNOTATION_ERRORS.push({
                        message: "Unable to resolve the action " +
                            annotationContent_1.Action +
                            " defined for " +
                            annotation.fullyQualifiedName
                    });
                    // Add to diagnostics
                    // debugger;
                }
            }
        });
        return Object.assign(annotationTerm_1, annotationContent_1);
    }
    else if (annotation.collection === undefined) {
        if (annotation.value) {
            return parseValue(annotation.value, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, "", annotation.term);
        }
        else {
            return true;
        }
    }
    else if (annotation.collection) {
        var collection = parseCollection(annotation.collection, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, "", annotation.term);
        collection.fullyQualifiedName = annotation.fullyQualifiedName;
        return collection;
    }
    else {
        throw new Error("Unsupported case");
    }
}
function createResolvePathFn(entityType, objectMap) {
    return function (relativePath, includeVisitedObjects) {
        var annotationTerm = "";
        var annotationType = "";
        return resolveTarget(objectMap, entityType, relativePath, false, includeVisitedObjects, annotationType, annotationTerm);
    };
}
function resolveNavigationProperties(entityTypes, associations, objectMap) {
    entityTypes.forEach(function (entityType) {
        entityType.navigationProperties = entityType.navigationProperties.map(function (navProp) {
            var outNavProp = {
                _type: "NavigationProperty",
                name: navProp.name,
                fullyQualifiedName: navProp.fullyQualifiedName,
                partner: navProp.hasOwnProperty("partner") ? navProp.partner : undefined,
                // targetTypeName: FullyQualifiedName;
                // targetType: EntityType;
                isCollection: navProp.hasOwnProperty("isCollection") ? navProp.isCollection : false,
                containsTarget: navProp.hasOwnProperty("containsTarget")
                    ? navProp.containsTarget
                    : false,
                referentialConstraint: navProp.referentialConstraint
                    ? navProp.referentialConstraint
                    : [],
                annotations: {}
            };
            if (navProp.targetTypeName) {
                outNavProp.targetType = objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        outNavProp.targetType = objectMap[associationEnd.type];
                        outNavProp.isCollection = associationEnd.multiplicity === "*";
                    }
                }
            }
            if (outNavProp.targetType) {
                outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
            }
            var outNavPropReq = outNavProp;
            objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
            return outNavPropReq;
        });
        entityType.resolvePath = createResolvePathFn(entityType, objectMap);
    });
}
function linkActionsToEntityType(namespace, actions, objectMap) {
    actions.forEach(function (action) {
        if (!action.annotations) {
            action.annotations = {};
        }
        if (action.isBound) {
            var sourceEntityType = objectMap[action.sourceType];
            action.sourceEntityType = sourceEntityType;
            if (sourceEntityType) {
                if (!sourceEntityType.actions) {
                    sourceEntityType.actions = {};
                }
                sourceEntityType.actions[action.name] = action;
                sourceEntityType.actions[namespace + "." + action.name] = action;
            }
            action.returnEntityType = objectMap[action.returnType];
        }
    });
}
function linkEntityTypeToEntitySet(entitySets, objectMap, references) {
    entitySets.forEach(function (entitySet) {
        entitySet.entityType = objectMap[entitySet.entityTypeName];
        if (!entitySet.entityType) {
            entitySet.entityType = objectMap[unalias(references, entitySet.entityTypeName)];
        }
        if (!entitySet.annotations) {
            entitySet.annotations = {};
        }
        if (!entitySet.entityType.annotations) {
            entitySet.entityType.annotations = {};
        }
        entitySet.entityType.keys.forEach(function (keyProp) {
            keyProp.isKey = true;
        });
    });
}
function linkEntityTypeToSingleton(singletons, objectMap, references) {
    if (singletons === void 0) { singletons = []; }
    singletons.forEach(function (singleton) {
        singleton.type = objectMap[singleton.typeName];
        if (!singleton.type) {
            singleton.type = objectMap[unalias(references, singleton.typeName)];
        }
        if (!singleton.annotations) {
            singleton.annotations = {};
        }
        if (!singleton.type.annotations) {
            singleton.type.annotations = {};
        }
        singleton.type.keys.forEach(function (keyProp) {
            keyProp.isKey = true;
        });
    });
}
function linkPropertiesToComplexTypes(entityTypes, objectMap) {
    function link(property) {
        if (!property.annotations) {
            property.annotations = {};
        }
        if (property.type.indexOf("Edm") === -1) {
            var complexType = void 0;
            if (property.type.startsWith("Collection")) {
                var complexTypeName = property.type.substr(11, property.type.length - 12);
                complexType = objectMap[complexTypeName];
            }
            else {
                complexType = objectMap[property.type];
            }
            if (complexType) {
                property.targetType = complexType;
                if (complexType.properties) {
                    complexType.properties.forEach(link);
                }
            }
        }
    }
    entityTypes.forEach(function (entityType) {
        entityType.entityProperties.forEach(link);
    });
}
function prepareComplexTypes(complexTypes, associations, objectMap) {
    complexTypes.forEach(function (complexType) {
        complexType.annotations = {};
        complexType.properties.forEach(function (property) {
            if (!property.annotations) {
                property.annotations = {};
            }
        });
        complexType.navigationProperties = complexType.navigationProperties.map(function (navProp) {
            if (!navProp.annotations) {
                navProp.annotations = {};
            }
            var outNavProp = {
                _type: "NavigationProperty",
                name: navProp.name,
                fullyQualifiedName: navProp.fullyQualifiedName,
                partner: navProp.hasOwnProperty("partner") ? navProp.partner : undefined,
                // targetTypeName: FullyQualifiedName;
                // targetType: EntityType;
                isCollection: navProp.hasOwnProperty("isCollection") ? navProp.isCollection : false,
                containsTarget: navProp.hasOwnProperty("containsTarget")
                    ? navProp.containsTarget
                    : false,
                referentialConstraint: navProp.referentialConstraint
                    ? navProp.referentialConstraint
                    : []
            };
            if (navProp.targetTypeName) {
                outNavProp.targetType = objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        outNavProp.targetType = objectMap[associationEnd.type];
                        outNavProp.isCollection = associationEnd.multiplicity === "*";
                    }
                }
            }
            if (outNavProp.targetType) {
                outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
            }
            var outNavPropReq = outNavProp;
            objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
            return outNavPropReq;
        });
    });
}
function splitTerm(references, termValue) {
    var aliasedTerm = alias(references, termValue);
    var lastDot = aliasedTerm.lastIndexOf(".");
    var termAlias = aliasedTerm.substr(0, lastDot);
    var term = aliasedTerm.substr(lastDot + 1);
    return [termAlias, term];
}
/**
 * Resolve a specific path
 * @param sPath
 */
function createGlobalResolve(convertedOutput, objectMap) {
    return function resolvePath(sPath) {
        var aPathSplit = sPath.split("/");
        if (aPathSplit.shift() !== "") {
            throw new Error("Cannot deal with relative path");
        }
        var entitySetName = aPathSplit.shift();
        var entitySet = convertedOutput.entitySets.find(function (et) { return et.name === entitySetName; });
        if (!entitySet) {
            return {
                target: convertedOutput.entityContainer,
                objectPath: [convertedOutput.entityContainer]
            };
        }
        if (aPathSplit.length === 0) {
            return {
                target: entitySet,
                objectPath: [convertedOutput.entityContainer, entitySet]
            };
        }
        else {
            var targetResolution = resolveTarget(objectMap, entitySet, "/" + aPathSplit.join("/"), false, true);
            if (targetResolution.target) {
                targetResolution.visitedObjects.push(targetResolution.target);
            }
            return {
                target: targetResolution.target,
                objectPath: targetResolution.visitedObjects
            };
        }
    };
}
var ANNOTATION_ERRORS = [];
var ALL_ANNOTATION_ERRORS = {};
function convertTypes(parserOutput) {
    ANNOTATION_ERRORS = [];
    var objectMap = buildObjectMap(parserOutput);
    resolveNavigationProperties(parserOutput.schema.entityTypes, parserOutput.schema.associations, objectMap);
    if (!parserOutput.schema.entityContainer.annotations) {
        parserOutput.schema.entityContainer.annotations = {};
    }
    linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions, objectMap);
    linkEntityTypeToEntitySet(parserOutput.schema.entitySets, objectMap, parserOutput.references);
    linkEntityTypeToSingleton(parserOutput.schema.singletons, objectMap, parserOutput.references);
    linkPropertiesToComplexTypes(parserOutput.schema.entityTypes, objectMap);
    prepareComplexTypes(parserOutput.schema.complexTypes, parserOutput.schema.associations, objectMap);
    var toResolve = [];
    var unresolvedAnnotations = [];
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            var objectMapElement = objectMap[currentTargetName];
            if (!objectMapElement) {
                if (currentTargetName && currentTargetName.indexOf("@") !== -1) {
                    annotationList.__source = annotationSource;
                    unresolvedAnnotations.push(annotationList);
                }
            }
            else if (typeof objectMapElement === "object") {
                var allTargets = [objectMapElement];
                var bOverrideExisting_1 = true;
                if (objectMapElement._type === "UnboundGenericAction") {
                    allTargets = objectMapElement.actions;
                    bOverrideExisting_1 = false;
                }
                allTargets.forEach(function (currentTarget) {
                    if (currentTargetName !== currentTarget.fullyQualifiedName) {
                        currentTargetName = currentTarget.fullyQualifiedName;
                    }
                    if (!currentTarget.annotations) {
                        currentTarget.annotations = {};
                    }
                    annotationList.annotations.forEach(function (annotation) {
                        var _a, _b;
                        var _c = splitTerm(exports.defaultReferences, annotation.term), vocAlias = _c[0], vocTerm = _c[1];
                        if (!currentTarget.annotations[vocAlias]) {
                            currentTarget.annotations[vocAlias] = {};
                        }
                        if (!currentTarget.annotations._annotations) {
                            currentTarget.annotations._annotations = {};
                        }
                        var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                        if (!bOverrideExisting_1 &&
                            ((_b = (_a = currentTarget.annotations) === null || _a === void 0 ? void 0 : _a[vocAlias]) === null || _b === void 0 ? void 0 : _b[vocTermWithQualifier]) !== undefined) {
                            return;
                        }
                        currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
                        switch (typeof currentTarget.annotations[vocAlias][vocTermWithQualifier]) {
                            case "string":
                                currentTarget.annotations[vocAlias][vocTermWithQualifier] = new String(currentTarget.annotations[vocAlias][vocTermWithQualifier]);
                                break;
                            case "boolean":
                                currentTarget.annotations[vocAlias][vocTermWithQualifier] = new Boolean(currentTarget.annotations[vocAlias][vocTermWithQualifier]);
                                break;
                        }
                        if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                            typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                            currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(exports.defaultReferences, vocAlias + "." + vocTerm);
                            currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                            currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationSource;
                        }
                        var annotationTarget = currentTargetName + "@" + unalias(exports.defaultReferences, vocAlias + "." + vocTermWithQualifier);
                        if (annotation.annotations && Array.isArray(annotation.annotations)) {
                            var subAnnotationList = {
                                target: annotationTarget,
                                annotations: annotation.annotations,
                                __source: annotationSource
                            };
                            unresolvedAnnotations.push(subAnnotationList);
                        }
                        else if (annotation.annotations &&
                            !currentTarget.annotations[vocAlias][vocTermWithQualifier].annotations) {
                            currentTarget.annotations[vocAlias][vocTermWithQualifier].annotations =
                                annotation.annotations;
                        }
                        currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                            currentTarget.annotations[vocAlias][vocTermWithQualifier];
                        objectMap[annotationTarget] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
                    });
                });
            }
        });
    });
    var extraUnresolvedAnnotations = [];
    unresolvedAnnotations.forEach(function (annotationList) {
        var currentTargetName = unalias(parserOutput.references, annotationList.target);
        var _a = currentTargetName.split("@"), baseObj = _a[0], annotationPart = _a[1];
        var targetSplit = annotationPart.split("/");
        baseObj = baseObj + "@" + targetSplit[0];
        var currentTarget = targetSplit.slice(1).reduce(function (currentObj, path) {
            if (!currentObj) {
                return null;
            }
            return currentObj[path];
        }, objectMap[baseObj]);
        if (!currentTarget) {
            ANNOTATION_ERRORS.push({
                message: "The following annotation target was not found on the service " + currentTargetName
            });
            // console.log("Missing target again " + currentTargetName);
        }
        else if (typeof currentTarget === "object") {
            if (!currentTarget.annotations) {
                currentTarget.annotations = {};
            }
            annotationList.annotations.forEach(function (annotation) {
                var _a = splitTerm(exports.defaultReferences, annotation.term), vocAlias = _a[0], vocTerm = _a[1];
                if (!currentTarget.annotations[vocAlias]) {
                    currentTarget.annotations[vocAlias] = {};
                }
                if (!currentTarget.annotations._annotations) {
                    currentTarget.annotations._annotations = {};
                }
                var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationList.__source, extraUnresolvedAnnotations);
                if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                    typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(exports.defaultReferences, vocAlias + "." + vocTerm);
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationList.__source;
                }
                currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
                objectMap[currentTargetName + "@" + unalias(exports.defaultReferences, vocAlias + "." + vocTermWithQualifier)] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
            });
        }
    });
    toResolve.forEach(function (resolveable) {
        var toResolve = resolveable.toResolve;
        var targetStr = toResolve.$target;
        var resolvedTarget = objectMap[targetStr];
        var annotationsTerm = toResolve.annotationsTerm, annotationType = toResolve.annotationType;
        delete toResolve.annotationType;
        delete toResolve.annotationsTerm;
        if (resolveable.inline && !(resolvedTarget instanceof String)) {
            // inline the resolved target
            var keys = void 0;
            for (keys in toResolve)
                delete toResolve[keys];
            Object.assign(toResolve, resolvedTarget);
        }
        else {
            // assign the resolved target
            toResolve.$target = resolvedTarget;
        }
        if (!resolvedTarget) {
            toResolve.targetString = targetStr;
            if (annotationsTerm && annotationType) {
                var oErrorMsg = {
                    message: "Unable to resolve the path expression: " +
                        targetStr +
                        "\n" +
                        "\n" +
                        "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                        "<Annotation Term = " +
                        annotationsTerm +
                        ">" +
                        "\n" +
                        "<Record Type = " +
                        annotationType +
                        ">" +
                        "\n" +
                        "<AnnotationPath = " +
                        targetStr +
                        ">"
                };
                addAnnotationErrorMessage(targetStr, oErrorMsg);
            }
            else {
                var property_1 = toResolve.term;
                var path = toResolve.path;
                var termInfo = targetStr ? targetStr.split("/")[0] : targetStr;
                var oErrorMsg = {
                    message: "Unable to resolve the path expression: " +
                        targetStr +
                        "\n" +
                        "\n" +
                        "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                        "<Annotation Term = " +
                        termInfo +
                        ">" +
                        "\n" +
                        "<PropertyValue Property = " +
                        property_1 +
                        "        Path= " +
                        path +
                        ">"
                };
                addAnnotationErrorMessage(targetStr, oErrorMsg);
            }
        }
    });
    for (var property in ALL_ANNOTATION_ERRORS) {
        ANNOTATION_ERRORS.push(ALL_ANNOTATION_ERRORS[property][0]);
    }
    parserOutput.entitySets = parserOutput.schema.entitySets;
    var convertedOutput = {
        version: parserOutput.version,
        annotations: parserOutput.schema.annotations,
        namespace: parserOutput.schema.namespace,
        entityContainer: parserOutput.schema.entityContainer,
        actions: parserOutput.schema.actions,
        entitySets: parserOutput.schema.entitySets,
        singletons: parserOutput.schema.singletons,
        entityTypes: parserOutput.schema.entityTypes,
        complexTypes: parserOutput.schema.complexTypes,
        references: exports.defaultReferences,
        diagnostics: ANNOTATION_ERRORS.concat()
    };
    convertedOutput.resolvePath = createGlobalResolve(convertedOutput, objectMap);
    return convertedOutput;
}
exports.convertTypes = convertTypes;
function revertValueToGenericType(references, value) {
    var result;
    if (typeof value === "string") {
        var valueMatches_1 = value.match(/(\w+)\.\w+\/.*/);
        if (valueMatches_1 && references.find(function (ref) { return ref.alias === valueMatches_1[1]; })) {
            result = {
                type: "EnumMember",
                EnumMember: value
            };
        }
        else {
            result = {
                type: "String",
                String: value
            };
        }
    }
    else if (Array.isArray(value)) {
        result = {
            type: "Collection",
            Collection: value.map(function (anno) { return revertCollectionItemToGenericType(references, anno); })
        };
    }
    else if (typeof value === "boolean") {
        result = {
            type: "Bool",
            Bool: value
        };
    }
    else if (typeof value === "number") {
        if (value.toString() === value.toFixed()) {
            result = {
                type: "Int",
                Int: value
            };
        }
        else {
            result = {
                type: "Decimal",
                Decimal: value
            };
        }
    }
    else if (typeof value === "object" && value.isDecimal && value.isDecimal()) {
        result = {
            type: "Decimal",
            Decimal: value.valueOf()
        };
    }
    else if (value.type === "Path") {
        result = {
            type: "Path",
            Path: value.path
        };
    }
    else if (value.type === "AnnotationPath") {
        result = {
            type: "AnnotationPath",
            AnnotationPath: value.value
        };
    }
    else if (value.type === "PropertyPath") {
        result = {
            type: "PropertyPath",
            PropertyPath: value.value
        };
    }
    else if (value.type === "NavigationPropertyPath") {
        result = {
            type: "NavigationPropertyPath",
            NavigationPropertyPath: value.value
        };
    }
    else if (Object.prototype.hasOwnProperty.call(value, "$Type")) {
        result = {
            type: "Record",
            Record: revertCollectionItemToGenericType(references, value)
        };
    }
    return result;
}
function revertCollectionItemToGenericType(references, collectionItem) {
    if (typeof collectionItem === "string") {
        return collectionItem;
    }
    else if (typeof collectionItem === "object") {
        if (collectionItem.hasOwnProperty("$Type")) {
            // Annotation Record
            var outItem_1 = {
                type: collectionItem.$Type,
                propertyValues: []
            };
            // Could validate keys and type based on $Type
            Object.keys(collectionItem).forEach(function (collectionKey) {
                if (collectionKey !== "$Type" &&
                    collectionKey !== "term" &&
                    collectionKey !== "__source" &&
                    collectionKey !== "qualifier" &&
                    collectionKey !== "ActionTarget" &&
                    collectionKey !== "fullyQualifiedName" &&
                    collectionKey !== "annotations") {
                    var value = collectionItem[collectionKey];
                    outItem_1.propertyValues.push({
                        name: collectionKey,
                        value: revertValueToGenericType(references, value)
                    });
                }
                else if (collectionKey === "annotations") {
                    var annotations_1 = collectionItem[collectionKey];
                    outItem_1.annotations = [];
                    Object.keys(annotations_1)
                        .filter(function (key) { return key !== "_annotations"; })
                        .forEach(function (key) {
                        Object.keys(annotations_1[key]).forEach(function (term) {
                            var _a;
                            var parsedAnnotation = revertTermToGenericType(references, annotations_1[key][term]);
                            if (!parsedAnnotation.term) {
                                var unaliasedTerm = unalias(references, key + "." + term);
                                if (unaliasedTerm) {
                                    var qualifiedSplit = unaliasedTerm.split("#");
                                    parsedAnnotation.term = qualifiedSplit[0];
                                    if (qualifiedSplit.length > 1) {
                                        parsedAnnotation.qualifier = qualifiedSplit[1];
                                    }
                                }
                            }
                            (_a = outItem_1.annotations) === null || _a === void 0 ? void 0 : _a.push(parsedAnnotation);
                        });
                    });
                }
            });
            return outItem_1;
        }
        else if (collectionItem.type === "PropertyPath") {
            return {
                type: "PropertyPath",
                PropertyPath: collectionItem.value
            };
        }
        else if (collectionItem.type === "AnnotationPath") {
            return {
                type: "AnnotationPath",
                AnnotationPath: collectionItem.value
            };
        }
        else if (collectionItem.type === "NavigationPropertyPath") {
            return {
                type: "NavigationPropertyPath",
                NavigationPropertyPath: collectionItem.value
            };
        }
    }
}
function revertTermToGenericType(references, annotation) {
    var baseAnnotation = {
        term: annotation.term,
        qualifier: annotation.qualifier
    };
    if (Array.isArray(annotation)) {
        // Collection
        if (annotation.hasOwnProperty("annotations")) {
            baseAnnotation.annotations = [];
            var currentAnnotations_1 = annotation.annotations;
            Object.keys(currentAnnotations_1)
                .filter(function (key) { return key !== "_annotations"; })
                .forEach(function (key) {
                Object.keys(currentAnnotations_1[key]).forEach(function (term) {
                    var _a;
                    var parsedAnnotation = revertTermToGenericType(references, currentAnnotations_1[key][term]);
                    if (!parsedAnnotation.term) {
                        var unaliasedTerm = unalias(references, key + "." + term);
                        if (unaliasedTerm) {
                            var qualifiedSplit = unaliasedTerm.split("#");
                            parsedAnnotation.term = qualifiedSplit[0];
                            if (qualifiedSplit.length > 1) {
                                parsedAnnotation.qualifier = qualifiedSplit[1];
                            }
                        }
                    }
                    (_a = baseAnnotation.annotations) === null || _a === void 0 ? void 0 : _a.push(parsedAnnotation);
                });
            });
        }
        return __assign(__assign({}, baseAnnotation), { collection: annotation.map(function (anno) { return revertCollectionItemToGenericType(references, anno); }) });
    }
    else if (annotation.hasOwnProperty("$Type")) {
        return __assign(__assign({}, baseAnnotation), { record: revertCollectionItemToGenericType(references, annotation) });
    }
    else {
        return __assign(__assign({}, baseAnnotation), { value: revertValueToGenericType(references, annotation) });
    }
}
exports.revertTermToGenericType = revertTermToGenericType;


/***/ }),

/***/ 1014:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var parser_1 = __webpack_require__(5129);
Object.defineProperty(exports, "parseEDMX", ({ enumerable: true, get: function () { return parser_1.parseEDMX; } }));
var merger_1 = __webpack_require__(8027);
Object.defineProperty(exports, "merge", ({ enumerable: true, get: function () { return merger_1.merge; } }));


/***/ }),

/***/ 8027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.merge = void 0;
const utils_1 = __webpack_require__(1878);
function merge(parserOutputs) {
    const outParserOutput = new utils_1.MergedParserOutput(parserOutputs[0]);
    parserOutputs.forEach((parserOutput) => {
        outParserOutput.addParserOutput(parserOutput);
    });
    return outParserOutput;
}
exports.merge = merge;


/***/ }),

/***/ 5129:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEDMX = void 0;
const xml_js_1 = __webpack_require__(4139);
const utils_1 = __webpack_require__(1878);
const Parser_1 = __webpack_require__(6162);
const v2annotations_1 = __webpack_require__(6511);
const collectionRegexp = /Collection\(([^)]+)\)/;
// Type guards
function isV4NavProperty(navPropertyAttributes) {
    return (navPropertyAttributes.Type !== null &&
        navPropertyAttributes.Type !== undefined);
}
// Parser Methods
/**
 * Retrieves the name of the keys for that entity type
 * @param propertyRefs {EDMX.PropertyRef} property reference
 */
function getEntityTypeKeys(propertyRefs) {
    return propertyRefs.map(propertyRef => propertyRef._attributes.Name);
}
/**
 * Parse the EDMX.Property to retrieve the property
 * @param entityProperties
 * @param entityKeys
 * @param entityTypeFQN
 */
function parseProperties(entityProperties, entityKeys, entityTypeFQN, annotationLists) {
    return entityProperties.reduce((outObject, entityProperty) => {
        const edmProperty = {
            _type: "Property",
            name: entityProperty._attributes.Name,
            fullyQualifiedName: `${entityTypeFQN}/${entityProperty._attributes.Name}`,
            type: entityProperty._attributes.Type
        };
        if (entityProperty._attributes.MaxLength) {
            edmProperty.maxLength = parseInt(entityProperty._attributes.MaxLength);
        }
        if (entityProperty._attributes.Precision) {
            edmProperty.precision = parseInt(entityProperty._attributes.Precision);
        }
        if (entityProperty._attributes.Scale) {
            edmProperty.scale = parseInt(entityProperty._attributes.Scale);
        }
        if (entityProperty._attributes.Nullable) {
            edmProperty.nullable = entityProperty._attributes.Nullable !== "false";
        }
        if (entityProperty._attributes.DefaultValue) {
            switch (edmProperty.type) {
                case "Edm.Int16":
                case "Edm.Byte":
                case "Edm.Int32":
                case "Edm.Int64":
                    edmProperty.defaultValue = parseInt(entityProperty._attributes.DefaultValue);
                    break;
                case "Edm.Decimal":
                    edmProperty.defaultValue = parseFloat(entityProperty._attributes.DefaultValue);
                    break;
                case "Edm.Boolean":
                    edmProperty.defaultValue = entityProperty._attributes.DefaultValue === "true";
                    break;
                default:
                    edmProperty.defaultValue = entityProperty._attributes.DefaultValue;
                    break;
            }
        }
        outObject.entityProperties.push(edmProperty);
        if (entityKeys.indexOf(edmProperty.name) !== -1) {
            outObject.entityKeys.push(edmProperty);
        }
        const v2Annotations = v2annotations_1.convertV2Annotations(entityProperty._attributes, "Property", entityProperty._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(edmProperty.fullyQualifiedName, v2Annotations));
        }
        return outObject;
    }, { entityProperties: [], entityKeys: [] });
}
function parseReferentialConstraint(referentialConstraints, sourceTypeName, targetTypeName) {
    return referentialConstraints.reduce((outArray, refCon) => {
        outArray.push({
            sourceTypeName: sourceTypeName,
            sourceProperty: refCon._attributes.Property,
            targetTypeName: targetTypeName,
            targetProperty: refCon._attributes.ReferencedProperty
        });
        return outArray;
    }, []);
}
function parseV2ReferentialConstraint(referentialConstraints, associationEnds) {
    return referentialConstraints.reduce((outArray, refCon) => {
        let sourceEnd = associationEnds.find(assEnd => assEnd.role === refCon.Principal._attributes.Role);
        let targetEnd = associationEnds.find(assEnd => assEnd.role === refCon.Dependent._attributes.Role);
        if (sourceEnd && targetEnd) {
            let sourceProperties = utils_1.ensureArray(refCon.Principal.PropertyRef);
            let targetProperties = utils_1.ensureArray(refCon.Dependent.PropertyRef);
            if (sourceEnd.multiplicity !== "1") {
                targetEnd = sourceEnd;
                sourceEnd = associationEnds.find(assEnd => assEnd.role === refCon.Dependent._attributes.Role);
                targetProperties = sourceProperties;
                sourceProperties = utils_1.ensureArray(refCon.Dependent.PropertyRef);
            }
            sourceProperties.forEach((sourceProperty, propertyIndex) => {
                outArray.push({
                    // @ts-ignore
                    sourceTypeName: sourceEnd.type,
                    sourceProperty: sourceProperty._attributes.Name,
                    // @ts-ignore
                    targetTypeName: targetEnd.type,
                    targetProperty: targetProperties[propertyIndex]._attributes.Name
                });
            });
        }
        return outArray;
    }, []);
}
function parseNavigationProperties(navigationProperties, currentEntityType, entityTypeFQN, annotationLists) {
    return navigationProperties.reduce((outArray, navigationProperty) => {
        // V4
        const attributes = navigationProperty._attributes;
        if (isV4NavProperty(attributes)) {
            const matches = attributes.Type.match(collectionRegexp);
            const isCollection = matches !== null;
            const typeName = matches ? matches[1] : attributes.Type;
            outArray.push({
                _type: "NavigationProperty",
                name: attributes.Name,
                fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
                partner: attributes.Partner,
                containsTarget: attributes.ContainsTarget === "true",
                isCollection,
                targetTypeName: typeName,
                referentialConstraint: parseReferentialConstraint(utils_1.ensureArray(navigationProperty.ReferentialConstraint), currentEntityType._attributes.Name, typeName)
            });
        }
        else {
            // V2
            const { Relationship, ToRole, FromRole } = attributes;
            outArray.push({
                _type: "NavigationProperty",
                name: attributes.Name,
                fullyQualifiedName: `${entityTypeFQN}/${attributes.Name}`,
                relationship: Relationship,
                toRole: ToRole,
                fromRole: FromRole
            });
            const v2Annotations = v2annotations_1.convertV2Annotations(attributes, "Property", attributes.Name);
            if (v2Annotations.length > 0) {
                annotationLists.push(createAnnotationList(`${entityTypeFQN}/${attributes.Name}`, v2Annotations));
            }
        }
        return outArray;
    }, []);
}
/**
 * Parse the multiplicty string and return the corresponding enum
 * @param multiplicity the multiplicity string
 * @returns the enum value
 */
function getMultiplicityFromString(multiplicity) {
    switch (multiplicity) {
        case "1":
            return Parser_1.Multiplicity.One;
        case "0..1":
            return Parser_1.Multiplicity.ZeroOrOne;
        case "*":
            return Parser_1.Multiplicity.Many;
    }
    return Parser_1.Multiplicity.Unknown;
}
function parseAssociationSets(associations, namespace) {
    return associations.map(association => {
        const associationFQN = `${namespace}.${association._attributes.Name}`;
        const associationEnd = utils_1.ensureArray(association.End).map((endValue) => {
            return {
                entitySet: endValue._attributes.EntitySet,
                role: endValue._attributes.Role
            };
        });
        return {
            fullyQualifiedName: associationFQN,
            name: association._attributes.Name,
            association: association._attributes.Association,
            associationEnd: associationEnd
        };
    });
}
function parseAssociations(associations, namespace) {
    return associations.map(association => {
        const associationFQN = `${namespace}.${association._attributes.Name}`;
        const associationEnd = utils_1.ensureArray(association.End).map((endValue) => {
            return {
                type: endValue._attributes.Type,
                role: endValue._attributes.Role,
                multiplicity: getMultiplicityFromString(endValue._attributes.Multiplicity)
            };
        });
        return {
            fullyQualifiedName: associationFQN,
            name: association._attributes.Name,
            associationEnd: associationEnd,
            referentialConstraints: parseV2ReferentialConstraint(utils_1.ensureArray(association.ReferentialConstraint), associationEnd)
        };
    });
}
function parseEntityTypes(entityTypes, annotations, namespace) {
    return entityTypes.reduce((outArray, entityType) => {
        const entityKeyNames = entityType.Key ? getEntityTypeKeys(utils_1.ensureArray(entityType.Key.PropertyRef)) : [];
        const entityTypeFQN = `${namespace}.${entityType._attributes.Name}`;
        const { entityProperties, entityKeys } = parseProperties(utils_1.ensureArray(entityType.Property), entityKeyNames, entityTypeFQN, annotations);
        const navigationProperties = parseNavigationProperties(utils_1.ensureArray(entityType.NavigationProperty), entityType, entityTypeFQN, annotations);
        outArray.push({
            _type: "EntityType",
            name: entityType._attributes.Name,
            fullyQualifiedName: entityTypeFQN,
            keys: entityKeys,
            entityProperties,
            navigationProperties: navigationProperties
        });
        return outArray;
    }, []);
}
function parseComplexTypes(complexTypes, annotationLists, namespace) {
    return complexTypes.reduce((outArray, complexType) => {
        const complexTypeFQN = `${namespace}.${complexType._attributes.Name}`;
        const { entityProperties, entityKeys } = parseProperties(utils_1.ensureArray(complexType.Property), [], complexTypeFQN, annotationLists);
        const navigationProperties = parseNavigationProperties(utils_1.ensureArray(complexType.NavigationProperty), complexType, complexTypeFQN, annotationLists);
        outArray.push({
            _type: "ComplexType",
            name: complexType._attributes.Name,
            fullyQualifiedName: complexTypeFQN,
            properties: entityProperties,
            navigationProperties
        });
        return outArray;
    }, []);
}
function parseEntitySets(entitySets, namespace, entityContainerName, annotationLists) {
    const outEntitySets = entitySets.map(entitySet => {
        const outEntitySet = {
            _type: "EntitySet",
            name: entitySet._attributes.Name,
            entityTypeName: entitySet._attributes.EntityType,
            navigationPropertyBinding: {},
            fullyQualifiedName: `${namespace}.${entityContainerName}/${entitySet._attributes.Name}`
        };
        const v2Annotations = v2annotations_1.convertV2Annotations(entitySet._attributes, "EntitySet", entitySet._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(outEntitySet.fullyQualifiedName, v2Annotations));
        }
        return outEntitySet;
    });
    entitySets.forEach(entitySet => {
        const currentOutEntitySet = outEntitySets.find(outEntitySet => outEntitySet.name === entitySet._attributes.Name);
        if (currentOutEntitySet) {
            utils_1.ensureArray(entitySet.NavigationPropertyBinding).forEach(navPropertyBinding => {
                const currentTargetEntitySet = outEntitySets.find(outEntitySet => outEntitySet.name === navPropertyBinding._attributes.Target);
                if (currentTargetEntitySet) {
                    currentOutEntitySet.navigationPropertyBinding[navPropertyBinding._attributes.Path] = currentTargetEntitySet;
                }
            });
        }
    });
    return outEntitySets;
}
function parseSingletons(singletons, namespace, entityContainerName, annotationLists) {
    const outSingletons = singletons.map(singleton => {
        const outSingleton = {
            _type: "Singleton",
            name: singleton._attributes.Name,
            typeName: singleton._attributes.Type,
            nullable: singleton._attributes.Nullable !== "false",
            navigationPropertyBinding: {},
            fullyQualifiedName: `${namespace}.${entityContainerName}/${singleton._attributes.Name}`
        };
        const v2Annotations = v2annotations_1.convertV2Annotations(singleton._attributes, "Singleton", singleton._attributes.Name);
        if (v2Annotations.length > 0) {
            annotationLists.push(createAnnotationList(outSingleton.fullyQualifiedName, v2Annotations));
        }
        return outSingleton;
    });
    singletons.forEach(singleton => {
        const currentOutSingleton = outSingletons.find(outSingleton => outSingleton.name === singleton._attributes.Name);
        if (currentOutSingleton) {
            utils_1.ensureArray(singleton.NavigationPropertyBinding).forEach(navPropertyBinding => {
                const currentTargetSingleton = outSingletons.find(outSingleton => outSingleton.name === navPropertyBinding._attributes.Target);
                if (currentTargetSingleton) {
                    currentOutSingleton.navigationPropertyBinding[navPropertyBinding._attributes.Path] = currentTargetSingleton;
                }
            });
        }
    });
    return outSingletons;
}
function parseActions(actions, namespace, isFunction = false) {
    return actions.map(action => {
        let actionEntityType = `${utils_1.ensureArray(action.Parameter)
            .filter(param => param._attributes.Name === action._attributes.EntitySetPath)
            .map(param => param._attributes.Type)}`;
        const isBound = action._attributes.IsBound === "true";
        let actionFQN = `${action._attributes.Name}()`;
        if (isBound) {
            if (!actionEntityType) {
                actionEntityType = `${utils_1.ensureArray(action.Parameter)[0]._attributes.Type}`;
            }
            actionFQN = `${namespace}.${action._attributes.Name}(${actionEntityType})`;
        }
        return {
            _type: "Action",
            name: action._attributes.Name,
            isBound: isBound,
            sourceType: actionEntityType,
            fullyQualifiedName: actionFQN,
            isFunction: isFunction,
            parameters: utils_1.ensureArray(action.Parameter).map(param => {
                return {
                    _type: "ActionParameter",
                    fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
                    type: param._attributes.Type,
                    isEntitySet: param._attributes.Name === action._attributes.EntitySetPath
                };
            }),
            returnType: action.ReturnType ? action.ReturnType._attributes.Type : ""
        };
    });
}
function parseFunctionImport(actions, entitySets, namespace) {
    return actions.map(action => {
        const targetEntitySet = entitySets.find(et => et.name === action._attributes.EntitySet);
        let actionFQN = `${namespace}/${action._attributes.Name}()`;
        return {
            _type: "Action",
            name: action._attributes.Name,
            isBound: false,
            sourceType: targetEntitySet ? targetEntitySet.entityTypeName : "",
            fullyQualifiedName: actionFQN,
            isFunction: false,
            parameters: utils_1.ensureArray(action.Parameter).map(param => {
                return {
                    _type: "ActionParameter",
                    fullyQualifiedName: `${actionFQN}/${param._attributes.Name}`,
                    type: param._attributes.Type,
                    isEntitySet: false
                };
            }),
            returnType: action._attributes.ReturnType ? action._attributes.ReturnType : ""
        };
    });
}
function parsePropertyValues(propertyValues, currentTarget, annotationsLists) {
    return propertyValues.map(propertyValue => {
        const { Annotation, _attributes, ...properties } = propertyValue;
        const outPropertyValue = {};
        if (_attributes) {
            const attributeKey = Object.keys(_attributes).find(keyName => keyName !== "Property");
            outPropertyValue.name = _attributes.Property;
            let currentPropertyTarget = `${currentTarget}/${outPropertyValue.name}`;
            if (properties && Object.keys(properties).length > 0) {
                outPropertyValue.value = parseExpression(properties, currentPropertyTarget, annotationsLists);
            }
            else if (attributeKey) {
                outPropertyValue.value = parseInlineExpression({ [attributeKey]: _attributes[attributeKey] }, currentPropertyTarget, annotationsLists);
            }
            if (propertyValue.Annotation) {
                const propertyAnnotations = parseAnnotations(utils_1.ensureArray(propertyValue.Annotation), currentPropertyTarget, annotationsLists);
                if (propertyAnnotations && propertyAnnotations.length > 0) {
                    annotationsLists.push(createAnnotationList(currentPropertyTarget, propertyAnnotations));
                }
            }
        }
        return outPropertyValue;
    });
}
function parseRecord(record, currentTarget, annotationsLists) {
    const recordAnnotations = parseAnnotations(utils_1.ensureArray(record.Annotation), currentTarget, annotationsLists);
    if (recordAnnotations && recordAnnotations.length > 0) {
        annotationsLists.push(createAnnotationList(currentTarget, recordAnnotations));
    }
    return {
        type: record._attributes ? unalias(record._attributes.Type) : undefined,
        propertyValues: parsePropertyValues(utils_1.ensureArray(record.PropertyValue), currentTarget, annotationsLists)
    };
}
/**
 * Type Guard for the type of the current collection
 * @param collection
 * @param propertyNameToCheck
 */
function isCollectionOfType(collection, propertyNameToCheck) {
    return collection[propertyNameToCheck] != null;
}
function parseModelPath(propertyPath, modelPathType) {
    switch (modelPathType) {
        case "NavigationPropertyPath":
            return { type: "NavigationPropertyPath", NavigationPropertyPath: propertyPath._text };
        case "PropertyPath":
            return { type: "PropertyPath", PropertyPath: propertyPath._text };
        case "AnnotationPath":
            return { type: "AnnotationPath", AnnotationPath: propertyPath._text };
        case "Path":
            return { type: "Path", Path: propertyPath._text };
    }
}
function parseCollection(collection, currentTarget, annotationsLists) {
    if (isCollectionOfType(collection, "Record")) {
        const recordArray = utils_1.ensureArray(collection.Record).map((record, recordIndex) => parseRecord(record, currentTarget + "/" + recordIndex, annotationsLists));
        recordArray.type = "Record";
        return recordArray;
    }
    else if (isCollectionOfType(collection, "PropertyPath")) {
        const propertyPathArray = utils_1.ensureArray(collection.PropertyPath).map(propertyPath => parseModelPath(propertyPath, "PropertyPath"));
        propertyPathArray.type = "PropertyPath";
        return propertyPathArray;
    }
    else if (isCollectionOfType(collection, "NavigationPropertyPath")) {
        const navPropertyPathArray = utils_1.ensureArray(collection.NavigationPropertyPath).map(navPropertyPath => parseModelPath(navPropertyPath, "NavigationPropertyPath"));
        navPropertyPathArray.type = "NavigationPropertyPath";
        return navPropertyPathArray;
    }
    else if (isCollectionOfType(collection, "String")) {
        const stringArray = utils_1.ensureArray(collection.String).map(stringValue => stringValue._text);
        stringArray.type = "String";
        return stringArray;
    }
    else if (isCollectionOfType(collection, "AnnotationPath")) {
        const annotationPathArray = utils_1.ensureArray(collection.AnnotationPath).map(annotationPath => parseModelPath(annotationPath, "AnnotationPath"));
        annotationPathArray.type = "AnnotationPath";
        return annotationPathArray;
    }
    else if (isCollectionOfType(collection, "Path")) {
        const pathArray = utils_1.ensureArray(collection.Path).map(pathDefinition => parseModelPath(pathDefinition, "Path"));
        pathArray.type = "Path";
        return pathArray;
    }
    else if (isCollectionOfType(collection, "If")) {
        const stringArray = utils_1.ensureArray(collection.If).map(stringValue => stringValue._text);
        stringArray.type = "String";
        return stringArray;
    }
    else if (Object.keys(collection).length === 0) {
        return [];
    }
    else {
        // TODO Full Coverage
        console.error(`Cannot parse ${JSON.stringify(collection)}, collection type is not supported`);
    }
    return [];
}
function parseApply(applyExpression) {
    return applyExpression;
}
/**
 * Type Guard for the type of the current expression
 * @param annotation
 * @param propertyNameToCheck
 */
function isExpressionOfType(annotation, propertyNameToCheck) {
    return annotation[propertyNameToCheck] != null;
}
function parseInlineExpression(expression, currentTarget, annotationsLists) {
    const expressionKeys = Object.keys(expression);
    if (expressionKeys.length > 1) {
        throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
    }
    const expressionKey = expressionKeys[0];
    switch (expressionKey) {
        case "String":
            return {
                type: "String",
                String: expression[expressionKey]
            };
        case "Bool":
            return {
                type: "Bool",
                Bool: expression.Bool === "true"
            };
        case "Decimal":
            return {
                type: "Decimal",
                Decimal: parseFloat(expression.Decimal)
            };
        case "Date":
            return {
                type: "Date",
                Date: expression.Date
            };
        case "Int":
            return {
                type: "Int",
                Int: parseInt(expression.Int)
            };
        case "Path":
            return {
                type: "Path",
                Path: expression.Path
            };
        case "PropertyPath":
            return {
                type: "PropertyPath",
                PropertyPath: expression.PropertyPath
            };
        case "AnnotationPath":
            return {
                type: "AnnotationPath",
                AnnotationPath: expression.AnnotationPath
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                NavigationPropertyPath: expression.NavigationPropertyPath
            };
        case "EnumMember":
            return {
                type: "EnumMember",
                EnumMember: expression[expressionKey]
            };
        case "Collection":
            return {
                type: "Collection",
                Collection: parseCollection(expression.Collection, currentTarget, annotationsLists)
            };
        case "Record":
            return {
                type: "Record",
                Record: parseRecord(expression.Record, currentTarget, annotationsLists)
            };
        case "Apply":
            return {
                type: "Apply",
                Apply: parseApply(expression.Apply)
            };
        default:
            console.error("Unsupported inline expression type " + expressionKey);
            return {
                type: "Unknown"
            };
    }
}
function parseExpression(expression, currentTarget, annotationsLists) {
    const expressionKeys = Object.keys(expression);
    if (expressionKeys.length > 1) {
        throw new Error(`Too many expressions defined on a single object ${JSON.stringify(expression)}`);
    }
    const expressionKey = expressionKeys[0];
    switch (expressionKey) {
        case "String":
            return {
                type: "String",
                String: expression[expressionKey]._text
            };
        case "Bool":
            return {
                type: "Bool",
                Bool: expression.Bool._text === "true"
            };
        case "Int":
            return {
                type: "Int",
                Int: parseInt(expression.Int._text)
            };
        case "Decimal":
            return {
                type: "Decimal",
                Decimal: parseFloat(expression.Decimal._text)
            };
        case "Path":
            return {
                type: "Path",
                Path: expression.Path._text
            };
        case "PropertyPath":
            return {
                type: "PropertyPath",
                PropertyPath: expression.PropertyPath._text
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                NavigationPropertyPath: expression.NavigationPropertyPath._text
            };
        case "AnnotationPath":
            return {
                type: "AnnotationPath",
                AnnotationPath: expression.AnnotationPath._text
            };
        case "EnumMember":
            return {
                type: "EnumMember",
                EnumMember: expression[expressionKey]._text
            };
        case "Collection":
            return {
                type: "Collection",
                Collection: parseCollection(expression.Collection, currentTarget, annotationsLists)
            };
        case "Record":
            return {
                type: "Record",
                Record: parseRecord(expression.Record, currentTarget, annotationsLists)
            };
        case "Apply":
            return {
                type: "Apply",
                Apply: parseApply(expression.Apply)
            };
        default:
            console.error("Unsupported expression type " + expressionKey);
            return {
                type: "Unknown"
            };
    }
}
function parseAnnotation(annotation, currentTarget, annotationsLists) {
    const { Term, Qualifier, ...others } = annotation._attributes;
    let outAnnotation = {
        term: unalias(Term),
        qualifier: Qualifier
    };
    let currentAnnotationTarget = `${currentTarget}@${unalias(Term)}`;
    if (Qualifier !== "" && Qualifier !== undefined) {
        currentAnnotationTarget += `#${Qualifier}`;
    }
    if (others && Object.keys(others).length > 0) {
        outAnnotation.value = parseInlineExpression(others, currentAnnotationTarget, annotationsLists);
    }
    if (annotation.Annotation) {
        const annotationAnnotations = parseAnnotations(utils_1.ensureArray(annotation.Annotation), currentAnnotationTarget, annotationsLists);
        if (annotationAnnotations && annotationAnnotations.length > 0) {
            annotationsLists.push(createAnnotationList(currentAnnotationTarget, annotationAnnotations));
        }
    }
    const keys = Object.keys(annotation).filter(keyValue => keyValue !== "_attributes" && keyValue !== "Annotation");
    let isCollection = false;
    if (isExpressionOfType(annotation, "Record")) {
        outAnnotation.record = parseRecord(annotation.Record, currentAnnotationTarget, annotationsLists);
    }
    else if (isExpressionOfType(annotation, "Collection")) {
        outAnnotation.collection = parseCollection(annotation.Collection, currentAnnotationTarget, annotationsLists);
    }
    else if (keys.length === 1) {
        outAnnotation.value = parseExpression({ [keys[0]]: annotation[keys[0]] }, currentAnnotationTarget, annotationsLists);
    }
    else if (keys.length > 1) {
        // TODO Full Coverage
        console.error(`Cannot parse ${JSON.stringify(annotation)}, expression type is not supported`);
    }
    return outAnnotation;
}
function parseAnnotations(annotations, currentTarget, annotationsLists) {
    return annotations.map(annotation => parseAnnotation(annotation, currentTarget, annotationsLists));
}
function createAnnotationList(target, annotations) {
    return {
        target: target,
        annotations: annotations
    };
}
function parseAnnotationLists(annotationLists, annotationsLists) {
    annotationLists
        .filter(annotationList => annotationList._attributes !== undefined)
        .forEach(annotationList => {
        annotationsLists.push(createAnnotationList(annotationList._attributes.Target, parseAnnotations(utils_1.ensureArray(annotationList.Annotation), annotationList._attributes.Target, annotationsLists)));
    });
}
function parseSchema(edmSchema, identification) {
    const namespace = edmSchema._attributes.Namespace;
    const annotations = [];
    const entityTypes = parseEntityTypes(utils_1.ensureArray(edmSchema.EntityType), annotations, namespace);
    const complexTypes = parseComplexTypes(utils_1.ensureArray(edmSchema.ComplexType), annotations, namespace);
    let entitySets = [];
    let singletons = [];
    let associationSets = [];
    let entityContainer = {};
    let actions = [];
    if (edmSchema.EntityContainer) {
        entitySets = parseEntitySets(utils_1.ensureArray(edmSchema.EntityContainer.EntitySet), namespace, edmSchema.EntityContainer._attributes.Name, annotations);
        singletons = parseSingletons(utils_1.ensureArray(edmSchema.EntityContainer.Singleton), namespace, edmSchema.EntityContainer._attributes.Name, annotations);
        associationSets = parseAssociationSets(utils_1.ensureArray(edmSchema.EntityContainer.AssociationSet), namespace);
        entityContainer = {
            name: edmSchema.EntityContainer._attributes.Name,
            fullyQualifiedName: `${namespace}.${edmSchema.EntityContainer._attributes.Name}`
        };
        actions = actions.concat(parseFunctionImport(utils_1.ensureArray(edmSchema.EntityContainer.FunctionImport), entitySets, entityContainer.fullyQualifiedName));
    }
    actions = actions.concat(parseActions(utils_1.ensureArray(edmSchema.Action), namespace));
    actions = actions.concat(parseActions(utils_1.ensureArray(edmSchema.Function), namespace, true));
    // const actionImports = parseActionImports(ensureArray(edmSchema.EntityContainer.ActionImport), namespace);
    const associations = parseAssociations(utils_1.ensureArray(edmSchema.Association), namespace);
    if (associationSets.length > 0)
        // V2 case
        entitySets.forEach(entitySet => {
            const entityType = entityTypes.find(entityType => entityType.fullyQualifiedName === entitySet.entityTypeName);
            entityType === null || entityType === void 0 ? void 0 : entityType.navigationProperties.forEach((navProp) => {
                const v2NavProp = navProp;
                const associationSet = associationSets.find(assoc => assoc.association === v2NavProp.relationship);
                if (associationSet) {
                    const associationEndEntitySets = associationSet.associationEnd.map((associationEnd) => {
                        return entitySets.find(entitySet => entitySet.name === associationEnd.entitySet);
                    });
                    const targetEntitySet = associationEndEntitySets.find((associationEntitySet) => (associationEntitySet === null || associationEntitySet === void 0 ? void 0 : associationEntitySet.fullyQualifiedName) !== entitySet.fullyQualifiedName);
                    if (targetEntitySet) {
                        entitySet.navigationPropertyBinding[navProp.name] = targetEntitySet;
                    }
                }
            });
        });
    if (associations.length > 0) {
        entityTypes.forEach(entityType => {
            entityType.navigationProperties.forEach((navProp) => {
                const v2NavProp = navProp;
                const association = associations.find(assoc => assoc.fullyQualifiedName === v2NavProp.relationship);
                if (association && association.referentialConstraints) {
                    v2NavProp.referentialConstraint = association.referentialConstraints;
                }
            });
        });
    }
    parseAnnotationLists(utils_1.ensureArray(edmSchema.Annotations), annotations);
    var annotationMap = {};
    annotationMap[identification] = annotations;
    return {
        associations,
        associationSets,
        annotations: annotationMap,
        entityContainer,
        namespace: namespace,
        entitySets,
        singletons,
        complexTypes,
        actions,
        entityTypes
    };
}
function parseReferences(references, schemas) {
    const outReferences = references.reduce((referencesArray, reference) => {
        const includes = utils_1.ensureArray(reference["edmx:Include"]);
        includes.forEach((include) => {
            referencesArray.push({
                uri: reference._attributes.Uri,
                alias: include._attributes.Alias,
                namespace: include._attributes.Namespace
            });
        });
        return referencesArray;
    }, []);
    schemas.forEach(schema => {
        if (schema && schema._attributes.Alias) {
            outReferences.push({
                uri: "",
                alias: schema._attributes.Alias,
                namespace: schema._attributes.Namespace
            });
        }
    });
    return outReferences;
}
let referenceMap = {};
function unalias(aliasedValue) {
    if (!aliasedValue) {
        return aliasedValue;
    }
    const [alias, value] = aliasedValue.split(".");
    const reference = referenceMap[alias];
    if (reference) {
        return `${reference.namespace}.${value}`;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (aliasedValue.indexOf("@") !== -1) {
            const [preAlias, postAlias] = aliasedValue.split("@");
            return `${preAlias}@${unalias(postAlias)}`;
        }
        else {
            return aliasedValue;
        }
    }
}
function mergeSchemas(schemas) {
    if (schemas.length === 1) {
        return schemas[0];
    }
    const associations = schemas.reduce((associations, schema) => {
        return associations.concat(schema.associations);
    }, []);
    const associationSets = schemas.reduce((associationSets, schema) => {
        return associationSets.concat(schema.associationSets);
    }, []);
    const entitySets = schemas.reduce((entitySets, schema) => {
        return entitySets.concat(schema.entitySets);
    }, []);
    const singletons = schemas.reduce((singletons, schema) => {
        return singletons.concat(schema.singletons);
    }, []);
    const entityTypes = schemas.reduce((entityTypes, schema) => {
        return entityTypes.concat(schema.entityTypes);
    }, []);
    const actions = schemas.reduce((actions, schema) => {
        return actions.concat(schema.actions);
    }, []);
    const complexTypes = schemas.reduce((complexTypes, schema) => {
        return complexTypes.concat(schema.complexTypes);
    }, []);
    let annotationMap = {};
    schemas.forEach(schema => {
        annotationMap = Object.assign(annotationMap, schema.annotations);
    });
    let entityContainer;
    let namespace;
    schemas.forEach(schema => {
        if (schema.entityContainer && Object.keys(schema.entityContainer).length > 0) {
            entityContainer = schema.entityContainer;
            namespace = schema.namespace;
        }
    });
    if (associationSets.length > 0)
        // V2 case
        entitySets.forEach(entitySet => {
            const entityType = entityTypes.find(entityType => entityType.fullyQualifiedName === entitySet.entityTypeName);
            entityType === null || entityType === void 0 ? void 0 : entityType.navigationProperties.forEach((navProp) => {
                const v2NavProp = navProp;
                const associationSet = associationSets.find(assoc => assoc.association === v2NavProp.relationship);
                if (associationSet) {
                    const associationEndEntitySets = associationSet.associationEnd.map((associationEnd) => {
                        return entitySets.find(entitySet => entitySet.name === associationEnd.entitySet);
                    });
                    const targetEntitySet = associationEndEntitySets.find((associationEntitySet) => (associationEntitySet === null || associationEntitySet === void 0 ? void 0 : associationEntitySet.fullyQualifiedName) !== entitySet.fullyQualifiedName);
                    if (targetEntitySet) {
                        entitySet.navigationPropertyBinding[navProp.name] = targetEntitySet;
                    }
                }
            });
        });
    if (associations.length > 0) {
        entityTypes.forEach(entityType => {
            entityType.navigationProperties.forEach((navProp) => {
                const v2NavProp = navProp;
                const association = associations.find(assoc => assoc.fullyQualifiedName === v2NavProp.relationship);
                if (association && association.referentialConstraints) {
                    v2NavProp.referentialConstraint = association.referentialConstraints;
                }
            });
        });
    }
    const outSchema = {
        associations,
        associationSets,
        annotations: annotationMap,
        entityContainer,
        namespace: namespace,
        entitySets,
        singletons,
        complexTypes,
        actions,
        entityTypes
    };
    return outSchema;
}
/**
 * Parse an edmx file and return a parsed Service Definition
 * @param xml {string} the original XML string
 * @param fileIdentification {string} a way to identify this file
 */
function parseEDMX(xml, fileIdentification = "serviceFile") {
    const jsonObj = xml_js_1.xml2js(xml, { compact: true });
    const schemas = utils_1.ensureArray(jsonObj["edmx:Edmx"]["edmx:DataServices"].Schema);
    const references = parseReferences(utils_1.ensureArray(jsonObj["edmx:Edmx"]["edmx:Reference"]), schemas);
    referenceMap = references.reduce((map, reference) => {
        map[reference.alias] = reference;
        return map;
    }, {});
    const parsedSchemas = schemas.map(schema => {
        return parseSchema(schema, fileIdentification);
    });
    const edmxDocument = new utils_1.ParserOutputInstance(fileIdentification, jsonObj["edmx:Edmx"]._attributes.Version, mergeSchemas(parsedSchemas), references);
    return edmxDocument;
}
exports.parseEDMX = parseEDMX;


/***/ }),

/***/ 1878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergedParserOutput = exports.ParserOutputInstance = exports.ensureArray = void 0;
function ensureArray(sourceObject) {
    if (sourceObject === undefined || sourceObject === null) {
        return [];
    }
    if (Array.isArray(sourceObject)) {
        return sourceObject;
    }
    else {
        return [sourceObject];
    }
}
exports.ensureArray = ensureArray;
class ParserOutputInstance {
    constructor(fileIdentification, version, schema, references) {
        this.identification = fileIdentification;
        this.references = references;
        this.version = version;
        this.schema = schema;
    }
    unalias(aliasedValue) {
        if (!aliasedValue) {
            return aliasedValue;
        }
        const [alias, value] = aliasedValue.split(".");
        const reference = this.references.find(reference => {
            return reference.alias === alias;
        });
        if (reference) {
            return `${reference.namespace}.${value}`;
        }
        else {
            // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
            if (aliasedValue.indexOf("@") !== -1) {
                const [preAlias, postAlias] = aliasedValue.split("@");
                return `${preAlias}@${this.unalias(postAlias)}`;
            }
            else {
                return aliasedValue;
            }
        }
    }
}
exports.ParserOutputInstance = ParserOutputInstance;
class MergedParserOutput {
    constructor(initialParserOutput) {
        this._references = [];
        this._parserOutput = [];
        this._annotations = {};
        this._associations = [];
        this._associationSets = [];
        this._entitySets = [];
        this._singletons = [];
        this._actions = [];
        this._entityContainer = {};
        this._entityTypes = [];
        this._complexTypes = [];
        this.identification = "mergedParserInstance";
        this.version = initialParserOutput.version;
        this._namespace = initialParserOutput.schema.namespace;
    }
    get references() {
        return this._references;
    }
    get schema() {
        return {
            associations: this._associations,
            associationSets: this._associationSets,
            annotations: this._annotations,
            entityContainer: this._entityContainer,
            namespace: this._namespace,
            entitySets: this._entitySets,
            singletons: this._singletons,
            complexTypes: this._complexTypes,
            actions: this._actions,
            entityTypes: this._entityTypes
        };
    }
    addParserOutput(parserOutput) {
        this._parserOutput.push(parserOutput);
        this._references = this._references.concat(parserOutput.references);
        this._associations = this._associations.concat(parserOutput.schema.associations);
        this._associationSets = this._associationSets.concat(parserOutput.schema.associationSets);
        this._annotations = Object.assign(this._annotations, parserOutput.schema.annotations);
        this._entitySets = this._entitySets.concat(parserOutput.schema.entitySets);
        this._singletons = this._singletons.concat(parserOutput.schema.singletons);
        this._actions = this._actions.concat(parserOutput.schema.actions);
        this._entityTypes = this._entityTypes.concat(parserOutput.schema.entityTypes);
        this._complexTypes = this._complexTypes.concat(parserOutput.schema.complexTypes);
        this._entityContainer = Object.assign(this._entityContainer, parserOutput.schema.entityContainer);
    }
    unalias(aliasedValue) {
        if (!aliasedValue) {
            return aliasedValue;
        }
        const [alias, value] = aliasedValue.split(".");
        const reference = this.references.find(reference => {
            return reference.alias === alias;
        });
        if (reference) {
            return `${reference.namespace}.${value}`;
        }
        else {
            // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
            if (aliasedValue.indexOf("@") !== -1) {
                const [preAlias, postAlias] = aliasedValue.split("@");
                return `${preAlias}@${this.unalias(postAlias)}`;
            }
            else {
                return aliasedValue;
            }
        }
    }
}
exports.MergedParserOutput = MergedParserOutput;


/***/ }),

/***/ 6511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertV2Annotations = void 0;
function convertV2Annotations(attributes, objectType, objectName) {
    const annotations = [];
    if (attributes["sap:schema-version"]) {
        annotations.push({
            term: "Org.OData.Core.V1.SchemaVersion" /* SchemaVersion */,
            value: {
                type: "String",
                String: attributes["sap:schema-version"]
            }
        });
    }
    if (attributes["sap:creatable"] && objectType === "EntitySet") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.InsertRestrictions" /* InsertRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "Insertable",
                        value: {
                            type: "Bool",
                            Bool: attributes["sap:creatable"] === "true"
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:creatable"] && objectType === "NavigationProperty") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.NavigationRestrictions" /* NavigationRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "RestrictedProperties",
                        value: {
                            type: "Record",
                            Record: {
                                propertyValues: [
                                    {
                                        name: "InsertRestrictrions",
                                        value: {
                                            type: "Record",
                                            Record: {
                                                propertyValues: [
                                                    {
                                                        name: "Insertable",
                                                        value: {
                                                            type: "Bool",
                                                            Bool: attributes["sap:creatable"] === "true"
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    }
                                ]
                            }
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:creatable-path"] && objectType === "NavigationProperty") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.NavigationRestrictions" /* NavigationRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "RestrictedProperties",
                        value: {
                            type: "Record",
                            Record: {
                                propertyValues: [
                                    {
                                        name: "InsertRestrictrions",
                                        value: {
                                            type: "Record",
                                            Record: {
                                                propertyValues: [
                                                    {
                                                        name: "Insertable",
                                                        value: {
                                                            type: "Path",
                                                            Path: attributes["sap:creatable-path"]
                                                        }
                                                    }
                                                ]
                                            }
                                        }
                                    }
                                ]
                            }
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:updatable"] && objectType === "EntitySet") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.UpdateRestrictions" /* UpdateRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "Updatable",
                        value: {
                            type: "Bool",
                            Bool: attributes["sap:updatable"] === "true"
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:updatable-path"] && objectType === "EntitySet") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.UpdateRestrictions" /* UpdateRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "Updatable",
                        value: {
                            type: "Path",
                            Path: attributes["sap:updatable-path"]
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:deletable"] && objectType === "EntitySet") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.DeleteRestrictions" /* DeleteRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "Deletable",
                        value: {
                            type: "Bool",
                            Bool: attributes["sap:updatable"] === "true"
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:deletable-path"] && objectType === "EntitySet") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.DeleteRestrictions" /* DeleteRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "Deletable",
                        value: {
                            type: "Path",
                            Path: attributes["sap:deletable-path"]
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:creatable"] === "true" &&
        attributes["sap:updatable"] === "false" &&
        objectType === "Property") {
        annotations.push({
            term: "Org.OData.Core.V1.Immutable" /* Immutable */,
            value: {
                type: "Bool",
                Bool: true
            }
        });
    }
    if (attributes["sap:creatable"] === "false" &&
        attributes["sap:updatable"] === "false" &&
        objectType === "Property") {
        annotations.push({
            term: "Org.OData.Core.V1.Computed" /* Computed */,
            value: {
                type: "Bool",
                Bool: true
            }
        });
    }
    if (attributes["sap:updatable-path"] && objectType === "Property") {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.FieldControl" /* FieldControl */,
            value: {
                type: "Path",
                Path: attributes["sap:updatable-path"]
            }
        });
    }
    if (attributes["sap:searchable"]) {
        annotations.push({
            term: "Org.OData.Capabilities.V1.SearchRestrictions" /* SearchRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "Searachable",
                        value: {
                            type: "Bool",
                            Bool: attributes["sap:searchable"] === "true"
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:pageable"]) {
        annotations.push({
            term: "Org.OData.Capabilities.V1.TopSupported" /* TopSupported */,
            value: {
                type: "Bool",
                Bool: attributes["sap:pageable"] === "true"
            }
        });
        annotations.push({
            term: "Org.OData.Capabilities.V1.SkipSupported" /* SkipSupported */,
            value: {
                type: "Bool",
                Bool: attributes["sap:pageable"] === "true"
            }
        });
    }
    if (attributes["sap:topable"]) {
        annotations.push({
            term: "Org.OData.Capabilities.V1.TopSupported" /* TopSupported */,
            value: {
                type: "Bool",
                Bool: attributes["sap:topable"] === "true"
            }
        });
    }
    if (attributes["sap:requires-filter"]) {
        annotations.push({
            term: "Org.OData.Capabilities.V1.FilterRestrictions" /* FilterRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "RequiresFilter",
                        value: {
                            type: "Bool",
                            Bool: attributes["sap:requires-filter"] === "true"
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:required-in-filter"]) {
        annotations.push({
            term: "Org.OData.Capabilities.V1.FilterRestrictions" /* FilterRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "RequiredProperties",
                        value: {
                            type: "Collection",
                            Collection: [
                                {
                                    type: "PropertyPath",
                                    PropertyPath: objectName
                                }
                            ]
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:filterable"] === "false" && objectType === "Property") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.FilterRestrictions" /* FilterRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "NonFilterableProperties",
                        value: {
                            type: "Collection",
                            Collection: [
                                {
                                    type: "PropertyPath",
                                    PropertyPath: objectName
                                }
                            ]
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:filterable"] === "false" && objectType === "NavigationProperty") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.NavigationRestrictions" /* NavigationRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "RestrictedProperties",
                        value: {
                            type: "Collection",
                            Collection: [
                                {
                                    type: "Record",
                                    propertyValues: [
                                        {
                                            name: "NavigationProperty",
                                            value: {
                                                type: "NavigationPropertyPath",
                                                NavigationPropertyPath: objectName
                                            }
                                        },
                                        {
                                            name: "FilterRestrictions",
                                            value: {
                                                type: "Record",
                                                Record: {
                                                    propertyValues: [
                                                        {
                                                            name: "Filterable",
                                                            value: {
                                                                type: "Bool",
                                                                Bool: false
                                                            }
                                                        }
                                                    ]
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:filter-restricton"]) {
        annotations.push({
            term: "Org.OData.Capabilities.V1.FilterRestrictions" /* FilterRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "FilterExpressionRestrictions",
                        value: {
                            type: "Collection",
                            Collection: [
                                {
                                    type: "Record",
                                    propertyValues: [
                                        {
                                            name: "FilterExpressionRestrictions",
                                            value: {
                                                type: "String",
                                                String: attributes["sap:filter-restricton"]
                                            }
                                        },
                                        {
                                            name: "Property",
                                            value: {
                                                type: "PropertyPath",
                                                PropertyPath: objectName
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:sortable"] === "false") {
        annotations.push({
            term: "Org.OData.Capabilities.V1.SortRestrictions" /* SortRestrictions */,
            record: {
                propertyValues: [
                    {
                        name: "NonSortableProperties",
                        value: {
                            type: "PropertyPath",
                            PropertyPath: objectName
                        }
                    }
                ]
            }
        });
    }
    if (attributes["sap:visible"] === "false") {
        annotations.push({
            term: "com.sap.vocabularies.UI.v1.Hidden" /* Hidden */,
            value: {
                type: "Bool",
                Bool: true
            }
        });
    }
    if (attributes["sap:label"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.Label" /* Label */,
            value: {
                type: "String",
                String: attributes["sap:label"]
            }
        });
    }
    if (attributes["sap:heading"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.Heading" /* Heading */,
            value: {
                type: "String",
                String: attributes["sap:heading"]
            }
        });
    }
    if (attributes["sap:quickinfo"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.QuickInfo" /* QuickInfo */,
            value: {
                type: "String",
                String: attributes["sap:quickinfo"]
            }
        });
    }
    if (attributes["sap:text"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.Text" /* Text */,
            value: {
                type: "Path",
                Path: attributes["sap:text"]
            }
        });
    }
    if (attributes["sap:unit"]) {
        annotations.push({
            term: "Org.OData.Measures.V1.Unit" /* Unit */,
            value: {
                type: "Path",
                Path: attributes["sap:unit"]
            }
        });
        annotations.push({
            term: "Org.OData.Measures.V1.ISOCurrency" /* ISOCurrency */,
            value: {
                type: "Path",
                Path: attributes["sap:unit"]
            }
        });
    }
    if (attributes["sap:precision"]) {
        annotations.push({
            term: "Org.OData.Measures.V1.Scale" /* Scale */,
            value: {
                type: "Int",
                Int: parseInt(attributes["sap:precision"])
            }
        });
    }
    if (attributes["sap:value-list"] === "fixed-value") {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.ValueListWithFixedValues" /* ValueListWithFixedValues */,
            value: {
                type: "Bool",
                Bool: true
            }
        });
    }
    if (attributes["sap:display-format"] === "NonNegative") {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.IsDigitSequence" /* IsDigitSequence */,
            value: {
                type: "Bool",
                Bool: true
            }
        });
    }
    if (attributes["sap:display-format"] === "UpperCase") {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.IsUpperCase" /* IsUpperCase */,
            value: {
                type: "Bool",
                Bool: true
            }
        });
    }
    if (attributes["sap:lower-boundary"] || attributes["sap:upper-boundary"]) {
        const pv = [];
        if (attributes["sap:lower-boundary"]) {
            pv.push({
                name: "LowerBoundary",
                value: {
                    type: "PropertyPath",
                    PropertyPath: attributes["sap:lower-boundary"]
                }
            });
        }
        if (attributes["sap:upper-boundary"]) {
            pv.push({
                name: "UpperBoundary",
                value: {
                    type: "PropertyPath",
                    PropertyPath: attributes["sap:upper-boundary"]
                }
            });
        }
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.Interval" /* Interval */,
            record: {
                propertyValues: pv
            }
        });
    }
    if (attributes["sap:field-control"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.FieldControl" /* FieldControl */,
            value: {
                type: "Path",
                Path: attributes["sap:field-control"]
            }
        });
    }
    if (attributes["sap:applicable-path"]) {
        annotations.push({
            term: "Org.OData.Core.V1.OperationAvailable" /* OperationAvailable */,
            value: {
                type: "Path",
                Path: attributes["sap:applicable-path"]
            }
        });
    }
    if (attributes["sap:minoccurs"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.MinOccurs" /* MinOccurs */,
            value: {
                type: "Int",
                Int: parseInt(attributes["sap:minoccurs"])
            }
        });
    }
    if (attributes["sap:maxoccurs"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.MaxOccurs" /* MaxOccurs */,
            value: {
                type: "Int",
                Int: parseInt(attributes["sap:maxoccurs"])
            }
        });
    }
    if (attributes["sap:parameter"] === "mandatory") {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.FieldControl" /* FieldControl */,
            value: {
                type: "EnumMember",
                EnumMember: "Common.FieldControlType/Mandatory" /* Mandatory */
            }
        });
    }
    if (attributes["sap:parameter"] === "optional") {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.FieldControl" /* FieldControl */,
            value: {
                type: "EnumMember",
                EnumMember: "Common.FieldControlType/Optional" /* Optional */
            }
        });
    }
    if (attributes["sap:attribute-for"]) {
        annotations.push({
            term: "com.sap.vocabularies.Common.v1.Attributes" /* Attributes */,
            value: {
                type: "Collection",
                Collection: [
                    {
                        type: "PropertyPath",
                        PropertyPath: objectName
                    }
                ]
            }
        });
    }
    return annotations;
}
exports.convertV2Annotations = convertV2Annotations;


/***/ }),

/***/ 6162:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Multiplicity = void 0;
var Multiplicity;
(function (Multiplicity) {
    Multiplicity["One"] = "1";
    Multiplicity["ZeroOrOne"] = "0..1";
    Multiplicity["Many"] = "*";
    Multiplicity["Unknown"] = "unknown";
})(Multiplicity = exports.Multiplicity || (exports.Multiplicity = {}));


/***/ }),

/***/ 9871:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = __webpack_require__(2781).Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(1576).StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? 0 : exports)


/***/ }),

/***/ 7725:
/***/ ((module) => {

module.exports = {

  isArray: function(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    // fallback for older browsers like  IE 8
    return Object.prototype.toString.call( value ) === '[object Array]';
  }

};


/***/ }),

/***/ 4139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*jslint node:true */

var xml2js = __webpack_require__(5707);
var xml2json = __webpack_require__(4096);
var js2xml = __webpack_require__(2160);
var json2xml = __webpack_require__(1473);

module.exports = {
  xml2js: xml2js,
  xml2json: xml2json,
  js2xml: js2xml,
  json2xml: json2xml
};


/***/ }),

/***/ 2160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var helper = __webpack_require__(4314);
var isArray = __webpack_require__(7725).isArray;

var currentElement, currentElementName;

function validateOptions(userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('indentText', options);
  helper.ensureFlagExists('indentCdata', options);
  helper.ensureFlagExists('indentAttributes', options);
  helper.ensureFlagExists('indentInstruction', options);
  helper.ensureFlagExists('fullTagEmptyElement', options);
  helper.ensureFlagExists('noQuotesForNativeAttributes', options);
  helper.ensureSpacesExists(options);
  if (typeof options.spaces === 'number') {
    options.spaces = Array(options.spaces + 1).join(' ');
  }
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  helper.checkFnExists('fullTagEmptyElement', options);
  return options;
}

function writeIndentation(options, depth, firstLine) {
  return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}

function writeAttributes(attributes, options, depth) {
  if (options.ignoreAttributes) {
    return '';
  }
  if ('attributesFn' in options) {
    attributes = options.attributesFn(attributes, currentElementName, currentElement);
  }
  var key, attr, attrName, quote, result = [];
  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
      attr = '' + attributes[key]; // ensure number and boolean are converted to String
      attr = attr.replace(/"/g, '&quot;');
      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push((options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : ' '));
      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }
  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
    result.push(writeIndentation(options, depth, false));
  }
  return result.join('');
}

function writeDeclaration(declaration, options, depth) {
  currentElement = declaration;
  currentElementName = 'xml';
  return options.ignoreDeclaration ? '' :  '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}

function writeInstruction(instruction, options, depth) {
  if (options.ignoreInstruction) {
    return '';
  }
  var key;
  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }
  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
  if (typeof instruction[key] === 'object') {
    currentElement = instruction;
    currentElementName = instructionName;
    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
  } else {
    var instructionValue = instruction[key] ? instruction[key] : '';
    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
  }
}

function writeComment(comment, options) {
  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}

function writeCdata(cdata, options) {
  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}

function writeDoctype(doctype, options) {
  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}

function writeText(text, options) {
  if (options.ignoreText) return '';
  text = '' + text; // ensure Number and Boolean are converted to String
  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}

function hasContent(element, options) {
  var i;
  if (element.elements && element.elements.length) {
    for (i = 0; i < element.elements.length; ++i) {
      switch (element.elements[i][options.typeKey]) {
      case 'text':
        if (options.indentText) {
          return true;
        }
        break; // skip to next key
      case 'cdata':
        if (options.indentCdata) {
          return true;
        }
        break; // skip to next key
      case 'instruction':
        if (options.indentInstruction) {
          return true;
        }
        break; // skip to next key
      case 'doctype':
      case 'comment':
      case 'element':
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElement(element, options, depth) {
  currentElement = element;
  currentElementName = element.name;
  var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
  xml.push('<' + elementName);
  if (element[options.attributesKey]) {
    xml.push(writeAttributes(element[options.attributesKey], options, depth));
  }
  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
  if (!withClosingTag) {
    if ('fullTagEmptyElementFn' in options) {
      withClosingTag = options.fullTagEmptyElementFn(element.name, element);
    } else {
      withClosingTag = options.fullTagEmptyElement;
    }
  }
  if (withClosingTag) {
    xml.push('>');
    if (element[options.elementsKey] && element[options.elementsKey].length) {
      xml.push(writeElements(element[options.elementsKey], options, depth + 1));
      currentElement = element;
      currentElementName = element.name;
    }
    xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
    xml.push('</' + elementName + '>');
  } else {
    xml.push('/>');
  }
  return xml.join('');
}

function writeElements(elements, options, depth, firstLine) {
  return elements.reduce(function (xml, element) {
    var indent = writeIndentation(options, depth, firstLine && !xml);
    switch (element.type) {
    case 'element': return xml + indent + writeElement(element, options, depth);
    case 'comment': return xml + indent + writeComment(element[options.commentKey], options);
    case 'doctype': return xml + indent + writeDoctype(element[options.doctypeKey], options);
    case 'cdata': return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
    case 'text': return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
    case 'instruction':
      var instruction = {};
      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
      return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
    }
  }, '');
}

function hasContentCompact(element, options, anyContent) {
  var key;
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      switch (key) {
      case options.parentKey:
      case options.attributesKey:
        break; // skip to next key
      case options.textKey:
        if (options.indentText || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.cdataKey:
        if (options.indentCdata || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.instructionKey:
        if (options.indentInstruction || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.doctypeKey:
      case options.commentKey:
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElementCompact(element, name, options, depth, indent) {
  currentElement = element;
  currentElementName = name;
  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
  if (typeof element === 'undefined' || element === null || element === '') {
    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
  }
  var xml = [];
  if (name) {
    xml.push('<' + elementName);
    if (typeof element !== 'object') {
      xml.push('>' + writeText(element,options) + '</' + elementName + '>');
      return xml.join('');
    }
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
      if ('fullTagEmptyElementFn' in options) {
        withClosingTag = options.fullTagEmptyElementFn(name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push('>');
    } else {
      xml.push('/>');
      return xml.join('');
    }
  }
  xml.push(writeElementsCompact(element, options, depth + 1, false));
  currentElement = element;
  currentElementName = name;
  if (name) {
    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
  }
  return xml.join('');
}

function writeElementsCompact(element, options, depth, firstLine) {
  var i, key, nodes, xml = [];
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      nodes = isArray(element[key]) ? element[key] : [element[key]];
      for (i = 0; i < nodes.length; ++i) {
        switch (key) {
        case options.declarationKey: xml.push(writeDeclaration(nodes[i], options, depth)); break;
        case options.instructionKey: xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth)); break;
        case options.attributesKey: case options.parentKey: break; // skip
        case options.textKey: xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options)); break;
        case options.cdataKey: xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options)); break;
        case options.doctypeKey: xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options)); break;
        case options.commentKey: xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options)); break;
        default: xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
        }
        firstLine = firstLine && !xml.length;
      }
    }
  }
  return xml.join('');
}

module.exports = function (js, options) {
  options = validateOptions(options);
  var xml = [];
  currentElement = js;
  currentElementName = '_root_';
  if (options.compact) {
    xml.push(writeElementsCompact(js, options, 0, true));
  } else {
    if (js[options.declarationKey]) {
      xml.push(writeDeclaration(js[options.declarationKey], options, 0));
    }
    if (js[options.elementsKey] && js[options.elementsKey].length) {
      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
  }
  return xml.join('');
};


/***/ }),

/***/ 1473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var js2xml = __webpack_require__(2160);

module.exports = function (json, options) {
  if (json instanceof Buffer) {
    json = json.toString();
  }
  var js = null;
  if (typeof (json) === 'string') {
    try {
      js = JSON.parse(json);
    } catch (e) {
      throw new Error('The JSON structure is invalid');
    }
  } else {
    js = json;
  }
  return js2xml(js, options);
};


/***/ }),

/***/ 4314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(7725).isArray;

module.exports = {

  copyOptions: function (options) {
    var key, copy = {};
    for (key in options) {
      if (options.hasOwnProperty(key)) {
        copy[key] = options[key];
      }
    }
    return copy;
  },

  ensureFlagExists: function (item, options) {
    if (!(item in options) || typeof options[item] !== 'boolean') {
      options[item] = false;
    }
  },

  ensureSpacesExists: function (options) {
    if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {
      options.spaces = 0;
    }
  },

  ensureAlwaysArrayExists: function (options) {
    if (!('alwaysArray' in options) || (typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray))) {
      options.alwaysArray = false;
    }
  },

  ensureKeyExists: function (key, options) {
    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
      options[key + 'Key'] = options.compact ? '_' + key : key;
    }
  },

  checkFnExists: function (key, options) {
    return key + 'Fn' in options;
  }

};


/***/ }),

/***/ 5707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var sax = __webpack_require__(9871);
var expat /*= require('node-expat');*/ = { on: function () { }, parse: function () { } };
var helper = __webpack_require__(4314);
var isArray = __webpack_require__(7725).isArray;

var options;
var pureJsParser = true;
var currentElement;

function validateOptions(userOptions) {
  options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('alwaysChildren', options);
  helper.ensureFlagExists('addParent', options);
  helper.ensureFlagExists('trim', options);
  helper.ensureFlagExists('nativeType', options);
  helper.ensureFlagExists('nativeTypeAttributes', options);
  helper.ensureFlagExists('sanitize', options);
  helper.ensureFlagExists('instructionHasAttributes', options);
  helper.ensureFlagExists('captureSpacesBetweenElements', options);
  helper.ensureAlwaysArrayExists(options);
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.ensureKeyExists('parent', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  return options;
}

function nativeType(value) {
  var nValue = Number(value);
  if (!isNaN(nValue)) {
    return nValue;
  }
  var bValue = value.toLowerCase();
  if (bValue === 'true') {
    return true;
  } else if (bValue === 'false') {
    return false;
  }
  return value;
}

function addField(type, value) {
  var key;
  if (options.compact) {
    if (
      !currentElement[options[type + 'Key']] &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)
    ) {
      currentElement[options[type + 'Key']] = [];
    }
    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];
    }
    if (type + 'Fn' in options && typeof value === 'string') {
      value = options[type + 'Fn'](value, currentElement);
    }
    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ('instructionFn' in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement)] = temp;
          }
        }
      }
    }
    if (isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']].push(value);
    } else {
      currentElement[options[type + 'Key']] = value;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    var element = {};
    element[options.typeKey] = type;
    if (type === 'instruction') {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }
      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;
      if (options.instructionHasAttributes) {
        element[options.attributesKey] = value[key][options.attributesKey];
        if ('instructionFn' in options) {
          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
        }
      } else {
        if ('instructionFn' in options) {
          value[key] = options.instructionFn(value[key], key, currentElement);
        }
        element[options.instructionKey] = value[key];
      }
    } else {
      if (type + 'Fn' in options) {
        value = options[type + 'Fn'](value, currentElement);
      }
      element[options[type + 'Key']] = value;
    }
    if (options.addParent) {
      element[options.parentKey] = currentElement;
    }
    currentElement[options.elementsKey].push(element);
  }
}

function manipulateAttributes(attributes) {
  if ('attributesFn' in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement);
  }
  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
    var key;
    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim) attributes[key] = attributes[key].trim();
        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }
        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
        if ('attributeNameFn' in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
        }
      }
    }
  }
  return attributes;
}

function onInstruction(instruction) {
  var attributes = {};
  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;
    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }
    attributes = manipulateAttributes(attributes);
  }
  if (instruction.name.toLowerCase() === 'xml') {
    if (options.ignoreDeclaration) {
      return;
    }
    currentElement[options.declarationKey] = {};
    if (Object.keys(attributes).length) {
      currentElement[options.declarationKey][options.attributesKey] = attributes;
    }
    if (options.addParent) {
      currentElement[options.declarationKey][options.parentKey] = currentElement;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }
    if (options.trim) {
      instruction.body = instruction.body.trim();
    }
    var value = {};
    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }
    addField('instruction', value);
  }
}

function onStartElement(name, attributes) {
  var element;
  if (typeof name === 'object') {
    attributes = name.attributes;
    name = name.name;
  }
  attributes = manipulateAttributes(attributes);
  if ('elementNameFn' in options) {
    name = options.elementNameFn(name, currentElement);
  }
  if (options.compact) {
    element = {};
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = {};
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element[options.attributesKey][key] = attributes[key];
        }
      }
    }
    if (
      !(name in currentElement) &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)
    ) {
      currentElement[name] = [];
    }
    if (currentElement[name] && !isArray(currentElement[name])) {
      currentElement[name] = [currentElement[name]];
    }
    if (isArray(currentElement[name])) {
      currentElement[name].push(element);
    } else {
      currentElement[name] = element;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    element = {};
    element[options.typeKey] = 'element';
    element[options.nameKey] = name;
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = attributes;
    }
    if (options.alwaysChildren) {
      element[options.elementsKey] = [];
    }
    currentElement[options.elementsKey].push(element);
  }
  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent
  currentElement = element;
}

function onText(text) {
  if (options.ignoreText) {
    return;
  }
  if (!text.trim() && !options.captureSpacesBetweenElements) {
    return;
  }
  if (options.trim) {
    text = text.trim();
  }
  if (options.nativeType) {
    text = nativeType(text);
  }
  if (options.sanitize) {
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  addField('text', text);
}

function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }
  if (options.trim) {
    comment = comment.trim();
  }
  addField('comment', comment);
}

function onEndElement(name) {
  var parentElement = currentElement[options.parentKey];
  if (!options.addParent) {
    delete currentElement[options.parentKey];
  }
  currentElement = parentElement;
}

function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }
  if (options.trim) {
    cdata = cdata.trim();
  }
  addField('cdata', cdata);
}

function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }
  doctype = doctype.replace(/^ /, '');
  if (options.trim) {
    doctype = doctype.trim();
  }
  addField('doctype', doctype);
}

function onError(error) {
  error.note = error; //console.error(error);
}

module.exports = function (xml, userOptions) {

  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');
  var result = {};
  currentElement = result;

  options = validateOptions(userOptions);

  if (pureJsParser) {
    parser.opt = {strictEntities: true};
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  } else {
    parser.on('startElement', onStartElement);
    parser.on('text', onText);
    parser.on('comment', onComment);
    parser.on('endElement', onEndElement);
    parser.on('error', onError);
    //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
  }

  if (pureJsParser) {
    parser.write(xml).close();
  } else {
    if (!parser.parse(xml)) {
      throw new Error('XML parsing error: ' + parser.getError());
    }
  }

  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }

  return result;

};


/***/ }),

/***/ 4096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var helper = __webpack_require__(4314);
var xml2js = __webpack_require__(5707);

function validateOptions (userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureSpacesExists(options);
  return options;
}

module.exports = function(xml, userOptions) {
  var options, js, json, parentKey;
  options = validateOptions(userOptions);
  js = xml2js(xml, options);
  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
  // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this
  if ('addParent' in options && options.addParent) {
    json = JSON.stringify(js, function (k, v) { return k === parentKey? '_' : v; }, options.spaces);
  } else {
    json = JSON.stringify(js, null, options.spaces);
  }
  return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};


/***/ }),

/***/ 3806:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mockAnswer = void 0;
var url_1 = __importDefault(__webpack_require__(4269));
function mockAnswer(app) {
    return function (xhr /*, id*/) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedUrl, req, oBoundaryRegex, sBoundary, responseHeaders, responseStatusCode, responseContentType, responseBuffer, res;
            return __generator(this, function (_a) {
                parsedUrl = url_1.default.parse(xhr.url);
                req = {
                    url: parsedUrl.href,
                    method: xhr.method,
                    body: xhr.requestBody,
                    headers: xhr.requestHeaders
                };
                if (req.headers['Content-Type'] === 'multipart/mixed;charset=utf-8') {
                    oBoundaryRegex = new RegExp('batch_[a-z0-9-]*');
                    sBoundary = oBoundaryRegex.exec(req.body)[0];
                    req.headers['Content-Type'] = 'multipart/mixed; boundary=' + sBoundary;
                }
                Object.keys(req.headers).forEach(function (headerText) {
                    req.headers[headerText.toLowerCase()] = req.headers[headerText];
                });
                responseHeaders = {};
                responseStatusCode = 200;
                responseBuffer = '';
                res = {
                    header: function (headerName, headerValue) {
                        //responseHeaders[headerName] = headerValue;
                        responseHeaders[headerName.toLowerCase()] = headerValue;
                    },
                    getHeader: function (headerName) {
                        return responseHeaders[headerName];
                    },
                    setHeader: function (headerName, headerValue) {
                        res.header(headerName, headerValue);
                    },
                    status: function (statusCode) {
                        responseStatusCode = statusCode;
                    },
                    type: function (contentType) {
                        responseContentType = contentType;
                        return res;
                    },
                    contentType: function (contentType) {
                        responseContentType = contentType;
                        res.header('Content-Type', responseContentType);
                        return res;
                    },
                    write: function (data) {
                        responseBuffer += data;
                    },
                    end: function () {
                        res.send(responseBuffer);
                    },
                    send: function (data) {
                        xhr.readyState = 1;
                        if (typeof data === 'object') {
                            data = JSON.stringify(data);
                        }
                        xhr.respond(responseStatusCode, responseHeaders, data);
                    }
                };
                xhr.readyState = 4;
                app(req, res, function (arg1 /*arg2, arg3*/) {
                    console.error(arg1);
                });
                return [2 /*return*/];
            });
        });
    };
}
exports.mockAnswer = mockAnswer;


/***/ }),

/***/ 5894:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveConfig = void 0;
var path_1 = __importDefault(__webpack_require__(1017));
var fs_1 = __importDefault(__webpack_require__(7147));
var fileLoader_1 = __webpack_require__(5352);
/**
 * @param serverConfig
 */
function isFolderBasedConfig(serverConfig) {
    return serverConfig.mockFolder !== undefined;
}
function isAnnotationConfig(serverConfig) {
    return serverConfig.type === 'Annotation';
}
function resolveConfig(inConfig, basePath) {
    var inServices = [];
    var inAnnotations = [];
    var currentBasePath = basePath;
    if (isFolderBasedConfig(inConfig)) {
        inConfig.mockFolder = fileLoader_1.resolvePath(basePath, inConfig.mockFolder);
        currentBasePath = inConfig.mockFolder;
        var mockConfig = void 0;
        if (fs_1.default.existsSync(path_1.default.join(inConfig.mockFolder, 'config.js'))) {
            mockConfig = require(/* webpackIgnore: true */ path_1.default.join(inConfig.mockFolder, 'config.js'));
        }
        else {
            mockConfig = JSON.parse(fs_1.default.readFileSync(path_1.default.join(inConfig.mockFolder, 'config.json')).toString('utf-8'));
        }
        mockConfig.forEach(function (mockConfigEntry) {
            if (isAnnotationConfig(mockConfigEntry)) {
                inAnnotations.push(mockConfigEntry);
            }
            else {
                inServices.push(mockConfigEntry);
            }
        });
    }
    else {
        var inServiceFromConfig = inConfig.service ? inConfig.service : inConfig.services;
        if (!Array.isArray(inServiceFromConfig) && inServiceFromConfig !== undefined) {
            inServiceFromConfig = [inServiceFromConfig];
        }
        else if (inServiceFromConfig === undefined) {
            inServiceFromConfig = [];
        }
        inServices = inServiceFromConfig;
        var inAnnotationsFromConfig = inConfig.annotations;
        if (!Array.isArray(inAnnotationsFromConfig) && inAnnotationsFromConfig !== undefined) {
            inAnnotationsFromConfig = [inAnnotationsFromConfig];
        }
        else if (inAnnotationsFromConfig === undefined) {
            inAnnotationsFromConfig = [];
        }
        inAnnotations = inAnnotationsFromConfig;
        inAnnotations.forEach(function (annotationConfig) { return annotationConfig.type === 'Annotation'; });
        currentBasePath = basePath;
    }
    var annotations = inAnnotations.map(function (inAnnotation) {
        inAnnotation.localPath = fileLoader_1.resolvePath(currentBasePath, inAnnotation.localPath);
        return inAnnotation;
    });
    var services = inServices.map(function (inService) {
        if (inService.metadataXmlPath) {
            inService.metadataXmlPath = fileLoader_1.resolvePath(currentBasePath, inService.metadataXmlPath);
        }
        if (inService.metadataCdsPath) {
            inService.metadataCdsPath = fileLoader_1.resolvePath(currentBasePath, inService.metadataCdsPath);
        }
        if (inService.mockdataRootPath) {
            inService.mockdataRootPath = fileLoader_1.resolvePath(currentBasePath, inService.mockdataRootPath);
        }
        if (!inService.urlPath) {
            inService.urlPath = inService.urlBasePath + '/' + inService.name;
        }
        var splittedPath = inService.urlPath.split('/');
        inService._internalName = splittedPath[splittedPath.length - 1];
        if (inConfig.watch && !inService.hasOwnProperty('watch')) {
            inService.watch = inConfig.watch;
        }
        if (inConfig.noETag && !inService.hasOwnProperty('noETag')) {
            inService.noETag = inConfig.noETag;
        }
        if (inConfig.debug && !inService.hasOwnProperty('debug')) {
            inService.debug = inConfig.debug;
        }
        if (inConfig.strictKeyMode && !inService.hasOwnProperty('strictKeyMode')) {
            inService.strictKeyMode = inConfig.strictKeyMode;
        }
        if (inConfig.contextBasedIsolation && !inService.hasOwnProperty('contextBasedIsolation')) {
            inService.contextBasedIsolation = inConfig.contextBasedIsolation;
        }
        return inService;
    });
    return {
        contextBasedIsolation: inConfig.contextBasedIsolation,
        watch: inConfig.watch,
        strictKeyMode: inConfig.strictKeyMode,
        debug: inConfig.debug,
        annotations: annotations,
        services: services
    };
}
exports.resolveConfig = resolveConfig;


/***/ }),

/***/ 7300:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var middleware_1 = __webpack_require__(6709);
var path = __importStar(__webpack_require__(1017));
/**
 * @param root0
 * @param root0.resources
 * @param root0.options
 */
function FEMiddleware(_a) {
    var resources = _a.resources, options = _a.options;
    // Basepath will be the webapp folder
    var basePath = resources ? path.resolve(resources.rootProject._readers[0]._fsBasePath, '..') : '';
    return middleware_1.createMockMiddleware(options.configuration, basePath);
}
module.exports = FEMiddleware;


/***/ }),

/***/ 6709:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMockMiddleware = void 0;
var router_1 = __importDefault(__webpack_require__(1071));
var logger_1 = __webpack_require__(2787);
var odata_1 = __webpack_require__(6822);
var catalog_1 = __webpack_require__(9441);
var fileLoader_1 = __webpack_require__(5352);
var browserMiddleware_1 = __webpack_require__(3806);
var configResolver_1 = __webpack_require__(5894);
/**
 * @param req
 * @param res
 * @param next
 */
function disableCache(req, res, next) {
    res.setHeader('Cache-Control', 'private, no-cache, no-store, must-revalidate');
    res.setHeader('Expires', '-1');
    res.setHeader('Pragma', 'no-cache');
    next();
}
function escapeRegex(string) {
    return string.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
}
/**
 * @param str
 */
function encode(str) {
    return str.replace(/'/g, '%27');
}
/**
 * @param inConfig
 */
function createMockMiddleware(inConfig, basePath) {
    return __awaiter(this, void 0, void 0, function () {
        var app, log, newConfig, oDataHandlerPromises, serverInit, nise_1, fakeServer, escapePath_1, mockServer_1;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    app = router_1.default();
                    log = logger_1.getLogger('server:ux-fe-mockserver');
                    app.use(disableCache);
                    newConfig = configResolver_1.resolveConfig(inConfig, basePath);
                    if (newConfig.watch) {
                        log.info("Mockserver is running in watch mode");
                    }
                    oDataHandlerPromises = newConfig.services.map(function (mockService) { return __awaiter(_this, void 0, void 0, function () {
                        var oDataHandlerInstance, subRouter, e_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, odata_1.oDataHandler(mockService)];
                                case 1:
                                    oDataHandlerInstance = _a.sent();
                                    if (newConfig.contextBasedIsolation || mockService.contextBasedIsolation) {
                                        subRouter = router_1.default();
                                        subRouter.use("" + mockService.urlPath, oDataHandlerInstance);
                                        subRouter.use("" + encode(mockService.urlPath), oDataHandlerInstance);
                                        app.use(/^\/tenant-(\d{1,3})/, subRouter);
                                    }
                                    if (newConfig.debug || mockService.debug) {
                                        log.info("Mockdata location: " + mockService.mockdataRootPath);
                                        log.info("Service path: " + mockService.urlPath);
                                    }
                                    app.use("" + mockService.urlPath, oDataHandlerInstance);
                                    app.use("" + encode(mockService.urlPath), oDataHandlerInstance);
                                    return [3 /*break*/, 3];
                                case 2:
                                    e_1 = _a.sent();
                                    if (newConfig.debug || mockService.debug) {
                                        console.error(e_1);
                                    }
                                    console.log('Failed to start ' + mockService.urlPath);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                    // Prepare the catalog service
                    app.use('/sap/opu/odata/IWFND/CATALOGSERVICE;v=2', catalog_1.catalogService(newConfig.services));
                    // Prepare the annotation files
                    newConfig.annotations.map(function (mockAnnotation) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            app.get(escapeRegex(mockAnnotation.urlPath), function (req, res) {
                                fileLoader_1.loadFile(mockAnnotation.localPath)
                                    .then(function (data) {
                                    res.setHeader('Content-Type', 'application/xml');
                                    res.write(data);
                                    res.end();
                                })
                                    .catch(function (error) {
                                    console.error(error);
                                });
                            });
                            return [2 /*return*/];
                        });
                    }); });
                    serverInit = Promise.all(oDataHandlerPromises);
                    return [4 /*yield*/, serverInit];
                case 1:
                    _a.sent();
                    if (fileLoader_1.isInBrowser()) {
                        nise_1 = __webpack_require__(3255);
                        fakeServer = nise_1.fakeServer;
                        escapePath_1 = function (sPath) {
                            // eslint-disable-next-line
                            return sPath.replace(/[\\\/\[\]\{\}\(\)\-\*\+\?\.\^\$\|]/g, '\\$&');
                        };
                        nise_1.fakeXhr.FakeXMLHttpRequest.useFilters = true;
                        mockServer_1 = fakeServer.create();
                        mockServer_1.autoRespond = true;
                        newConfig.services.map(function (newService) {
                            var serverhook = new RegExp(escapePath_1(newService.urlPath) + '.*');
                            nise_1.fakeXhr.FakeXMLHttpRequest.addFilter(function (method, url /*async, username, password*/) {
                                return !serverhook.test(url);
                            });
                            mockServer_1.respondWith(serverhook, browserMiddleware_1.mockAnswer(app));
                        });
                        app.mockServer = mockServer_1;
                    }
                    app.readyPromise = serverInit;
                    return [2 /*return*/, app];
            }
        });
    });
}
exports.createMockMiddleware = createMockMiddleware;


/***/ }),

/***/ 4831:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppHttp = void 0;
/**
 *
 */
var AppHttp = /** @class */ (function () {
    /**
     * @param {string} url
     * @param {Object} headers
     * @param {Array} payload
     * @class
     */
    function AppHttp(url, headers, payload) {
        this.type = 'app';
        this.rawData = {
            url: url,
            headers: headers,
            payload: payload
        };
        this.contentId = undefined;
        this.request = undefined;
        this.response = undefined;
    }
    /**
     * @param context
     * @param response
     */
    AppHttp.prototype.write = function (context, response) {
        response.write('Content-Type: application/http\r\n');
        response.write('Content-Transfer-Encoding: binary\r\n');
        if (this.contentId) {
            response.write('Content-ID: ' + this.contentId.id + '\r\n');
        }
        response.write('\r\n'); //end of header
        this.response.writeToBatchResponse(response, this.contentId);
    };
    return AppHttp;
}());
exports.AppHttp = AppHttp;


/***/ }),

/***/ 5371:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Batch = void 0;
/**
 *
 */
var Batch = /** @class */ (function () {
    /**
     * @param type
     */
    function Batch(type) {
        this.type = type;
        this.isChangeSet = type === 'changeset';
        if (this.isChangeSet) {
            this.changeSetErrorResponse = null;
        }
        this.parts = [];
    }
    return Batch;
}());
exports.Batch = Batch;


/***/ }),

/***/ 2251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchContent = void 0;
/**
 * @param input
 */
function split(input) {
    var LF = '\n';
    var CRLF = '\r\n';
    var a = [];
    var pL = 0;
    var p1 = input.indexOf(CRLF, pL);
    var p2 = input.indexOf(LF, pL);
    while (p1 !== -1 || p2 !== -1) {
        if (p1 !== -1 && p1 <= p2) {
            a.push(input.substring(pL, p1));
            pL = p1 + 2;
        }
        else {
            a.push(input.substring(pL, p2));
            pL = p2 + 1;
        }
        p1 = input.indexOf(CRLF, pL);
        p2 = input.indexOf(LF, pL);
    }
    if (pL < input.length) {
        a.push(input.substring(pL));
    }
    return a;
}
/**
 *
 */
var BatchContent = /** @class */ (function () {
    /**
     * @param data
     */
    function BatchContent(data) {
        if (typeof data === 'string') {
            this.type = 0;
            this.stringData = data;
            this.stringSplit = split(data);
            this.pos = 0;
        }
        else {
            throw new Error('Only string allowed for batch parser');
        }
    }
    /**
     *
     */
    BatchContent.prototype.lookLine = function () {
        return this.stringSplit[this.pos];
    };
    /**
     *
     */
    BatchContent.prototype.readLine = function () {
        return this.stringSplit[this.pos++];
    };
    BatchContent.prototype.inc = function () {
        this.pos++;
    };
    return BatchContent;
}());
exports.BatchContent = BatchContent;


/***/ }),

/***/ 6773:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertBatch = exports.getBoundary = void 0;
var batchContent_1 = __webpack_require__(2251);
var batch_1 = __webpack_require__(5371);
var appHttp_1 = __webpack_require__(4831);
/**
 * @param headerValue
 */
function getBoundary(headerValue) {
    var l = headerValue.split(';');
    for (var i = 0; i < l.length; i++) {
        var ll = l[i].split('=');
        if (ll[0].trim() === 'boundary') {
            return ll[1];
        }
    }
}
exports.getBoundary = getBoundary;
/**
 * @param line
 */
function readHeader(line) {
    var colPos = line.indexOf(':');
    if (colPos === -1) {
        throw new Error('Invalid header "content-type" in batch part');
    }
    var s0 = line.substr(0, colPos);
    var s1 = line.substr(colPos + 1);
    return {
        name: s0.toLowerCase(),
        value: s1.trim()
    };
}
/**
 * @param batchContent
 * @param boundary
 */
function readAppHttp(batchContent, boundary) {
    var headers = {};
    var payload = [];
    var state = 0; //read url
    var url = batchContent.readLine();
    state = 1; //read header
    var line = batchContent.lookLine();
    while (line !== null && line !== undefined && line.indexOf(boundary) !== 0) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            }
            else {
                var h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        }
        else if (state === 2) {
            payload.push(line);
            batchContent.inc();
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }
    return new appHttp_1.AppHttp(url, headers, payload);
}
/**
 * @param batchContent
 * @param boundary
 */
function parsePart(batchContent, boundary) {
    var boundaryNext = boundary;
    var boundaryEnd = boundary + '--';
    var headers = {};
    var content;
    var state = 1; //read header
    var line = batchContent.lookLine();
    while (line !== null && line !== undefined && line !== boundaryNext && line !== boundaryEnd) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            }
            else {
                var h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        }
        else if (state === 2) {
            if (!headers['content-type']) {
                throw new Error('Missing header "content-type" in batch part');
            }
            else if (headers['content-type'] === 'application/http') {
                content = readAppHttp(batchContent, boundary);
                if (headers['content-id']) {
                    content.contentId = { id: headers['content-id'] };
                }
            }
            else if (headers['content-type'].indexOf('multipart/mixed;') > -1) {
                var changeSetBoundary = exports.getBoundary(headers['content-type']);
                content = parseBatch(batchContent, changeSetBoundary, 'changeset');
            }
            else {
                //TODO not supported
            }
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }
    return content;
}
/**
 * @param content
 * @param boundary
 * @param type
 */
function parseBatch(content, boundary, type) {
    var boundaryNext = '--' + boundary;
    var boundaryEnd = '--' + boundary + '--';
    var batch = new batch_1.Batch(type);
    var part;
    var line = content.readLine();
    while (line !== null && line !== undefined && line !== boundaryNext) {
        //read lines before first boundary
        line = content.readLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request');
    }
    //line is now read boundary
    line = content.lookLine(); //read line behind
    while (line !== null && line !== undefined && line !== boundaryEnd) {
        part = parsePart(content, boundaryNext);
        batch.parts.push(part);
        line = content.lookLine(); //now on boundary
        if (line === boundaryNext) {
            line = content.readLine(); //consume boundaryNext
        }
    }
    content.readLine(); //consume boundaryEnd
    line = content.lookLine(); //read line behind
    while (line !== null && line !== undefined && line.length === 0) {
        //read empty lines after first boundaryend
        content.readLine();
        line = content.lookLine();
    }
    return batch;
}
/**
 * @param payload
 * @param boundary
 */
function convertBatch(payload, boundary) {
    return parseBatch(new batchContent_1.BatchContent(payload), boundary, 'batch');
}
exports.convertBatch = convertBatch;


/***/ }),

/***/ 285:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRequest = void 0;
var body_parser_1 = __webpack_require__(3986);
var clone = function (obj) {
    return JSON.parse(JSON.stringify(obj));
};
var createUrlData = function (request) {
    var protocol = request.connection && request.connection.encrypted ? 'https' : 'http';
    return {
        host: request.headers['x-forwarded-host'] || request.headers.host,
        proto: request.headers['x-forwarded-proto'] || request.protocol || protocol,
        path: request.headers['x-forwarded-path'] || request.url,
        forwarded: !!request.headers['x-forwarded-path'],
        baseUrl: request.baseUrl
    };
};
/**
 * @param originalRequest
 * @param uriPrefix
 */
function createRequest(originalRequest, uriPrefix) {
    var request = {
        headers: {}
    };
    if (originalRequest) {
        request = {
            httpVersion: originalRequest.httpVersion,
            headers: clone(originalRequest.headers),
            method: originalRequest.method,
            url: originalRequest.url,
            urlData: createUrlData(originalRequest),
            baseUrl: uriPrefix || originalRequest.baseUrl || ''
        };
    }
    if (originalRequest.body) {
        request.body = originalRequest.body;
    }
    request.getBodyAsString = function (cb) {
        if (request.body) {
            if (request.body instanceof Buffer) {
                return cb(request.body.toString('utf8'));
            }
            else {
                return cb(request.body);
            }
        }
        else if (originalRequest.body) {
            return cb(originalRequest.body);
        }
        else {
            var parser = body_parser_1.raw({ type: '*/*' });
            parser(originalRequest, null, function next(err) {
                if (err) {
                    throw new Error('Error while parsing http content');
                }
                var body = originalRequest.body;
                return cb(body.toString('utf8'));
            });
        }
    };
    return request;
}
exports.createRequest = createRequest;


/***/ }),

/***/ 7158:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createResponse = exports.SimpleResponse = void 0;
var http = __importStar(__webpack_require__(3685));
/**
 *
 */
var SimpleResponse = /** @class */ (function () {
    function SimpleResponse() {
        this.statusCode = null;
        this.headers = {};
        this.data = '';
    }
    /**
     * @param code
     * @param headers
     */
    SimpleResponse.prototype.writeHead = function (code, headers) {
        this.statusCode = code;
        Object.assign(this.headers, headers);
    };
    /**
     * @param name
     * @param value
     */
    SimpleResponse.prototype.setHeader = function (name, value) {
        this.headers[name] = value;
    };
    /**
     * @param code
     */
    SimpleResponse.prototype.status = function (code) {
        this.statusCode = code;
        return this;
    };
    /**
     * @param data
     */
    SimpleResponse.prototype.write = function (data) {
        this.data += data;
        return this;
    };
    SimpleResponse.prototype.end = function () {
        // nothing to do
    };
    /**
     * @param response
     */
    SimpleResponse.prototype.writeToBatchResponse = function (response /*, contentId*/) {
        var value;
        var headers = this.headers;
        response.write('HTTP/1.1 ' + this.statusCode + ' ' + http.STATUS_CODES['' + this.statusCode] + '\r\n');
        Object.keys(headers).forEach(function (key) {
            value = headers[key];
            response.write(key + ': ' + value + '\r\n');
        });
        response.write('\r\n'); // end of header
        response.write(this.data);
        if (this.data.length > 0) {
            response.write('\r\n'); //as used in OData_Specification_V2.0 batch samples
        }
    };
    /**
     * @param res
     */
    SimpleResponse.prototype.writeToResponse = function (res) {
        var _this = this;
        res.statusCode = this.statusCode;
        Object.keys(this.headers).forEach(function (headerName) {
            res.setHeader(headerName, _this.headers[headerName]);
        });
        res.send(this.data);
    };
    return SimpleResponse;
}());
exports.SimpleResponse = SimpleResponse;
/**
 *
 */
function createResponse() {
    return new SimpleResponse();
}
exports.createResponse = createResponse;


/***/ }),

/***/ 710:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.batchRequestHandler = void 0;
var keyGenerator_1 = __webpack_require__(100);
var simpleHttpRequest_1 = __webpack_require__(285);
var batchParser_1 = __webpack_require__(6773);
var odataRequest_1 = __webpack_require__(8506);
var odataV2Request_1 = __webpack_require__(4493);
var odataV4Request_1 = __webpack_require__(5205);
/**
 * Simplified/mocked implementation of a batch context required by the
 * xs2/xsodata lib
 */
var index = 0;
var mockContext = {
    getNextKeyCounter: function () {
        return index++;
    }
};
/**
 * Write batch content to the response. The method has been copied from the
 * xs2/xsodata project and modified because FE expects status code 202.
 *
 * @param batch
 * @param context
 * @param response
 */
function writeBatch(batch, context, response, innerPart) {
    if (innerPart === void 0) { innerPart = false; }
    response.statusCode = 200;
    var boundary = 'batch_' + keyGenerator_1.createBoundary(context);
    if (innerPart) {
        response.write('Content-Type: multipart/mixed; boundary=' + boundary);
    }
    else {
        response.setHeader('Content-Type', 'multipart/mixed; boundary=' + boundary);
    }
    response.write('--' + boundary + '\r\n');
    for (var i = 0; i < batch.parts.length; i++) {
        if (i !== 0) {
            response.write('\r\n--' + boundary + '\r\n');
        }
        if (batch.parts[i].isChangeSet) {
            writeBatch(batch.parts[i], context, response, true);
        }
        else {
            batch.parts[i].write(context, response);
        }
    }
    response.write('\r\n--' + boundary + '--\r\n');
}
/**
 * @param metadata
 * @param dataAccess
 * @param config
 */
function batchRequestHandler(metadata, dataAccess, config) {
    var _this = this;
    return function (req, res) {
        var request = simpleHttpRequest_1.createRequest(req, '/');
        if (metadata.getVersion() === '2.0') {
            res.setHeader('dataserviceversion', metadata.getVersion());
        }
        else {
            res.setHeader('odata-version', metadata.getVersion());
        }
        res.statusCode = 200;
        var boundary = batchParser_1.getBoundary(req.headers['content-type']);
        /**
         * Process the current part and prepare the return part
         *
         * @param part
         */
        function handlePart(part) {
            return __awaiter(this, void 0, void 0, function () {
                var baseUrl, minimalRepresentation, _a, method, url, odataReq, _b, patchData, updatedData, postData, actionResponse, createdData, actionResponse, data, e_1;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            baseUrl = req.baseUrl.replace('/$batch', '');
                            if (config.debug) {
                                console.log(part.rawData.url);
                            }
                            minimalRepresentation = part.rawData.headers['prefer'] && part.rawData.headers['prefer'] === 'return=minimal';
                            _a = part.rawData.url.split(' '), method = _a[0], url = _a[1];
                            odataReq = metadata.getVersion() === '2.0'
                                ? new odataV2Request_1.ODataV2Request(baseUrl, url, metadata)
                                : new odataV4Request_1.ODataV4Request(baseUrl, url, metadata, minimalRepresentation);
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 17, 18, 19]);
                            _b = method;
                            switch (_b) {
                                case 'PATCH': return [3 /*break*/, 2];
                                case 'MERGE': return [3 /*break*/, 2];
                                case 'DELETE': return [3 /*break*/, 4];
                                case 'POST': return [3 /*break*/, 6];
                                case 'GET': return [3 /*break*/, 11];
                            }
                            return [3 /*break*/, 11];
                        case 2:
                            patchData = part.rawData.payload[0].length ? JSON.parse(part.rawData.payload[0]) : {};
                            return [4 /*yield*/, dataAccess.updateData(odataReq, patchData)];
                        case 3:
                            updatedData = _c.sent();
                            part.response = odataReq.createResponse(updatedData);
                            return [3 /*break*/, 16];
                        case 4: return [4 /*yield*/, dataAccess.deleteData(odataReq)];
                        case 5:
                            _c.sent();
                            part.response = odataReq.createResponse(null);
                            return [3 /*break*/, 16];
                        case 6:
                            postData = part.rawData.payload[0].length ? JSON.parse(part.rawData.payload[0]) : {};
                            return [4 /*yield*/, dataAccess.performAction(odataReq, postData)];
                        case 7:
                            actionResponse = _c.sent();
                            if (!(actionResponse === null)) return [3 /*break*/, 9];
                            return [4 /*yield*/, dataAccess.createData(odataReq, postData)];
                        case 8:
                            createdData = _c.sent();
                            part.response = odataReq.createResponse(createdData, true, createdData);
                            return [3 /*break*/, 10];
                        case 9:
                            part.response = odataReq.createResponse(actionResponse);
                            _c.label = 10;
                        case 10: return [3 /*break*/, 16];
                        case 11: return [4 /*yield*/, dataAccess.performAction(odataReq)];
                        case 12:
                            actionResponse = _c.sent();
                            if (!(actionResponse === null)) return [3 /*break*/, 14];
                            return [4 /*yield*/, dataAccess.getData(odataReq)];
                        case 13:
                            data = _c.sent();
                            part.response = odataReq.createResponse(data);
                            return [3 /*break*/, 15];
                        case 14:
                            part.response = odataReq.createResponse(actionResponse);
                            _c.label = 15;
                        case 15: return [3 /*break*/, 16];
                        case 16: return [3 /*break*/, 19];
                        case 17:
                            e_1 = _c.sent();
                            part.response = odataRequest_1.ODataRequest.createErrorResponse(e_1);
                            return [3 /*break*/, 19];
                        case 18:
                            odataReq.applyResponseHeaders(res);
                            return [7 /*endfinally*/];
                        case 19: return [2 /*return*/];
                    }
                });
            });
        }
        request.getBodyAsString(function (body) { return __awaiter(_this, void 0, void 0, function () {
            var batch, _i, _a, part;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        batch = batchParser_1.convertBatch(body, boundary);
                        _i = 0, _a = batch.parts;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 6];
                        part = _a[_i];
                        if (!part.isChangeSet) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all(part.parts.map(function (subPart) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, handlePart(subPart)];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); }))];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, handlePart(part)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6:
                        writeBatch(batch, mockContext, res);
                        res.end();
                        return [2 /*return*/];
                }
            });
        }); });
    };
}
exports.batchRequestHandler = batchRequestHandler;


/***/ }),

/***/ 100:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBoundary = void 0;
function createBoundary(context) {
    return '' + Date.now() + '_' + context.getNextKeyCounter();
}
exports.createBoundary = createBoundary;


/***/ }),

/***/ 9441:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.catalogService = void 0;
var router_1 = __importDefault(__webpack_require__(1071));
/**
 * @param servicesConfig
 * @param version
 */
function catalogService(servicesConfig, version) {
    if (version === void 0) { version = 2; }
    var router = router_1.default();
    router.get('/ServiceCollection', function (req, res) {
        res.json({
            d: {
                results: servicesConfig.map(function (serviceConfig) {
                    return {
                        ID: serviceConfig._internalName
                    };
                })
            }
        });
    });
    router.get('/ServiceCollection\\(*', function (req, res) {
        res.json({
            d: {
                results: servicesConfig.map(function (serviceConfig) {
                    return {
                        TechnicalName: serviceConfig._internalName,
                        Version: version
                    };
                })
            }
        });
    });
    return router;
}
exports.catalogService = catalogService;


/***/ }),

/***/ 3306:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContainedDataEntitySet = void 0;
var entitySet_1 = __webpack_require__(4763);
/**
 *
 */
var ContainedDataEntitySet = /** @class */ (function (_super) {
    __extends(ContainedDataEntitySet, _super);
    /**
     * @param entitySetDefinition
     * @param containedData
     * @param dataAccess
     */
    function ContainedDataEntitySet(entitySetDefinition, containedData, dataAccess) {
        var _this = _super.call(this, undefined, entitySetDefinition, dataAccess, false, false) || this;
        _this._rootMockData = containedData;
        _this.readyPromise = Promise.resolve(_this);
        return _this;
    }
    return ContainedDataEntitySet;
}(entitySet_1.MockDataEntitySet));
exports.ContainedDataEntitySet = ContainedDataEntitySet;


/***/ }),

/***/ 5650:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._getDateTimeOffset = exports.ExecutionError = void 0;
/**
 *
 */
var ExecutionError = /** @class */ (function (_super) {
    __extends(ExecutionError, _super);
    /**
     * @param message
     * @param statusCode
     * @param messageData
     * @param isSAPMessage
     */
    function ExecutionError(message, statusCode, messageData, isSAPMessage, headers) {
        if (headers === void 0) { headers = {}; }
        var _this = _super.call(this, message) || this;
        _this.isCustomError = true;
        _this.statusCode = statusCode;
        _this.messageData = messageData;
        _this.isSAPMessage = isSAPMessage;
        _this.headers = headers;
        return _this;
    }
    return ExecutionError;
}(Error));
exports.ExecutionError = ExecutionError;
function _getDateTimeOffset(isV4) {
    var date = new Date();
    return isV4 ? date.toISOString() : '/Date(' + date.getTime() + '+0000)/';
}
exports._getDateTimeOffset = _getDateTimeOffset;


/***/ }),

/***/ 7235:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataAccess = void 0;
var entitySet_1 = __webpack_require__(4763);
var draftEntitySet_1 = __webpack_require__(1162);
var stickyEntitySet_1 = __webpack_require__(3968);
var odataV4Request_1 = __webpack_require__(5205);
var lodash_clonedeep_1 = __importDefault(__webpack_require__(9548));
var logger_1 = __webpack_require__(2787);
var ContainedDataEntitySet_1 = __webpack_require__(3306);
var common_1 = __webpack_require__(5650);
var mockEntityContainer_1 = __webpack_require__(1308);
/**
 *
 */
var DataAccess = /** @class */ (function () {
    /**
     * @param root
     * @param metadata
     * @param strictKeyMode
     * @param contextBasedIsolation
     * @param generateMockData
     */
    function DataAccess(root, metadata, strictKeyMode, contextBasedIsolation, generateMockData, debugMode) {
        var _this = this;
        if (debugMode === void 0) { debugMode = false; }
        this.entitySets = {};
        this.stickyEntitySets = [];
        this.mockDataRootFolder = root;
        this.metadata = metadata;
        this.debug = debugMode;
        this.log = logger_1.getLogger('server:ux-fe-mockserver');
        this.strictKeyMode = strictKeyMode;
        this.generateMockData = generateMockData;
        this.contextBasedIsolation = contextBasedIsolation;
        this.metadata.getEntitySets().forEach(function (entitySet) {
            _this.getMockEntitySet(entitySet.name, generateMockData);
        });
    }
    DataAccess.prototype.reloadData = function (metadata) {
        var _this = this;
        this.metadata = metadata;
        this.entitySets = {};
        this.metadata.getEntitySets().forEach(function (entitySet) {
            _this.getMockEntitySet(entitySet.name, _this.generateMockData);
        });
    };
    /**
     *
     */
    DataAccess.prototype.isV4 = function () {
        return this.metadata.getVersion() !== '2.0';
    };
    /**
     * @param entityTypeName
     * @param generateMockData
     * @param containedEntityType
     * @param containedData
     */
    DataAccess.prototype.getMockEntitySet = function (entityTypeName, generateMockData, containedEntityType, containedData) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var mockEntitySet, entitySet, entityType, mockEntitySet;
            return __generator(this, function (_b) {
                if (containedEntityType) {
                    mockEntitySet = new ContainedDataEntitySet_1.ContainedDataEntitySet(containedEntityType, containedData, this);
                    return [2 /*return*/, mockEntitySet.readyPromise];
                }
                else if (!this.entitySets[entityTypeName]) {
                    entitySet = this.metadata.getEntitySet(entityTypeName);
                    entityType = this.metadata.getEntityType(entityTypeName);
                    mockEntitySet = void 0;
                    if (this.metadata.isDraftEntity(entitySet)) {
                        if (this.debug) {
                            this.log.info('Creating draft entity for ' + (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name));
                        }
                        mockEntitySet = new draftEntitySet_1.DraftMockEntitySet(this.mockDataRootFolder, entitySet || entityType, this, generateMockData);
                    }
                    else if (this.metadata.isStickyEntity(entitySet)) {
                        if (this.debug) {
                            this.log.info('Creating sticky entity for ' + (entitySet === null || entitySet === void 0 ? void 0 : entitySet.name));
                        }
                        mockEntitySet = new stickyEntitySet_1.StickyMockEntitySet(this.mockDataRootFolder, entitySet || entityType, this, generateMockData);
                        this.stickyEntitySets.push(mockEntitySet);
                    }
                    else {
                        if (this.debug) {
                            this.log.info('Creating entity for ' + ((_a = (entitySet || entityType)) === null || _a === void 0 ? void 0 : _a.name));
                        }
                        mockEntitySet = new entitySet_1.MockDataEntitySet(this.mockDataRootFolder, entitySet || entityType, this, generateMockData);
                    }
                    this.entitySets[entityTypeName] = mockEntitySet;
                }
                return [2 /*return*/, this.entitySets[entityTypeName].readyPromise];
            });
        });
    };
    /**
     * @param odataRequest
     * @param actionData
     */
    DataAccess.prototype.performAction = function (odataRequest, actionData) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var rootEntitySet, currentEntityType, currentEntitySet, i, _loop_1, entitySetName, actionName, fqActionName, actionDefinition, collecfqActionName, collecactionDefinition, actionName, fqActionName, actionDefinition, targetEntitySet_1, outData, enrichElement_1, outData, fqActionName_1, actionDefinition_1, _i, _b, entitySet;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        rootEntitySet = this.metadata.getEntitySet(odataRequest.query.queryPath[0].path);
                        if (!rootEntitySet) return [3 /*break*/, 5];
                        currentEntityType = rootEntitySet.entityType;
                        currentEntitySet = rootEntitySet;
                        i = 1;
                        _loop_1 = function () {
                            var queryPart = odataRequest.query.queryPath[i].path;
                            var targetNavProp = currentEntityType.navigationProperties.find(function (navProp) { return navProp.name === queryPart; });
                            if (targetNavProp) {
                                currentEntityType = targetNavProp.targetType;
                                if (currentEntitySet) {
                                    currentEntitySet = currentEntitySet.navigationPropertyBinding[queryPart];
                                }
                            }
                        };
                        for (i = 1; i < odataRequest.query.queryPath.length - 1; i++) {
                            _loop_1();
                        }
                        entitySetName = currentEntitySet ? currentEntitySet.name : currentEntityType.name;
                        actionName = odataRequest.query.queryPath[i] ? odataRequest.query.queryPath[i].path : undefined;
                        if (!(actionName && actionName.length > 0)) return [3 /*break*/, 4];
                        fqActionName = actionName + "(" + currentEntityType.fullyQualifiedName + ")";
                        actionDefinition = this.metadata.getActionByFQN(fqActionName);
                        if (!actionDefinition) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getMockEntitySet(entitySetName)];
                    case 1: return [2 /*return*/, (_c.sent()).executeAction(actionDefinition, actionData, odataRequest, odataRequest.query.queryPath[i - 1].keys)];
                    case 2:
                        collecfqActionName = actionName + "(Collection(" + currentEntityType.fullyQualifiedName + "))";
                        collecactionDefinition = this.metadata.getActionByFQN(collecfqActionName);
                        if (!collecactionDefinition) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getMockEntitySet(entitySetName)];
                    case 3: return [2 /*return*/, (_c.sent()).executeAction(collecactionDefinition, actionData, odataRequest, odataRequest.query.queryPath[0].keys)];
                    case 4: return [3 /*break*/, 16];
                    case 5:
                        actionName = odataRequest.query.queryPath[0].path;
                        fqActionName = this.metadata.getEntityContainerPath() + "/" + actionName + "()";
                        actionDefinition = this.metadata.getActionByFQN(fqActionName);
                        if (!actionDefinition) return [3 /*break*/, 10];
                        if (!this.metadata.getEntitySetByType(actionDefinition.sourceType)) return [3 /*break*/, 7];
                        targetEntitySet_1 = this.metadata.getEntitySetByType(actionDefinition.sourceType);
                        return [4 /*yield*/, this.getMockEntitySet(targetEntitySet_1.name)];
                    case 6:
                        outData = (_c.sent()).executeAction(actionDefinition, Object.assign({}, actionData, odataRequest.query.rawParams), odataRequest, odataRequest.query.rawParams);
                        if (this.metadata.getVersion() === '2.0') {
                            enrichElement_1 = function (entitySet, dataLine) {
                                var keyValues = [];
                                if (entitySet.entityType.keys.length === 1) {
                                    keyValues.push("" + dataLine[entitySet.entityType.keys[0].name]);
                                }
                                else {
                                    entitySet.entityType.keys.forEach(function (key) {
                                        keyValues.push(key.name + "='" + dataLine[key.name] + "'");
                                    });
                                }
                                var uri = odataRequest.baseUrl + "/" + entitySet.name + "(" + keyValues.join(',') + ")";
                                dataLine['__metadata'] = {
                                    id: uri,
                                    uri: uri,
                                    type: entitySet.entityTypeName
                                };
                                return dataLine;
                            };
                            // Enrich data with __metadata for v2
                            if (Array.isArray(outData)) {
                                outData = outData.map(function (element) {
                                    return enrichElement_1(targetEntitySet_1, element);
                                });
                            }
                            else if (outData != null) {
                                outData = enrichElement_1(targetEntitySet_1, outData);
                            }
                        }
                        return [2 /*return*/, outData];
                    case 7: return [4 /*yield*/, mockEntityContainer_1.MockEntityContainer.read(this.mockDataRootFolder)];
                    case 8:
                        outData = (_a = (_c.sent())) === null || _a === void 0 ? void 0 : _a.executeAction(actionDefinition, Object.assign({}, actionData, odataRequest.query.rawParams), odataRequest.query.rawParams);
                        return [2 /*return*/, outData];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        fqActionName_1 = actionName + "()";
                        actionDefinition_1 = this.metadata.getActionByFQN(fqActionName_1);
                        if (!actionDefinition_1) return [3 /*break*/, 15];
                        _i = 0, _b = this.stickyEntitySets;
                        _c.label = 11;
                    case 11:
                        if (!(_i < _b.length)) return [3 /*break*/, 14];
                        entitySet = _b[_i];
                        return [4 /*yield*/, entitySet.executeAction(actionDefinition_1, actionData, odataRequest, odataRequest.query.queryPath[0].keys)];
                    case 12:
                        _c.sent();
                        _c.label = 13;
                    case 13:
                        _i++;
                        return [3 /*break*/, 11];
                    case 14: return [2 /*return*/, true];
                    case 15: return [2 /*return*/, null];
                    case 16: return [2 /*return*/, null];
                }
            });
        });
    };
    /**
     * @param data
     * @param navPropDetail
     * @param currentEntityType
     * @param currentKeys
     * @param forCreate
     */
    DataAccess.prototype.getNavigationPropertyKeys = function (data, navPropDetail, currentEntityType, currentKeys, forCreate) {
        if (forCreate === void 0) { forCreate = false; }
        if (navPropDetail.referentialConstraint && navPropDetail.referentialConstraint.length > 0) {
            var dataArray = Array.isArray(data) ? data : [data];
            dataArray.forEach(function (data) {
                var _a, _b;
                navPropDetail.referentialConstraint.forEach(function (refConstr) {
                    currentKeys[refConstr.targetProperty] = data[refConstr.sourceProperty];
                });
                if (data.hasOwnProperty('IsActiveEntity') && ((_b = (_a = navPropDetail.targetType.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode)) {
                    currentKeys['IsActiveEntity'] = data.IsActiveEntity;
                }
            });
        }
        else {
            // Try to find a back link (a nav property going back to the original entityType)
            var originalData_1 = lodash_clonedeep_1.default(data);
            var backNav = navPropDetail.targetType.navigationProperties.find(function (targetNavProp) { return targetNavProp.targetTypeName === currentEntityType.fullyQualifiedName; });
            if (backNav && backNav.referentialConstraint && backNav.referentialConstraint.length > 0) {
                backNav.referentialConstraint.forEach(function (refConstr) {
                    if (originalData_1[refConstr.targetProperty] !== undefined) {
                        currentKeys[refConstr.sourceProperty] = originalData_1[refConstr.targetProperty];
                        delete originalData_1[refConstr.targetProperty];
                    }
                });
                navPropDetail.targetType.keys.forEach(function (propKey) {
                    var _a, _b;
                    if (propKey.name === 'IsActiveEntity' &&
                        currentKeys[propKey.name] === undefined &&
                        Object.hasOwnProperty.call(originalData_1, propKey.name) &&
                        (!forCreate || !((_b = (_a = propKey.annotations) === null || _a === void 0 ? void 0 : _a.Core) === null || _b === void 0 ? void 0 : _b.Computed))) {
                        currentKeys[propKey.name] = originalData_1[propKey.name];
                        delete originalData_1[propKey.name];
                    }
                });
            }
            else if (!this.strictKeyMode) {
                navPropDetail.targetType.keys.forEach(function (propKey) {
                    var _a, _b;
                    if (Object.hasOwnProperty.call(originalData_1, propKey.name) &&
                        (!forCreate || !((_b = (_a = propKey.annotations) === null || _a === void 0 ? void 0 : _a.Core) === null || _b === void 0 ? void 0 : _b.Computed))) {
                        currentKeys[propKey.name] = originalData_1[propKey.name];
                        delete originalData_1[propKey.name];
                    }
                });
                // If there is no key or only draft stuff
                if (Object.keys(currentKeys).length === 0 ||
                    (Object.keys(currentKeys).length === 1 && currentKeys.hasOwnProperty('IsActiveEntity'))) {
                    // If we still don't have anything, try to get the keys from the current entity that are properties in the target
                    currentEntityType.keys.forEach(function (propKey) {
                        if (navPropDetail.targetType.entityProperties.find(function (prop) { return prop.name === propKey.name; }) &&
                            originalData_1[propKey.name] !== undefined) {
                            currentKeys[propKey.name] = originalData_1[propKey.name];
                            delete originalData_1[propKey.name];
                        }
                    });
                }
            }
        }
        return currentKeys;
    };
    /**
     * @param currentEntitySet
     * @param entityType
     * @param expandNavProp
     * @param data
     * @param requestExpandObject
     * @param tenantId
     * @param previousEntitySet
     * @param visitedPaths
     */
    DataAccess.prototype.getExpandData = function (currentEntitySet, entityType, expandNavProp, data, requestExpandObject, tenantId, previousEntitySet, visitedPaths) {
        return __awaiter(this, void 0, void 0, function () {
            var navProp, targetEntitySet, navEntitySet, dataArray, _loop_2, this_1, _i, dataArray_1, data_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (data === null) {
                            return [2 /*return*/];
                        }
                        navProp = entityType.navigationProperties.find(function (navProp) { return navProp.name === expandNavProp; });
                        visitedPaths = visitedPaths.concat();
                        visitedPaths.push(expandNavProp);
                        if (navProp && currentEntitySet && currentEntitySet.navigationPropertyBinding[expandNavProp]) {
                            targetEntitySet = currentEntitySet.navigationPropertyBinding[expandNavProp];
                        }
                        else if (previousEntitySet && previousEntitySet.navigationPropertyBinding[visitedPaths.join('/')]) {
                            targetEntitySet = previousEntitySet.navigationPropertyBinding[visitedPaths.join('/')];
                        }
                        if (!targetEntitySet) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.getMockEntitySet(targetEntitySet.name)];
                    case 1:
                        navEntitySet = _a.sent();
                        dataArray = Array.isArray(data) ? data : [data];
                        _loop_2 = function (data_1) {
                            var currentKeys, expandData_1, expandDetail_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        currentKeys = this_1.getNavigationPropertyKeys(data_1, navProp, entityType, {});
                                        if (!!navProp.containsTarget) return [3 /*break*/, 2];
                                        expandData_1 = data_1[expandNavProp];
                                        if (!expandData_1) {
                                            expandData_1 = navEntitySet.performGET(currentKeys, navProp.isCollection, tenantId);
                                            data_1[expandNavProp] = expandData_1;
                                        }
                                        expandDetail_1 = requestExpandObject.expand[expandNavProp];
                                        if (!(expandDetail_1.expand && Object.keys(expandDetail_1.expand).length > 0)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, Promise.all(Object.keys(expandDetail_1.expand).map(function (subExpandNavProp) { return __awaiter(_this, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    return [2 /*return*/, this.getExpandData(targetEntitySet, navProp.targetType, subExpandNavProp, expandData_1, expandDetail_1, tenantId, targetEntitySet, [])];
                                                });
                                            }); }))];
                                    case 1:
                                        _b.sent();
                                        _b.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _i = 0, dataArray_1 = dataArray;
                        _a.label = 2;
                    case 2:
                        if (!(_i < dataArray_1.length)) return [3 /*break*/, 5];
                        data_1 = dataArray_1[_i];
                        return [5 /*yield**/, _loop_2(data_1)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 7];
                    case 6: return [2 /*return*/, data[expandNavProp]];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    DataAccess.prototype.getMetadata = function () {
        return this.metadata;
    };
    /**
     * @param odataRequest
     */
    DataAccess.prototype.getData = function (odataRequest, dontClone) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (dontClone === void 0) { dontClone = false; }
        return __awaiter(this, void 0, void 0, function () {
            var currentEntitySet, previousEntitySet, currentEntityType, visitedPaths, targetContainedData, targetContainedEntityType, rootEntitySet, isCount, data, potentialTarget, filterDef_1, mockEntitySet_1, mockEntitySet_2, dataByGroup_1, mockEntitySet, mockData_1, getAggregateKey_1, originalData_2, apply$Select_1, select_1, expand, enrichElement_2;
            var _this = this;
            return __generator(this, function (_q) {
                switch (_q.label) {
                    case 0:
                        if (this.debug) {
                            this.log.info('Retrieving data for ' + JSON.stringify(odataRequest.query.queryPath));
                        }
                        currentEntitySet = null;
                        previousEntitySet = null;
                        currentEntityType = null;
                        visitedPaths = [];
                        targetContainedEntityType = null;
                        rootEntitySet = this.metadata.getEntitySet(odataRequest.query.queryPath[0].path);
                        isCount = false;
                        return [4 /*yield*/, odataRequest.query.queryPath.reduce(function (data, queryPathPart, index) { return __awaiter(_this, void 0, void 0, function () {
                                var currentKeys, asArray, navPropDetail, navPropDetail, hasOnlyDraftKey;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, data];
                                        case 1:
                                            data = _a.sent();
                                            currentKeys = queryPathPart.keys || {};
                                            asArray = Object.keys(currentKeys).length === 0;
                                            if (queryPathPart.path === '$count') {
                                                isCount = true;
                                                return [2 /*return*/, data];
                                            }
                                            if ((!currentEntityType || data === null) && index > 0) {
                                                if (data === null) {
                                                    if (currentEntityType) {
                                                        navPropDetail = currentEntityType.navigationProperties.find(function (navProp) { return navProp.name === queryPathPart.path; });
                                                        asArray = asArray && navPropDetail.isCollection;
                                                    }
                                                    return [2 /*return*/, asArray ? [] : null];
                                                }
                                                return [2 /*return*/, data];
                                            }
                                            if (!currentEntityType) {
                                                // First level if entity set, then it's navigation properties
                                                currentEntitySet = this.metadata.getEntitySet(queryPathPart.path);
                                                previousEntitySet = currentEntitySet;
                                                currentEntityType = currentEntitySet.entityType;
                                            }
                                            else {
                                                navPropDetail = currentEntityType.navigationProperties.find(function (navProp) { return navProp.name === queryPathPart.path; });
                                                if (navPropDetail.name === 'SiblingEntity' && currentEntityType) {
                                                    asArray = asArray && navPropDetail.isCollection;
                                                    currentKeys.IsActiveEntity = !data.IsActiveEntity;
                                                }
                                                else {
                                                    visitedPaths.push(queryPathPart.path);
                                                    if (navPropDetail) {
                                                        if (asArray) {
                                                            currentKeys = this.getNavigationPropertyKeys(data, navPropDetail, currentEntityType, currentKeys);
                                                        }
                                                        hasOnlyDraftKey = Object.keys(currentKeys).length === 1 && currentKeys.hasOwnProperty('IsActiveEntity');
                                                        if (navPropDetail.referentialConstraint.length == 0 &&
                                                            data.hasOwnProperty(queryPathPart.path) &&
                                                            (this.metadata.getVersion() === '2.0' || hasOnlyDraftKey)) {
                                                            // Fake containment for result set
                                                            targetContainedEntityType = navPropDetail.targetType;
                                                            targetContainedData = data[queryPathPart.path];
                                                            currentEntitySet = null;
                                                            currentEntityType = targetContainedEntityType;
                                                            if (hasOnlyDraftKey) {
                                                                currentKeys = {};
                                                            }
                                                        }
                                                        else if (!navPropDetail.containsTarget && previousEntitySet) {
                                                            currentEntitySet = previousEntitySet.navigationPropertyBinding[visitedPaths.join('/')];
                                                            previousEntitySet = currentEntitySet;
                                                            visitedPaths = [];
                                                            currentEntityType = currentEntitySet.entityType;
                                                            targetContainedEntityType = null;
                                                            targetContainedData = null;
                                                        }
                                                        else {
                                                            targetContainedEntityType = navPropDetail.targetType;
                                                            targetContainedData = data[queryPathPart.path];
                                                            currentEntitySet = null;
                                                            currentEntityType = targetContainedEntityType;
                                                        }
                                                    }
                                                    else {
                                                        currentEntitySet = null;
                                                        currentEntityType = null;
                                                    }
                                                    asArray = asArray && navPropDetail.isCollection;
                                                }
                                            }
                                            if ((!currentEntitySet && !targetContainedEntityType) ||
                                                (this.metadata.getVersion() === '2.0' && targetContainedData)) {
                                                if (Array.isArray(data)) {
                                                    return [2 /*return*/, asArray ? [] : null];
                                                }
                                                else {
                                                    return [2 /*return*/, data[queryPathPart.path]];
                                                }
                                            }
                                            return [4 /*yield*/, this.getMockEntitySet(currentEntitySet === null || currentEntitySet === void 0 ? void 0 : currentEntitySet.name, undefined, targetContainedEntityType, targetContainedData)];
                                        case 2: return [2 /*return*/, (_a.sent()).performGET(currentKeys, asArray, odataRequest.tenantId, dontClone)];
                                    }
                                });
                            }); }, {})];
                    case 1:
                        data = _q.sent();
                        if (((_d = (_c = (_b = (_a = rootEntitySet.entityType) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.Common) === null || _c === void 0 ? void 0 : _c.ResultContext) === null || _d === void 0 ? void 0 : _d.valueOf()) &&
                            odataRequest.query.queryPath.length === 1) {
                            potentialTarget = rootEntitySet.entityType.navigationProperties.find(function (navProp) { return navProp.containsTarget; });
                            throw new Error(JSON.stringify({
                                message: 'Parametrized entityset cannot be queried directly, you need to load the result set, most likely "' +
                                    potentialTarget.name +
                                    '" in this case'
                            }));
                        }
                        if (!(data !== null || (Array.isArray(data) && data.length > 0))) return [3 /*break*/, 12];
                        if (!odataRequest.query.expand) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all(Object.keys(odataRequest.query.expand).map(function (expandNavProp) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2 /*return*/, this.getExpandData(currentEntitySet, currentEntityType, expandNavProp, data, odataRequest.query, odataRequest.tenantId, previousEntitySet, visitedPaths)];
                                });
                            }); }))];
                    case 2:
                        _q.sent();
                        _q.label = 3;
                    case 3:
                        if (!((odataRequest.query.filter || ((_f = (_e = odataRequest.query) === null || _e === void 0 ? void 0 : _e.aggregateDefinition) === null || _f === void 0 ? void 0 : _f.filter)) && Array.isArray(data))) return [3 /*break*/, 5];
                        filterDef_1 = odataRequest.query.filter || ((_h = (_g = odataRequest.query) === null || _g === void 0 ? void 0 : _g.aggregateDefinition) === null || _h === void 0 ? void 0 : _h.filter);
                        return [4 /*yield*/, this.getMockEntitySet(currentEntitySet ? currentEntitySet.name : currentEntityType.name)];
                    case 4:
                        mockEntitySet_1 = _q.sent();
                        data = data.filter(function (dataLine) {
                            return mockEntitySet_1.checkFilter(dataLine, filterDef_1, odataRequest.tenantId);
                        });
                        _q.label = 5;
                    case 5:
                        if (!(odataRequest.query.searchQuery && Array.isArray(data))) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.getMockEntitySet(currentEntityType.name)];
                    case 6:
                        mockEntitySet_2 = _q.sent();
                        data = data.filter(function (dataLine) {
                            return mockEntitySet_2.checkSearch(dataLine, odataRequest.query.searchQuery);
                        });
                        _q.label = 7;
                    case 7:
                        if (!odataRequest.query.aggregateDefinition) return [3 /*break*/, 11];
                        dataByGroup_1 = {};
                        return [4 /*yield*/, this.getMockEntitySet(currentEntityType.name)];
                    case 8:
                        mockEntitySet = _q.sent();
                        if (!mockEntitySet) return [3 /*break*/, 10];
                        return [4 /*yield*/, mockEntitySet.getMockData(odataRequest.tenantId)];
                    case 9:
                        mockData_1 = _q.sent();
                        _q.label = 10;
                    case 10:
                        getAggregateKey_1 = function (dataLine) {
                            return odataRequest.query.aggregateDefinition.groupBy.reduce(function (key, groupByProp) {
                                if (key.length > 0) {
                                    key += ',';
                                }
                                key += dataLine[groupByProp];
                                return key;
                            }, '');
                        };
                        data.forEach(function (dataLine) {
                            var aggregateKey = getAggregateKey_1(dataLine);
                            if (!dataByGroup_1[aggregateKey]) {
                                dataByGroup_1[aggregateKey] = [];
                            }
                            dataByGroup_1[aggregateKey].push(dataLine);
                        });
                        data = Object.keys(dataByGroup_1).map(function (groupName) {
                            var dataToAggregate = dataByGroup_1[groupName];
                            var outData = {};
                            odataRequest.query.aggregateDefinition.groupBy.forEach(function (propName) {
                                outData[propName] = dataToAggregate[0][propName];
                            });
                            odataRequest.query.aggregateDefinition.aggregates.forEach(function (aggregateDefinition) {
                                var propValue;
                                if (aggregateDefinition.operator === undefined &&
                                    mockData_1 &&
                                    mockData_1.hasCustomAggregate(aggregateDefinition.name)) {
                                    propValue = mockData_1.performCustomAggregate(aggregateDefinition.name, dataToAggregate);
                                }
                                else {
                                    dataToAggregate.forEach(function (dataLine) {
                                        var currentValue = dataLine[aggregateDefinition.sourceProperty];
                                        if (propValue === undefined) {
                                            propValue = currentValue;
                                        }
                                        else {
                                            switch (aggregateDefinition.operator) {
                                                case 'max':
                                                    propValue = Math.max(propValue, currentValue);
                                                    break;
                                                case 'min':
                                                    propValue = Math.min(propValue, currentValue);
                                                    break;
                                                case 'average':
                                                    propValue += currentValue;
                                                    break;
                                                default:
                                                    propValue += currentValue;
                                                    break;
                                            }
                                        }
                                    });
                                }
                                if (aggregateDefinition.operator === 'average') {
                                    propValue = propValue / dataToAggregate.length;
                                }
                                outData[aggregateDefinition.name] = propValue;
                            });
                            return outData;
                        });
                        _q.label = 11;
                    case 11:
                        // Apply $orderby
                        if (((_j = odataRequest === null || odataRequest === void 0 ? void 0 : odataRequest.query) === null || _j === void 0 ? void 0 : _j.orderBy) && ((_k = odataRequest === null || odataRequest === void 0 ? void 0 : odataRequest.query) === null || _k === void 0 ? void 0 : _k.orderBy.length) > 0) {
                            data.sort(function (firstElement, secondElement) {
                                var isDecisive = false;
                                var outValue = 0;
                                odataRequest.query.orderBy.forEach(function (orderByDef) {
                                    if (isDecisive) {
                                        return;
                                    }
                                    if (firstElement[orderByDef.name] > secondElement[orderByDef.name]) {
                                        outValue = orderByDef.direction === 'asc' ? 1 : -1;
                                        isDecisive = true;
                                    }
                                    else if (firstElement[orderByDef.name] < secondElement[orderByDef.name]) {
                                        outValue = orderByDef.direction === 'asc' ? -1 : 1;
                                        isDecisive = true;
                                    }
                                });
                                return outValue;
                            });
                        }
                        originalData_2 = lodash_clonedeep_1.default(data);
                        if ((_l = odataRequest === null || odataRequest === void 0 ? void 0 : odataRequest.query) === null || _l === void 0 ? void 0 : _l.properties) {
                            if (odataRequest.query.properties['DraftAdministrativeData']) {
                                if (Array.isArray(data)) {
                                    data = data.map(function (element) {
                                        if (!element.DraftAdministrativeData) {
                                            element.DraftAdministrativeData = null;
                                        }
                                        return element;
                                    });
                                }
                                else if (data != null && data.constructor.name === 'Object') {
                                    if (!data.DraftAdministrativeData) {
                                        data.DraftAdministrativeData = null;
                                    }
                                }
                            }
                        }
                        if (((_m = odataRequest === null || odataRequest === void 0 ? void 0 : odataRequest.query) === null || _m === void 0 ? void 0 : _m.properties) && Object.keys((_o = odataRequest === null || odataRequest === void 0 ? void 0 : odataRequest.query) === null || _o === void 0 ? void 0 : _o.properties).length > 0) {
                            apply$Select_1 = function (expand, data) {
                                var selectedPropertyNames = Object.keys(expand.select);
                                var expandedNavProps = Object.keys(expand.expand);
                                var allNavProps = (currentEntityType === null || currentEntityType === void 0 ? void 0 : currentEntityType.navigationProperties.map(function (navProp) { return navProp.name; })) || [];
                                data.forEach(function (element) {
                                    // the element might be null (if it is a 1:1 navigation property)
                                    if (element === null) {
                                        return;
                                    }
                                    // if all properties are requested ("*") keep everything else delete unwanted properties
                                    if (!selectedPropertyNames.includes('*')) {
                                        var propertyNames = Object.keys(element);
                                        var differenceKeys = propertyNames.filter(function (propertyName) { return !selectedPropertyNames.includes(propertyName); });
                                        differenceKeys.forEach(function (k) {
                                            delete element[k];
                                        });
                                    }
                                    expandedNavProps.forEach(function (navProp) {
                                        var expandedIndex = allNavProps.indexOf(navProp);
                                        if (expandedIndex !== -1) {
                                            allNavProps.splice(expandedIndex, 1);
                                        }
                                        var subElement = element[navProp];
                                        if (Array.isArray(subElement)) {
                                            apply$Select_1(expand.expand[navProp], subElement);
                                        }
                                        else {
                                            apply$Select_1(expand.expand[navProp], [subElement]);
                                        }
                                    });
                                    if (selectedPropertyNames.includes('*') && currentEntitySet && allNavProps.length > 0) {
                                        // we may still want to remove navProp that were inline and not requested
                                        allNavProps.forEach(function (k) {
                                            delete element[k];
                                        });
                                    }
                                });
                            };
                            select_1 = {};
                            Object.keys(odataRequest.query.properties).forEach(function (prop) { return (select_1[prop] = true); });
                            expand = {
                                expand: (_p = odataRequest.query.expand) !== null && _p !== void 0 ? _p : {},
                                select: select_1
                            };
                            if (Array.isArray(data)) {
                                apply$Select_1(expand, data);
                            }
                            else if (data != null && data.constructor.name === 'Object') {
                                apply$Select_1(expand, [data]);
                            }
                        }
                        odataRequest.dataLength = (Array.isArray(data) && data.length) || 1;
                        // Apply $skip / $top
                        if (Array.isArray(data) && odataRequest.query.startIndex !== undefined && odataRequest.query.maxElements) {
                            data = data.slice(odataRequest.query.startIndex, odataRequest.query.startIndex + odataRequest.query.maxElements);
                        }
                        if (this.metadata.getVersion() === '2.0') {
                            enrichElement_2 = function (entitySet, entityType, dataLine, originalDataLine) {
                                if (!entityType) {
                                    return;
                                }
                                var keyValues = [];
                                if (entityType.keys.length === 1) {
                                    var key = entityType.keys[0];
                                    keyValues.push("" + (dataLine[key.name] || originalDataLine[key.name]));
                                }
                                else {
                                    entityType.keys.forEach(function (key) {
                                        keyValues.push(key.name + "='" + (dataLine[key.name] || originalDataLine[key.name]) + "'");
                                    });
                                }
                                var uri = odataRequest.baseUrl + "/" + (entitySet ? entitySet.name : entityType.name) + "(" + keyValues.join(',') + ")";
                                dataLine['__metadata'] = {
                                    id: uri,
                                    uri: uri,
                                    type: entityType.fullyQualifiedName
                                };
                                entityType.navigationProperties.forEach(function (navProp) {
                                    var _a;
                                    //eslint-disable-next-line
                                    if (dataLine.hasOwnProperty(navProp.name)) {
                                        if (entitySet.navigationPropertyBinding[navProp.name]) {
                                            if (navProp.isCollection) {
                                                var navPropData = dataLine[navProp.name];
                                                var hasResult_1 = false;
                                                if (!Array.isArray(navPropData) && navPropData.hasOwnProperty('results')) {
                                                    navPropData = navPropData.results;
                                                    hasResult_1 = true;
                                                }
                                                if (!Array.isArray(navPropData) && navPropData.hasOwnProperty('__deferred')) {
                                                    navPropData = [];
                                                    hasResult_1 = false;
                                                }
                                                dataLine[navProp.name] = {
                                                    results: navPropData.map(function (element, idx) {
                                                        var _a;
                                                        var originalData = originalDataLine[navProp.name][idx];
                                                        if (hasResult_1) {
                                                            originalData = originalDataLine[navProp.name].results[idx];
                                                        }
                                                        return enrichElement_2(entitySet.navigationPropertyBinding[navProp.name], (_a = entityType.navigationProperties.find(function (nav) { return nav.name === navProp.name; })) === null || _a === void 0 ? void 0 : _a.targetType, element, originalData);
                                                    })
                                                };
                                            }
                                            else if (dataLine[navProp.name] !== null) {
                                                dataLine[navProp.name] = enrichElement_2(entitySet.navigationPropertyBinding[navProp.name], (_a = entityType.navigationProperties.find(function (nav) { return nav.name === navProp.name; })) === null || _a === void 0 ? void 0 : _a.targetType, dataLine[navProp.name], originalDataLine[navProp.name]);
                                            }
                                        }
                                    }
                                });
                                return dataLine;
                            };
                            // Enrich data with __metadata for v2
                            if (Array.isArray(data)) {
                                data = data.map(function (element, idx) {
                                    return enrichElement_2(currentEntitySet, currentEntityType, element, originalData_2[idx]);
                                });
                            }
                            else if (data != null) {
                                data = enrichElement_2(currentEntitySet, currentEntityType, data, originalData_2);
                            }
                        }
                        if (isCount) {
                            data = odataRequest.dataLength;
                        }
                        _q.label = 12;
                    case 12: return [2 /*return*/, data];
                }
            });
        });
    };
    /**
     * @param odataRequest
     * @param patchData
     */
    DataAccess.prototype.updateData = function (odataRequest, patchData) {
        return __awaiter(this, void 0, void 0, function () {
            var entitySetName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        entitySetName = odataRequest.query.queryPath[0].path;
                        return [4 /*yield*/, this.getMockEntitySet(entitySetName)];
                    case 1: return [4 /*yield*/, (_a.sent()).performPATCH(odataRequest.query.queryPath[0].keys, patchData, odataRequest.tenantId, true)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * @param odataRequest
     * @param postData
     */
    DataAccess.prototype.createData = function (odataRequest, postData) {
        return __awaiter(this, void 0, void 0, function () {
            var entitySetName, navPropertyName, entitySet, entityType, navPropDetail, navPropEntityType, data, providedKeys_1, currentKeys_1, targetEntitySet, currentKeys_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        entitySetName = odataRequest.query.queryPath[0].path;
                        navPropertyName = odataRequest.query.queryPath.length > 1 ? odataRequest.query.queryPath[1].path : undefined;
                        entitySet = this.metadata.getEntitySet(entitySetName);
                        if (!navPropertyName) return [3 /*break*/, 5];
                        entityType = entitySet.entityType;
                        navPropDetail = entityType.navigationProperties.find(function (navProp) { return navProp.name === navPropertyName; });
                        navPropEntityType = navPropDetail.targetType;
                        return [4 /*yield*/, this.getMockEntitySet(entitySetName)];
                    case 1:
                        data = (_a.sent()).performGET(odataRequest.query.queryPath[0].keys, false, odataRequest.tenantId, true);
                        providedKeys_1 = {};
                        navPropEntityType.keys.forEach(function (key) {
                            if (postData[key.name] !== undefined) {
                                providedKeys_1[key.name] = postData[key.name];
                            }
                        });
                        currentKeys_1 = this.getNavigationPropertyKeys(data, navPropDetail, entitySet.entityType, providedKeys_1, true);
                        if (data.DraftAdministrativeData !== null && data.DraftAdministrativeData !== undefined) {
                            data.DraftAdministrativeData.LastChangeDateTime = common_1._getDateTimeOffset(this.isV4());
                        }
                        if (!!navPropDetail.containsTarget) return [3 /*break*/, 3];
                        targetEntitySet = entitySet.navigationPropertyBinding[navPropertyName];
                        odataRequest.context = "../$metadata#" + targetEntitySet.name + "/$entity";
                        odataRequest.location = targetEntitySet.name + "(" + Object.keys(currentKeys_1)
                            .map(function (key) { return key + "='" + currentKeys_1[key] + "'"; })
                            .join(',') + ")";
                        return [4 /*yield*/, this.getMockEntitySet(targetEntitySet.name)];
                    case 2:
                        postData = (_a.sent()).performPOST(currentKeys_1, postData, odataRequest.tenantId, true);
                        return [3 /*break*/, 4];
                    case 3:
                        if (!data[navPropertyName]) {
                            data[navPropertyName] = [];
                        }
                        data[navPropertyName].push(postData);
                        _a.label = 4;
                    case 4: return [2 /*return*/, postData];
                    case 5:
                        currentKeys_2 = {};
                        entitySet.entityType.keys.forEach(function (key) {
                            if (postData[key.name] !== undefined) {
                                currentKeys_2[key.name] = postData[key.name];
                            }
                        });
                        return [4 /*yield*/, this.getMockEntitySet(entitySet.name)];
                    case 6:
                        postData = (_a.sent()).performPOST(currentKeys_2, postData, odataRequest.tenantId, true);
                        odataRequest.context = "../$metadata#" + entitySet.name + "/$entity";
                        odataRequest.location = entitySet.name + "(" + Object.keys(currentKeys_2)
                            .map(function (key) { return key + "='" + currentKeys_2[key] + "'"; })
                            .join(',') + ")";
                        return [2 /*return*/, postData];
                }
            });
        });
    };
    /**
     * @param odataRequest
     */
    DataAccess.prototype.deleteData = function (odataRequest) {
        return __awaiter(this, void 0, void 0, function () {
            var entitySetName, mockEntitySet, deleteResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        entitySetName = odataRequest.query.queryPath[0].path;
                        return [4 /*yield*/, this.getMockEntitySet(entitySetName)];
                    case 1:
                        mockEntitySet = _a.sent();
                        deleteResult = mockEntitySet.performDELETE(odataRequest.query.queryPath[0].keys, odataRequest.tenantId, true);
                        return [2 /*return*/, deleteResult];
                }
            });
        });
    };
    DataAccess.prototype.getParentEntityKeys = function (keyValues, entitySetDefinition) {
        return undefined;
    };
    DataAccess.prototype.getDraftRoot = function (keyValues, tenantId, entitySetDefinition) {
        return __awaiter(this, void 0, void 0, function () {
            var data, rootInfo, parentRequestPath, i, parentRequest, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = {};
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        rootInfo = this.metadata.resolveDraftRoot(entitySetDefinition);
                        parentRequestPath = entitySetDefinition.name + "(" + Object.keys(keyValues)
                            .map(function (keyName) { return keyName + "=" + keyValues[keyName]; })
                            .join(',') + ")";
                        for (i = 0; i < rootInfo.path.length; i++) {
                            parentRequestPath += '/';
                            parentRequestPath += rootInfo.path[i].partner.name;
                        }
                        parentRequest = new odataV4Request_1.ODataV4Request('', parentRequestPath, this.metadata);
                        return [4 /*yield*/, this.getData(parentRequest, true)];
                    case 2:
                        data = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.log("Couldn't find the parent for " + keyValues);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, data];
                }
            });
        });
    };
    /**
     * @param res
     * @param tenantId
     */
    DataAccess.prototype.resetStickySessionTimeout = function (res, tenantId) {
        res.setHeader('odata-version', '4.0');
        var UUID = '';
        var timeoutTime = 20;
        this.stickyEntitySets.forEach(function (entitySet) {
            UUID = entitySet.resetSessionTimeout(tenantId);
            timeoutTime = entitySet.sessionTimeoutTime;
        });
        res.setHeader('sap-contextid', UUID);
        res.setHeader('sap-http-session-timeout', timeoutTime.toString());
        res.statusCode = 200;
        res.end();
    };
    return DataAccess;
}());
exports.DataAccess = DataAccess;


/***/ }),

/***/ 1162:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DraftMockEntitySet = void 0;
var entitySet_1 = __webpack_require__(4763);
var id_1 = __webpack_require__(1016);
var common_1 = __webpack_require__(5650);
/**
 * @param isV4
 */
/**
 *
 */
var DraftMockEntitySet = /** @class */ (function (_super) {
    __extends(DraftMockEntitySet, _super);
    /**
     * @param rootFolder
     * @param entitySetDefinition
     * @param dataAccess
     * @param generateMockData
     */
    function DraftMockEntitySet(rootFolder, entitySetDefinition, dataAccess, generateMockData) {
        return _super.call(this, rootFolder, entitySetDefinition, dataAccess, generateMockData, true, true) || this;
    }
    /**
     * @param filterExpression
     * @param mockData
     * @param allData
     */
    DraftMockEntitySet.prototype.checkSpecificProperties = function (filterExpression, mockData, allData) {
        if (filterExpression.identifier === 'DraftAdministrativeData/InProcessByUser') {
            return false;
        }
        else if (filterExpression.identifier === 'SiblingEntity/IsActiveEntity' &&
            filterExpression.literal === 'null') {
            // Ensure that there is not sibling entity which is inactive
            var keys_1 = {};
            this.entityTypeDefinition.keys.forEach(function (keyDef) {
                if (keyDef.name !== 'IsActiveEntity') {
                    keys_1[keyDef.name] = mockData[keyDef.name];
                }
                else {
                    keys_1[keyDef.name] = false;
                }
            });
            return !allData.hasEntry(keys_1);
        }
        else {
            return null;
        }
    };
    /**
     * @param mockData
     * @param keyValues
     * @param keyName
     * @param property
     */
    DraftMockEntitySet.prototype.checkKeyValue = function (mockData, keyValues, keyName, property) {
        if (keyName === 'IsActiveEntity') {
            // Make sure we check a boolean value
            var booleanKeyValue = keyValues[keyName];
            if (typeof booleanKeyValue === 'string') {
                booleanKeyValue = booleanKeyValue === 'true';
            }
            return mockData[keyName] === booleanKeyValue;
        }
        return _super.prototype.checkKeyValue.call(this, mockData, keyValues, keyName, property);
    };
    /**
     * @param keyValues
     * @param tenantId
     */
    DraftMockEntitySet.prototype.createInactiveVersion = function (keyValues, tenantId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData, dataToDuplicate, _i, dataToDuplicate_1, data, duplicate, _loop_1, this_1, _c, _d, _e, navPropName;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        currentMockData = this.getMockData(tenantId);
                        dataToDuplicate = this.performGET(keyValues, true, tenantId, true);
                        _i = 0, dataToDuplicate_1 = dataToDuplicate;
                        _f.label = 1;
                    case 1:
                        if (!(_i < dataToDuplicate_1.length)) return [3 /*break*/, 6];
                        data = dataToDuplicate_1[_i];
                        if (!(!data.HasDraftEntity && data.IsActiveEntity)) return [3 /*break*/, 5];
                        data.HasDraftEntity = true;
                        duplicate = Object.assign({}, data);
                        duplicate.IsActiveEntity = false;
                        duplicate.HasActiveEntity = true;
                        currentMockData.addEntry(duplicate);
                        _loop_1 = function (navPropName) {
                            var navPropDetail, subKeys, navPropEntity;
                            return __generator(this, function (_g) {
                                switch (_g.label) {
                                    case 0:
                                        if (!(((_b = (_a = this_1.entitySetDefinition.navigationPropertyBinding[navPropName].annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode) &&
                                            navPropName !== 'SiblingEntity')) return [3 /*break*/, 3];
                                        navPropDetail = this_1.entityTypeDefinition.navigationProperties.find(function (navProp) { return navProp.name === navPropName; });
                                        subKeys = this_1.dataAccess.getNavigationPropertyKeys(data, navPropDetail, this_1.entitySetDefinition.entityType, {});
                                        return [4 /*yield*/, this_1.dataAccess.getMockEntitySet(this_1.entitySetDefinition.navigationPropertyBinding[navPropName].name)];
                                    case 1:
                                        navPropEntity = (_g.sent());
                                        if (!(navPropEntity && navPropEntity.createInactiveVersion)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, navPropEntity.createInactiveVersion(subKeys, tenantId)];
                                    case 2:
                                        _g.sent();
                                        _g.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _c = [];
                        for (_d in this.entitySetDefinition.navigationPropertyBinding)
                            _c.push(_d);
                        _e = 0;
                        _f.label = 2;
                    case 2:
                        if (!(_e < _c.length)) return [3 /*break*/, 5];
                        navPropName = _c[_e];
                        return [5 /*yield**/, _loop_1(navPropName)];
                    case 3:
                        _f.sent();
                        _f.label = 4;
                    case 4:
                        _e++;
                        return [3 /*break*/, 2];
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param tenantId
     */
    DraftMockEntitySet.prototype.activateInactiveVersion = function (keyValues, tenantId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData, dataToDuplicate, deleteKeyValues, dataToDelete, _i, dataToDelete_1, draftData, activateKeyValues, _c, dataToDuplicate_2, draftData, activateKeyValues, activeDraft, _loop_2, this_2, _d, _e, _f, navPropName;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        currentMockData = this.getMockData(tenantId);
                        dataToDuplicate = this.performGET(keyValues, true, tenantId, true);
                        deleteKeyValues = Object.assign({}, keyValues);
                        deleteKeyValues.IsActiveEntity = true;
                        dataToDelete = this.performGET(deleteKeyValues, true, tenantId, true);
                        for (_i = 0, dataToDelete_1 = dataToDelete; _i < dataToDelete_1.length; _i++) {
                            draftData = dataToDelete_1[_i];
                            if (draftData.IsActiveEntity && !draftData.HasDraftEntity) {
                                activateKeyValues = this.getKeys(draftData);
                                currentMockData.removeEntry(activateKeyValues);
                            }
                        }
                        _c = 0, dataToDuplicate_2 = dataToDuplicate;
                        _g.label = 1;
                    case 1:
                        if (!(_c < dataToDuplicate_2.length)) return [3 /*break*/, 6];
                        draftData = dataToDuplicate_2[_c];
                        if (!(!draftData.IsActiveEntity && draftData.HasDraftEntity)) return [3 /*break*/, 5];
                        draftData.HasDraftEntity = false;
                        activateKeyValues = this.getKeys(draftData);
                        activateKeyValues.IsActiveEntity = true;
                        activeDraft = Object.assign({}, draftData);
                        activeDraft.IsActiveEntity = true;
                        activeDraft.HasDraftEntity = false;
                        if (!currentMockData.hasEntry(activateKeyValues)) {
                            currentMockData.addEntry(activeDraft);
                        }
                        else {
                            currentMockData.updateEntry(activateKeyValues, activeDraft);
                        }
                        _loop_2 = function (navPropName) {
                            var navPropDetail, subKeys, navPropEntity;
                            return __generator(this, function (_h) {
                                switch (_h.label) {
                                    case 0:
                                        if (!(((_b = (_a = this_2.entitySetDefinition.navigationPropertyBinding[navPropName].annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode) &&
                                            navPropName !== 'SiblingEntity')) return [3 /*break*/, 3];
                                        navPropDetail = this_2.entityTypeDefinition.navigationProperties.find(function (navProp) { return navProp.name === navPropName; });
                                        subKeys = this_2.dataAccess.getNavigationPropertyKeys(draftData, navPropDetail, this_2.entitySetDefinition.entityType, {});
                                        return [4 /*yield*/, this_2.dataAccess.getMockEntitySet(this_2.entitySetDefinition.navigationPropertyBinding[navPropName].name)];
                                    case 1:
                                        navPropEntity = (_h.sent());
                                        if (!(navPropEntity && navPropEntity.activateInactiveVersion)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, navPropEntity.activateInactiveVersion(subKeys, tenantId)];
                                    case 2:
                                        _h.sent();
                                        _h.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        };
                        this_2 = this;
                        _d = [];
                        for (_e in this.entitySetDefinition.navigationPropertyBinding)
                            _d.push(_e);
                        _f = 0;
                        _g.label = 2;
                    case 2:
                        if (!(_f < _d.length)) return [3 /*break*/, 5];
                        navPropName = _d[_f];
                        return [5 /*yield**/, _loop_2(navPropName)];
                    case 3:
                        _g.sent();
                        _g.label = 4;
                    case 4:
                        _f++;
                        return [3 /*break*/, 2];
                    case 5:
                        _c++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param odataRequest
     */
    DraftMockEntitySet.prototype.draftEdit = function (keyValues, odataRequest) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var data, duplicate, currentDate, currentMockData, _loop_3, this_3, _c, _d, _i, navPropName;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        data = this.performGET(keyValues, false, odataRequest.tenantId);
                        data.HasDraftEntity = true;
                        duplicate = Object.assign({}, data);
                        duplicate.IsActiveEntity = false;
                        duplicate.HasActiveEntity = true;
                        currentDate = common_1._getDateTimeOffset(this.isV4());
                        duplicate.DraftAdministrativeData = {
                            DraftUUID: id_1.uuidv4(),
                            CreationDateTime: currentDate,
                            CreatedByUser: 'nobody',
                            DraftIsCreatedByMe: true,
                            LastChangeDateTime: currentDate,
                            LastChangedByUser: 'nobody',
                            InProcessByUser: 'nobody',
                            DraftIsProcessedByMe: true
                        };
                        currentMockData = this.getMockData(odataRequest.tenantId);
                        currentMockData.addEntry(duplicate);
                        _loop_3 = function (navPropName) {
                            var navPropDetail, subKeys, navPropEntity;
                            return __generator(this, function (_f) {
                                switch (_f.label) {
                                    case 0:
                                        if (!(((_b = (_a = this_3.entitySetDefinition.navigationPropertyBinding[navPropName].annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode) &&
                                            navPropName !== 'SiblingEntity')) return [3 /*break*/, 3];
                                        navPropDetail = this_3.entityTypeDefinition.navigationProperties.find(function (navProp) { return navProp.name === navPropName; });
                                        subKeys = this_3.dataAccess.getNavigationPropertyKeys(data, navPropDetail, this_3.entitySetDefinition.entityType, {});
                                        return [4 /*yield*/, this_3.dataAccess.getMockEntitySet(this_3.entitySetDefinition.navigationPropertyBinding[navPropName].name)];
                                    case 1:
                                        navPropEntity = (_f.sent());
                                        if (!(navPropEntity && navPropEntity.createInactiveVersion)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, navPropEntity.createInactiveVersion(subKeys, odataRequest.tenantId)];
                                    case 2:
                                        _f.sent();
                                        _f.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        };
                        this_3 = this;
                        _c = [];
                        for (_d in this.entitySetDefinition.navigationPropertyBinding)
                            _c.push(_d);
                        _i = 0;
                        _e.label = 1;
                    case 1:
                        if (!(_i < _c.length)) return [3 /*break*/, 4];
                        navPropName = _c[_i];
                        return [5 /*yield**/, _loop_3(navPropName)];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param tenantId
     */
    DraftMockEntitySet.prototype.draftDiscard = function (keyValues, tenantId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var draftData, _loop_4, this_4, _c, _d, _i, navPropName, deleteKeyValues, activeData;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        draftData = this.performGET(keyValues, false, tenantId);
                        _super.prototype.performDELETE.call(this, keyValues, tenantId);
                        _loop_4 = function (navPropName) {
                            var navPropDetail, subKeys, navPropEntity;
                            return __generator(this, function (_f) {
                                switch (_f.label) {
                                    case 0:
                                        if (!(((_b = (_a = this_4.entitySetDefinition.navigationPropertyBinding[navPropName].annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode) &&
                                            navPropName !== 'SiblingEntity')) return [3 /*break*/, 2];
                                        navPropDetail = this_4.entityTypeDefinition.navigationProperties.find(function (navProp) { return navProp.name === navPropName; });
                                        subKeys = this_4.dataAccess.getNavigationPropertyKeys(draftData, navPropDetail, this_4.entitySetDefinition.entityType, {});
                                        return [4 /*yield*/, this_4.dataAccess.getMockEntitySet(this_4.entitySetDefinition.navigationPropertyBinding[navPropName].name)];
                                    case 1:
                                        navPropEntity = (_f.sent());
                                        if (navPropEntity && navPropEntity.discardInactiveVersion) {
                                            navPropEntity.discardInactiveVersion(subKeys, tenantId);
                                        }
                                        _f.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        };
                        this_4 = this;
                        _c = [];
                        for (_d in this.entitySetDefinition.navigationPropertyBinding)
                            _c.push(_d);
                        _i = 0;
                        _e.label = 1;
                    case 1:
                        if (!(_i < _c.length)) return [3 /*break*/, 4];
                        navPropName = _c[_i];
                        return [5 /*yield**/, _loop_4(navPropName)];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        deleteKeyValues = Object.assign({}, keyValues);
                        deleteKeyValues.IsActiveEntity = true;
                        activeData = this.performGET(deleteKeyValues, false, tenantId, true);
                        if (activeData) {
                            activeData.HasDraftEntity = false;
                        }
                        return [2 /*return*/, activeData];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param tenantId
     */
    DraftMockEntitySet.prototype.discardInactiveVersion = function (keyValues, tenantId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var dataToDiscard, _i, dataToDiscard_1, data, keys, _loop_5, this_5, _c, _d, _e, navPropName, deleteKeyValues, activeData, activeVersionOfDeletedKeys, dataToAdjust, _f, dataToAdjust_1, data;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        dataToDiscard = this.performGET(keyValues, true, tenantId);
                        _i = 0, dataToDiscard_1 = dataToDiscard;
                        _g.label = 1;
                    case 1:
                        if (!(_i < dataToDiscard_1.length)) return [3 /*break*/, 7];
                        data = dataToDiscard_1[_i];
                        keys = this.getKeys(data);
                        this.performDELETE(keys, tenantId);
                        _loop_5 = function (navPropName) {
                            var navPropDetail, subKeys, navPropEntity;
                            return __generator(this, function (_h) {
                                switch (_h.label) {
                                    case 0:
                                        if (!(((_b = (_a = this_5.entitySetDefinition.navigationPropertyBinding[navPropName].annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode) &&
                                            navPropName !== 'SiblingEntity')) return [3 /*break*/, 3];
                                        navPropDetail = this_5.entityTypeDefinition.navigationProperties.find(function (navProp) { return navProp.name === navPropName; });
                                        subKeys = this_5.dataAccess.getNavigationPropertyKeys(data, navPropDetail, this_5.entitySetDefinition.entityType, {});
                                        return [4 /*yield*/, this_5.dataAccess.getMockEntitySet(this_5.entitySetDefinition.navigationPropertyBinding[navPropName].name)];
                                    case 1:
                                        navPropEntity = (_h.sent());
                                        if (!(navPropEntity && navPropEntity.discardInactiveVersion)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, navPropEntity.discardInactiveVersion(subKeys, tenantId)];
                                    case 2:
                                        _h.sent();
                                        _h.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        };
                        this_5 = this;
                        _c = [];
                        for (_d in this.entitySetDefinition.navigationPropertyBinding)
                            _c.push(_d);
                        _e = 0;
                        _g.label = 2;
                    case 2:
                        if (!(_e < _c.length)) return [3 /*break*/, 5];
                        navPropName = _c[_e];
                        return [5 /*yield**/, _loop_5(navPropName)];
                    case 3:
                        _g.sent();
                        _g.label = 4;
                    case 4:
                        _e++;
                        return [3 /*break*/, 2];
                    case 5:
                        deleteKeyValues = Object.assign({}, keys);
                        deleteKeyValues.IsActiveEntity = true;
                        activeData = this.performGET(deleteKeyValues, false, tenantId, true);
                        if (activeData) {
                            activeData.HasDraftEntity = false;
                        }
                        _g.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7:
                        activeVersionOfDeletedKeys = Object.assign({}, keyValues);
                        activeVersionOfDeletedKeys.IsActiveEntity = true;
                        dataToAdjust = this.performGET(activeVersionOfDeletedKeys, true, tenantId, true);
                        for (_f = 0, dataToAdjust_1 = dataToAdjust; _f < dataToAdjust_1.length; _f++) {
                            data = dataToAdjust_1[_f];
                            data.HasDraftEntity = false;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @param actionDefinition
     * @param actionData
     * @param odataRequest
     * @param keys
     */
    DraftMockEntitySet.prototype.executeAction = function (actionDefinition, actionData, odataRequest, keys) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData, responseObject, _c, draftData, keyValues, activeDraft, _loop_6, this_6, _d, _e, _i, navPropName;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        currentMockData = this.getMockData(odataRequest.tenantId);
                        return [4 /*yield*/, currentMockData.onBeforeAction(actionDefinition, actionData, keys)];
                    case 1:
                        actionData = _f.sent();
                        _c = actionDefinition.fullyQualifiedName;
                        switch (_c) {
                            case this.entitySetDefinition.annotations.Common.DraftRoot.EditAction + "(" + this.entitySetDefinition.entityTypeName + ")": return [3 /*break*/, 2];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.EditAction + "()": return [3 /*break*/, 2];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.PreparationAction + "(" + this.entitySetDefinition.entityTypeName + ")": return [3 /*break*/, 4];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.PreparationAction + "()": return [3 /*break*/, 4];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.DiscardAction + "(" + this.entitySetDefinition.entityTypeName + ")": return [3 /*break*/, 5];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.DiscardAction + "()": return [3 /*break*/, 5];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.ActivationAction + "(" + this.entitySetDefinition.entityTypeName + ")": return [3 /*break*/, 7];
                            case this.entitySetDefinition.annotations.Common.DraftRoot.ActivationAction + "()": return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 13];
                    case 2: return [4 /*yield*/, this.draftEdit(keys, odataRequest)];
                    case 3:
                        _f.sent();
                        odataRequest.query.queryPath.pop();
                        odataRequest.query.queryPath[odataRequest.query.queryPath.length - 1].keys = Object.assign({}, keys, {
                            IsActiveEntity: false
                        });
                        responseObject = this.dataAccess.getData(odataRequest);
                        return [3 /*break*/, 15];
                    case 4:
                        // Prepare
                        responseObject = this.performGET(keys, false, odataRequest.tenantId);
                        return [3 /*break*/, 15];
                    case 5: return [4 /*yield*/, this.draftDiscard(keys, odataRequest.tenantId)];
                    case 6:
                        // Discard
                        responseObject = _f.sent();
                        return [3 /*break*/, 15];
                    case 7:
                        draftData = this.performGET(keys, false, odataRequest.tenantId);
                        keyValues = Object.assign({}, keys);
                        keyValues.IsActiveEntity = true;
                        activeDraft = Object.assign({}, draftData);
                        activeDraft.IsActiveEntity = true;
                        activeDraft.DraftAdministrativeData = null;
                        activeDraft.HasDraftEntity = false;
                        if (currentMockData.hasEntry(keyValues)) {
                            currentMockData.updateEntry(keyValues, activeDraft);
                        }
                        else {
                            currentMockData.addEntry(activeDraft);
                        }
                        _loop_6 = function (navPropName) {
                            var navPropDetail, subKeys, navPropEntity;
                            return __generator(this, function (_g) {
                                switch (_g.label) {
                                    case 0:
                                        if (!(((_b = (_a = this_6.entitySetDefinition.navigationPropertyBinding[navPropName].annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftNode) &&
                                            navPropName !== 'SiblingEntity')) return [3 /*break*/, 3];
                                        navPropDetail = this_6.entityTypeDefinition.navigationProperties.find(function (navProp) { return navProp.name === navPropName; });
                                        subKeys = this_6.dataAccess.getNavigationPropertyKeys(draftData, navPropDetail, this_6.entitySetDefinition.entityType, {});
                                        return [4 /*yield*/, this_6.dataAccess.getMockEntitySet(this_6.entitySetDefinition.navigationPropertyBinding[navPropName].name)];
                                    case 1:
                                        navPropEntity = (_g.sent());
                                        if (!(navPropEntity && navPropEntity.activateInactiveVersion)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, navPropEntity.activateInactiveVersion(subKeys, odataRequest.tenantId)];
                                    case 2:
                                        _g.sent();
                                        _g.label = 3;
                                    case 3: return [2 /*return*/];
                                }
                            });
                        };
                        this_6 = this;
                        _d = [];
                        for (_e in this.entitySetDefinition.navigationPropertyBinding)
                            _d.push(_e);
                        _i = 0;
                        _f.label = 8;
                    case 8:
                        if (!(_i < _d.length)) return [3 /*break*/, 11];
                        navPropName = _d[_i];
                        return [5 /*yield**/, _loop_6(navPropName)];
                    case 9:
                        _f.sent();
                        _f.label = 10;
                    case 10:
                        _i++;
                        return [3 /*break*/, 8];
                    case 11: return [4 /*yield*/, this.draftDiscard(keys, odataRequest.tenantId)];
                    case 12:
                        _f.sent();
                        responseObject = activeDraft;
                        return [3 /*break*/, 15];
                    case 13: return [4 /*yield*/, currentMockData.executeAction(actionDefinition, actionData, keys)];
                    case 14:
                        responseObject = _f.sent();
                        return [3 /*break*/, 15];
                    case 15: return [4 /*yield*/, currentMockData.onAfterAction(actionDefinition, actionData, keys, responseObject)];
                    case 16:
                        responseObject = _f.sent();
                        return [2 /*return*/, responseObject];
                }
            });
        });
    };
    DraftMockEntitySet.prototype.performPATCH = function (keyValues, patchData, tenantId, updateParent) {
        var _a, _b, _c, _d, _e, _f;
        if (updateParent === void 0) { updateParent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var updatedData, parentEntity;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0: return [4 /*yield*/, _super.prototype.performPATCH.call(this, keyValues, patchData, tenantId)];
                    case 1:
                        updatedData = _g.sent();
                        if (!(updateParent && ((_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.Common) === null || _c === void 0 ? void 0 : _c.DraftNode))) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.dataAccess.getDraftRoot(keyValues, tenantId, this.entitySetDefinition)];
                    case 2:
                        parentEntity = _g.sent();
                        if (parentEntity &&
                            parentEntity.DraftAdministrativeData !== null &&
                            parentEntity.DraftAdministrativeData !== undefined) {
                            parentEntity.DraftAdministrativeData.LastChangeDateTime = common_1._getDateTimeOffset(this.isV4());
                        }
                        _g.label = 3;
                    case 3:
                        if (((_f = (_e = (_d = this.entitySetDefinition) === null || _d === void 0 ? void 0 : _d.annotations) === null || _e === void 0 ? void 0 : _e.Common) === null || _f === void 0 ? void 0 : _f.DraftRoot) &&
                            updatedData.DraftAdministrativeData !== null &&
                            updatedData.DraftAdministrativeData !== undefined) {
                            updatedData.DraftAdministrativeData.LastChangeDateTime = common_1._getDateTimeOffset(this.isV4());
                        }
                        return [2 /*return*/, updatedData];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param postData
     * @param tenantId
     */
    DraftMockEntitySet.prototype.performPOST = function (keyValues, postData, tenantId, updateParent) {
        var _a, _b, _c;
        if (updateParent === void 0) { updateParent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var parentEntity;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!(updateParent && ((_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.Common) === null || _c === void 0 ? void 0 : _c.DraftNode))) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dataAccess.getDraftRoot(keyValues, tenantId, this.entitySetDefinition)];
                    case 1:
                        parentEntity = _d.sent();
                        if (parentEntity &&
                            parentEntity.DraftAdministrativeData !== null &&
                            parentEntity.DraftAdministrativeData !== undefined) {
                            parentEntity.DraftAdministrativeData.LastChangeDateTime = common_1._getDateTimeOffset(this.isV4());
                        }
                        _d.label = 2;
                    case 2:
                        // Validate potentially missing keys
                        if (!Object.hasOwnProperty.call(postData, 'IsActiveEntity')) {
                            postData.IsActiveEntity = false;
                        }
                        if (!Object.hasOwnProperty.call(postData, 'HasActiveEntity')) {
                            postData.HasActiveEntity = false;
                        }
                        if (!Object.hasOwnProperty.call(postData, 'HasDraftEntity')) {
                            postData.HasDraftEntity = !postData.IsActiveEntity;
                        }
                        return [2 /*return*/, _super.prototype.performPOST.call(this, keyValues, postData, tenantId)];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param tenantId
     */
    DraftMockEntitySet.prototype.performDELETE = function (keyValues, tenantId, updateParent) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (updateParent === void 0) { updateParent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var draftData, parentEntity, activeKeys, activeEquivalent;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        draftData = this.performGET(keyValues, false, tenantId);
                        if (!(updateParent && ((_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.Common) === null || _c === void 0 ? void 0 : _c.DraftNode))) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dataAccess.getDraftRoot(keyValues, tenantId, this.entitySetDefinition)];
                    case 1:
                        parentEntity = _h.sent();
                        if (parentEntity &&
                            parentEntity.DraftAdministrativeData !== null &&
                            parentEntity.DraftAdministrativeData !== undefined) {
                            parentEntity.DraftAdministrativeData.LastChangeDateTime = common_1._getDateTimeOffset(this.isV4());
                        }
                        _h.label = 2;
                    case 2:
                        if (!(((_e = (_d = this.entitySetDefinition.annotations) === null || _d === void 0 ? void 0 : _d.Common) === null || _e === void 0 ? void 0 : _e.DraftRoot) && draftData && !draftData.IsActiveEntity)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.draftDiscard(keyValues, tenantId)];
                    case 3:
                        _h.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        if (((_g = (_f = this.entitySetDefinition.annotations) === null || _f === void 0 ? void 0 : _f.Common) === null || _g === void 0 ? void 0 : _g.DraftNode) && draftData && !draftData.IsActiveEntity) {
                            activeKeys = Object.assign({}, keyValues, { IsActiveEntity: true });
                            activeEquivalent = this.performGET(activeKeys, false, tenantId, true);
                            if (activeEquivalent && activeEquivalent.HasDraftEntity) {
                                activeEquivalent.HasDraftEntity = false;
                            }
                        }
                        return [2 /*return*/, _super.prototype.performDELETE.call(this, keyValues, tenantId)];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return DraftMockEntitySet;
}(entitySet_1.MockDataEntitySet));
exports.DraftMockEntitySet = DraftMockEntitySet;


/***/ }),

/***/ 4763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockDataEntitySet = void 0;
var path_1 = __webpack_require__(1017);
var lodash_clonedeep_1 = __importDefault(__webpack_require__(9548));
var fileBasedMockData_1 = __webpack_require__(2769);
var functionBasedMockData_1 = __webpack_require__(9215);
var fileLoader_1 = __webpack_require__(5352);
function getData(fullData, objectPath) {
    if (fullData === undefined || objectPath.length === 0) {
        return fullData;
    }
    if (objectPath.indexOf('/') === -1) {
        return fullData === null || fullData === void 0 ? void 0 : fullData[objectPath]; // fullData can be null
    }
    else {
        var subObjectPath = objectPath.split('/');
        return getData(fullData[subObjectPath[0]], subObjectPath.slice(1).join('/'));
    }
}
function transformationFn(type, check) {
    switch (type) {
        case 'tolower':
            return function (data) { return data.toLowerCase(); };
        case 'toupper':
            return function (data) { return data.toUpperCase(); };
        case 'trim':
            return function (data) { return data.trim(); };
        case 'length':
            return function (data) {
                return data && data.length;
            };
        case 'round':
            return function (data) { return Math.round(parseFloat(data)); };
        case 'floor':
            return function (data) { return Math.floor(parseFloat(data)); };
        case 'ceiling':
            return function (data) { return Math.ceil(parseFloat(data)); };
        case 'cast':
            return function (data) {
                switch (check) {
                    case 'Edm.String':
                        return data.toString();
                    case 'Edm.Boolean':
                        return data === 'true';
                    case 'Edm.Byte':
                    case 'Edm.Int16':
                    case 'Edm.Int32':
                    case 'Edm.Int64': {
                        return parseInt(data, 10);
                    }
                    case 'Edm.Decimal': {
                        return parseFloat(data);
                    }
                    default:
                        return data;
                }
            };
        case 'startswith':
            return function (data) {
                return data.startsWith(check);
            };
        case 'endswith':
            return function (data) {
                return data.endsWith(check);
            };
        case 'contains':
            return function (data) {
                return data.indexOf(check) !== -1;
            };
        case 'concat':
            return function (data) {
                return data + check;
            };
        case 'indexof':
            return function (data) {
                return data.indexOf(check);
            };
        case 'substring':
            return function (data) {
                return data.substring(check);
            };
        case 'matchesPattern':
            var regExp_1 = new RegExp(check);
            return function (data) {
                return regExp_1.test(data);
            };
        case 'noop':
        default:
            return function (data) { return data; };
    }
}
function prepareLiteral(literal, property) {
    if (!literal) {
        return literal;
    }
    switch (property.type) {
        case 'Edm.Boolean':
            return literal === 'true';
        case 'Edm.String':
        case 'Edm.Guid':
            if (literal && literal.startsWith("'")) {
                return literal.substr(1, literal.length - 2);
            }
            else {
                return literal;
            }
        case 'Edm.Byte':
        case 'Edm.Int16':
        case 'Edm.Int32':
        case 'Edm.Int64': {
            return parseInt(literal, 10);
        }
        case 'Edm.Decimal': {
            return parseFloat(literal);
        }
        default:
            return literal;
    }
}
/**
 *
 */
var MockDataEntitySet = /** @class */ (function () {
    /**
     * @param rootFolder
     * @param entitySetDefinition
     * @param dataAccess
     * @param generateMockData
     * @param initializeMockData
     * @param isDraft
     */
    function MockDataEntitySet(rootFolder, entitySetDefinition, dataAccess, generateMockData, initializeMockData, isDraft) {
        var _this = this;
        if (initializeMockData === void 0) { initializeMockData = true; }
        if (isDraft === void 0) { isDraft = false; }
        this._rootMockData = [];
        this.contextBasedMockData = {};
        if (entitySetDefinition._type === 'EntityType') {
            this.entitySetDefinition = null;
            this.entityTypeDefinition = entitySetDefinition;
        }
        else {
            this.entitySetDefinition = entitySetDefinition;
            this.entityTypeDefinition = this.entitySetDefinition.entityType;
        }
        this.dataAccess = dataAccess;
        if (initializeMockData) {
            this.readyPromise = MockDataEntitySet.read(rootFolder, entitySetDefinition.name, generateMockData, isDraft, dataAccess).then(function (mockData) {
                if (typeof mockData === 'object' && !Array.isArray(mockData)) {
                    _this._rootMockDataFn = mockData;
                }
                else {
                    _this._rootMockData = mockData;
                }
                return _this;
            });
        }
    }
    /**
     * @param mockDataRootFolder
     * @param entity
     * @param generateMockData
     * @param isDraft
     */
    MockDataEntitySet.read = function (mockDataRootFolder, entity, generateMockData, isDraft, dataAccess) {
        return __awaiter(this, void 0, void 0, function () {
            var path, jsPath, outData, isInitial, e_1, _a, fileContent, outJsonData_1, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        path = path_1.join(mockDataRootFolder, entity) + '.json';
                        jsPath = path_1.join(mockDataRootFolder, entity) + '.js';
                        outData = [];
                        isInitial = true;
                        if (dataAccess.debug) {
                            dataAccess.log.info('Trying to find ' + jsPath + ' for mockdata');
                        }
                        return [4 /*yield*/, fileLoader_1.exists(jsPath)];
                    case 1:
                        if (!_b.sent()) return [3 /*break*/, 5];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, fileLoader_1.loadJS(jsPath)];
                    case 3:
                        //eslint-disable-next-line
                        outData = _b.sent();
                        isInitial = false;
                        dataAccess.log.info('JS file found for ' + entity);
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _b.sent();
                        console.error(e_1);
                        return [2 /*return*/, Promise.resolve([])];
                    case 5:
                        _a = (isInitial || !outData.getInitialDataSet);
                        if (!_a) return [3 /*break*/, 7];
                        return [4 /*yield*/, fileLoader_1.exists(path)];
                    case 6:
                        _a = (_b.sent());
                        _b.label = 7;
                    case 7:
                        if (!_a) return [3 /*break*/, 11];
                        if (dataAccess.debug) {
                            dataAccess.log.info('Trying to find ' + path + ' for mockdata');
                        }
                        _b.label = 8;
                    case 8:
                        _b.trys.push([8, 10, , 11]);
                        return [4 /*yield*/, fileLoader_1.loadFile(path)];
                    case 9:
                        fileContent = _b.sent();
                        if (fileContent.length === 0) {
                            outJsonData_1 = [];
                        }
                        else {
                            outJsonData_1 = JSON.parse(fileContent);
                            if (isDraft) {
                                outJsonData_1.forEach(function (jsonLine) {
                                    var IsActiveEntityValue = jsonLine.IsActiveEntity;
                                    if (IsActiveEntityValue === undefined) {
                                        jsonLine.IsActiveEntity = true;
                                        jsonLine.HasActiveEntity = true;
                                        jsonLine.HasDraftEntity = false;
                                    }
                                });
                            }
                        }
                        dataAccess.log.info('JSON file found for ' + entity);
                        if (isInitial) {
                            outData = outJsonData_1;
                            isInitial = false;
                        }
                        else {
                            outData.getInitialDataSet = function (contextId) {
                                return outJsonData_1.concat();
                            };
                        }
                        return [3 /*break*/, 11];
                    case 10:
                        e_2 = _b.sent();
                        if (dataAccess.debug) {
                            dataAccess.log.info(e_2);
                        }
                        return [3 /*break*/, 11];
                    case 11:
                        if (isInitial) {
                            outData = [];
                            if (generateMockData) {
                                outData.__generateMockData = generateMockData;
                            }
                        }
                        return [2 /*return*/, outData];
                }
            });
        });
    };
    /**
     * @param contextId
     */
    MockDataEntitySet.prototype.getMockData = function (contextId) {
        if (!Object.prototype.hasOwnProperty.apply(this.contextBasedMockData, [contextId])) {
            this.contextBasedMockData[contextId] = this._rootMockDataFn
                ? new functionBasedMockData_1.FunctionBasedMockData(this._rootMockDataFn, this.entityTypeDefinition, this, contextId)
                : new fileBasedMockData_1.FileBasedMockData(this._rootMockData, this.entityTypeDefinition, this, contextId);
        }
        return this.contextBasedMockData[contextId];
    };
    /**
     * @param keyValues
     * @param dataLine
     * @param keyDefinition
     */
    MockDataEntitySet.prototype.checkKeys = function (keyValues, dataLine, keyDefinition) {
        var _this = this;
        return Object.keys(keyValues).every(function (keyName) {
            return _this.checkKeyValue(dataLine, keyValues, keyName, keyDefinition.find(function (keyProp) { return keyProp.name === keyName; }));
        });
    };
    /**
     * @param filterExpression
     * @param mockData
     * @param allData
     */
    MockDataEntitySet.prototype.checkSpecificProperties = function (filterExpression, mockData, allData) {
        return null;
    };
    /**
     *
     */
    MockDataEntitySet.prototype.isV4 = function () {
        return this.dataAccess.isV4();
    };
    MockDataEntitySet.prototype.getProperty = function (identifier) {
        var resolvedPath;
        if (this.entitySetDefinition) {
            resolvedPath = this.dataAccess
                .getMetadata()
                .resolvePath('/' + this.entitySetDefinition.name + '/' + identifier);
        }
        else {
            resolvedPath = this.entityTypeDefinition.resolvePath(identifier, true);
        }
        return resolvedPath.target;
    };
    /**
     * @param mockData
     * @param filterExpression
     * @param tenantId
     */
    MockDataEntitySet.prototype.checkFilter = function (mockData, filterExpression, tenantId) {
        var _this = this;
        var isValid = true;
        if (filterExpression.hasOwnProperty('expressions')) {
            if (filterExpression.operator === 'AND') {
                isValid = filterExpression.expressions.every(function (filterValue) {
                    return _this.checkFilter(mockData, filterValue, tenantId);
                });
            }
            else {
                isValid = filterExpression.expressions.some(function (filterValue) {
                    return _this.checkFilter(mockData, filterValue, tenantId);
                });
            }
        }
        else {
            isValid = this.checkSimpleExpression(filterExpression, mockData, tenantId);
        }
        return isValid;
    };
    MockDataEntitySet.prototype.checkSimpleExpression = function (filterExpression, mockData, tenantId) {
        var _this = this;
        var identifier = filterExpression.identifier;
        var operator = filterExpression.operator;
        var literal = filterExpression.literal;
        var identifierTransformation = transformationFn('noop');
        var comparisonType = null;
        if (identifier.type === 'lambda') {
            var lambdaOperator = identifier.operator;
            var hasAnyValid_1 = false;
            var hasAllValid_1 = true;
            var mockDataToCheckValue = identifierTransformation(getData(mockData, identifier.target));
            identifier.expression.identifier = identifier.expression.identifier.replace(identifier.key, '');
            mockDataToCheckValue.find(function (subMockData) {
                var isEntryValid = _this.checkSimpleExpression(identifier.expression, subMockData, tenantId);
                if (!isEntryValid) {
                    hasAllValid_1 = false;
                }
                else {
                    hasAnyValid_1 = true;
                }
            });
            if (lambdaOperator === 'ANY') {
                return hasAnyValid_1;
            }
            else {
                return hasAllValid_1;
            }
        }
        else if (identifier.method) {
            identifierTransformation = transformationFn(identifier.method, prepareLiteral(identifier.methodArgs[1], this.getProperty(identifier.methodArgs[0])));
            if (identifier.method === 'length' || identifier.method === 'indexof') {
                comparisonType = 'Edm.Int16';
            }
            else {
                comparisonType = 'Edm.String';
            }
            identifier = identifier.methodArgs[0];
        }
        var literalTransformation = transformationFn('noop');
        if (literal && literal.method) {
            literalTransformation = transformationFn(literal.method);
            literal = literalTransformation(literal.methodArgs[0]);
        }
        else if (!literal) {
            literal = true;
        }
        var property = this.getProperty(identifier);
        if (!comparisonType) {
            comparisonType = property.type;
        }
        var currentMockData = this.getMockData(tenantId);
        var specificCheck = this.checkSpecificProperties(filterExpression, mockData, currentMockData);
        if (specificCheck !== null) {
            return specificCheck;
        }
        var mockValue = identifierTransformation(getData(mockData, identifier));
        if (literal === true) {
            return mockValue === literal;
        }
        var isValid = true;
        switch (comparisonType) {
            case 'Edm.Boolean':
                isValid = !!mockValue === (literal === 'true');
                break;
            case 'Edm.Byte':
            case 'Edm.Int16':
            case 'Edm.Int32':
            case 'Edm.Int64': {
                var testValue = parseInt(literal, 10);
                switch (operator) {
                    case 'gt':
                        isValid = mockValue > testValue;
                        break;
                    case 'ge':
                        isValid = mockValue >= testValue;
                        break;
                    case 'lt':
                        isValid = mockValue < testValue;
                        break;
                    case 'le':
                        isValid = mockValue <= testValue;
                        break;
                    case 'ne':
                        isValid = mockValue !== testValue;
                        break;
                    case 'eq':
                    default:
                        isValid = mockValue === testValue;
                        break;
                }
                break;
            }
            case 'Edm.Decimal': {
                var testValue = parseFloat(literal);
                switch (operator) {
                    case 'gt':
                        isValid = mockValue > testValue;
                        break;
                    case 'ge':
                        isValid = mockValue >= testValue;
                        break;
                    case 'lt':
                        isValid = mockValue < testValue;
                        break;
                    case 'le':
                        isValid = mockValue <= testValue;
                        break;
                    case 'ne':
                        isValid = mockValue !== testValue;
                        break;
                    case 'eq':
                    default:
                        isValid = mockValue === testValue;
                        break;
                }
                break;
            }
            case 'Edm.String':
            case 'Edm.Guid':
            default:
                if (literal && literal.startsWith("guid'")) {
                    isValid = mockValue === literal.substr(5, literal.length - 6);
                }
                else if (literal && literal.startsWith("'")) {
                    isValid = mockValue === literal.substr(1, literal.length - 2);
                }
                else {
                    isValid = mockValue === literal;
                }
                break;
        }
        return isValid;
    };
    /**
     * @param mockData
     * @param searchQueries
     */
    MockDataEntitySet.prototype.checkSearch = function (mockData, searchQueries) {
        var searchableProperties = this.entityTypeDefinition.entityProperties.filter(function (property) {
            switch (property.type) {
                case 'Edm.Boolean':
                case 'Edm.Int32':
                    return false;
                case 'Edm.String':
                    return true;
                default:
                    return false;
            }
        });
        return searchQueries.every(function (searchQuery) {
            return searchableProperties.some(function (property) {
                var mockValue = mockData[property.name];
                return mockValue && mockValue.indexOf(searchQuery) !== -1;
            });
        });
    };
    /**
     * @param mockData
     * @param keyValues
     * @param keyName
     * @param keyProp
     */
    MockDataEntitySet.prototype.checkKeyValue = function (mockData, keyValues, keyName, keyProp) {
        if (keyProp) {
            switch (keyProp.type) {
                case 'Edm.Guid':
                    if (keyValues[keyName] && keyValues[keyName].startsWith("guid'")) {
                        return mockData[keyName] === keyValues[keyName].substr(5, keyValues[keyName].length - 6);
                    }
                    return mockData[keyName] === keyValues[keyName];
                case 'Edm.String':
                    if (keyValues[keyName] && keyValues[keyName].startsWith("'")) {
                        return mockData[keyName] === keyValues[keyName].substr(1, keyValues[keyName].length - 2);
                    }
                    return mockData[keyName] === keyValues[keyName];
                case 'Edm.Int32':
                case 'Edm.Int64':
                case 'Edm.Int16':
                    return mockData[keyName] === parseInt(keyValues[keyName], 10);
                default:
                    return mockData[keyName] === keyValues[keyName];
            }
        }
        return mockData[keyName] === keyValues[keyName];
    };
    /**
     * @param dataLine
     */
    MockDataEntitySet.prototype.getKeys = function (dataLine) {
        var keys = this.entityTypeDefinition.keys;
        var keyValues = {};
        keys.forEach(function (keyProp) {
            keyValues[keyProp.name] = dataLine[keyProp.name];
        });
        return keyValues;
    };
    /**
     * @param keyValues
     */
    MockDataEntitySet.prototype.prepareKeys = function (keyValues) {
        var _this = this;
        var outKeys = {};
        if (keyValues === undefined) {
            return outKeys;
        }
        if (Object.keys(keyValues).length === 1 && Object.values(keyValues)[0] === undefined) {
            var keyValue_1;
            Object.keys(keyValues).forEach(function (keyName) {
                keyValue_1 = keyName;
                if (keyValue_1.startsWith("'")) {
                    keyValue_1 = keyValue_1.substr(1, keyValue_1.length - 2);
                }
            });
            var keyName = this.entityTypeDefinition.keys[0].name;
            outKeys[keyName] = keyValue_1;
        }
        else {
            outKeys = keyValues;
        }
        // Remove non key items only if all keys are provided
        var realKeys = outKeys;
        if (this.entityTypeDefinition.keys.every(function (keyProp) { return outKeys[keyProp.name] !== undefined; })) {
            realKeys = {};
            Object.keys(outKeys).forEach(function (keyName) {
                if (_this.entityTypeDefinition.keys.find(function (keyProp) { return keyProp.name === keyName; })) {
                    realKeys[keyName] = outKeys[keyName];
                }
            });
        }
        return realKeys;
    };
    /**
     * @param keyValues
     * @param asArray
     * @param tenantId
     * @param dontClone
     */
    MockDataEntitySet.prototype.performGET = function (keyValues, asArray, tenantId, dontClone) {
        var _a, _b, _c, _d, _e;
        if (dontClone === void 0) { dontClone = false; }
        var currentMockData = this.getMockData(tenantId);
        if (keyValues && Object.keys(keyValues).length) {
            keyValues = this.prepareKeys(keyValues);
            var data = currentMockData.fetchEntries(keyValues);
            if (!data || (Array.isArray(data) && data.length === 0 && !asArray)) {
                if (!currentMockData.hasEntries()) {
                    return currentMockData.getEmptyObject();
                }
                else {
                    return null;
                }
            }
            if (Array.isArray(data) && !asArray) {
                if (dontClone) {
                    return data[0];
                }
                return lodash_clonedeep_1.default(data[0]);
            }
            if (dontClone) {
                return data;
            }
            return lodash_clonedeep_1.default(data);
        }
        if ((_e = (_d = (_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.entityType) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.Common) === null || _d === void 0 ? void 0 : _d.ResultContext) === null || _e === void 0 ? void 0 : _e.valueOf()) {
            // Parametrized entityset, they cannot be requested directly
            throw new Error(JSON.stringify({ message: 'Parametrized entityset need to be queried with keys' }));
        }
        if (!asArray) {
            return lodash_clonedeep_1.default(currentMockData.getDefaultElement());
        }
        return currentMockData.getAllEntries(dontClone);
    };
    /**
     * @param keyValues
     * @param postData
     * @param tenantId
     */
    MockDataEntitySet.prototype.performPOST = function (keyValues, postData, tenantId, updateParent) {
        if (updateParent === void 0) { updateParent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData, newObject;
            return __generator(this, function (_a) {
                // Validate potentially missing keys
                keyValues = this.prepareKeys(keyValues);
                currentMockData = this.getMockData(tenantId);
                Object.keys(keyValues).forEach(function (key) {
                    if (!postData[key]) {
                        postData[key] = keyValues[key];
                    }
                });
                this.entityTypeDefinition.keys.forEach(function (keyProp) {
                    if (postData[keyProp.name] === undefined || postData[keyProp.name].length === 0) {
                        // Missing key
                        if (keyProp.name === 'IsActiveEntity') {
                            postData['IsActiveEntity'] = false;
                        }
                        else {
                            postData[keyProp.name] = currentMockData.generateKey(keyProp);
                        }
                    }
                });
                newObject = currentMockData.getEmptyObject();
                newObject = Object.assign(newObject, postData);
                currentMockData.addEntry(newObject);
                return [2 /*return*/, newObject];
            });
        });
    };
    /**
     * @param keyValues
     * @param patchData
     * @param tenantId
     */
    MockDataEntitySet.prototype.performPATCH = function (keyValues, patchData, tenantId, updateParent) {
        if (updateParent === void 0) { updateParent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var data, currentMockData, updatedData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyValues = this.prepareKeys(keyValues);
                        data = this.performGET(keyValues, false, tenantId);
                        currentMockData = this.getMockData(tenantId);
                        updatedData = Object.assign(data, patchData);
                        return [4 /*yield*/, currentMockData.onBeforeUpdateEntry(keyValues, updatedData)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, currentMockData.updateEntry(keyValues, updatedData)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, currentMockData.onAfterUpdateEntry(keyValues, updatedData)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, updatedData];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param tenantId
     */
    MockDataEntitySet.prototype.performDELETE = function (keyValues, tenantId, updateParent) {
        if (updateParent === void 0) { updateParent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData;
            return __generator(this, function (_a) {
                currentMockData = this.getMockData(tenantId);
                keyValues = this.prepareKeys(keyValues);
                currentMockData.removeEntry(keyValues);
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param actionDefinition
     * @param actionData
     * @param odataRequest
     * @param keys
     */
    MockDataEntitySet.prototype.executeAction = function (actionDefinition, actionData, odataRequest, keys) {
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData, responseObject;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentMockData = this.getMockData(odataRequest.tenantId);
                        keys = this.prepareKeys(keys);
                        return [4 /*yield*/, currentMockData.onBeforeAction(actionDefinition, actionData, keys)];
                    case 1:
                        actionData = _a.sent();
                        return [4 /*yield*/, currentMockData.executeAction(actionDefinition, actionData, keys)];
                    case 2:
                        responseObject = _a.sent();
                        return [4 /*yield*/, currentMockData.onAfterAction(actionDefinition, actionData, keys, responseObject)];
                    case 3:
                        responseObject = _a.sent();
                        return [2 /*return*/, responseObject];
                }
            });
        });
    };
    MockDataEntitySet.prototype.getParentEntityInterface = function (tenantId) {
        return __awaiter(this, void 0, void 0, function () {
            var parentEntitySetName;
            return __generator(this, function (_a) {
                parentEntitySetName = this.dataAccess.getMetadata().getParentEntitySetName(this.entitySetDefinition);
                return [2 /*return*/, this.getEntityInterface(parentEntitySetName, tenantId)];
            });
        });
    };
    MockDataEntitySet.prototype.getEntityInterface = function (entitySet, tenantId) {
        return __awaiter(this, void 0, void 0, function () {
            var mockEntitySet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.dataAccess.getMockEntitySet(entitySet)];
                    case 1:
                        mockEntitySet = _a.sent();
                        return [2 /*return*/, mockEntitySet === null || mockEntitySet === void 0 ? void 0 : mockEntitySet.getMockData(tenantId)];
                }
            });
        });
    };
    return MockDataEntitySet;
}());
exports.MockDataEntitySet = MockDataEntitySet;


/***/ }),

/***/ 2769:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileBasedMockData = void 0;
var lodash_clonedeep_1 = __importDefault(__webpack_require__(9548));
var id_1 = __webpack_require__(1016);
/**
 *
 */
var FileBasedMockData = /** @class */ (function () {
    /**
     * @param mockData
     * @param entityType
     * @param mockDataEntitySet
     */
    function FileBasedMockData(mockData, entityType, mockDataEntitySet, contextId) {
        var _this = this;
        this._entityType = entityType;
        this._contextId = contextId;
        this._mockDataEntitySet = mockDataEntitySet;
        if (mockData.length === 0 && mockData.__generateMockData) {
            this._mockData = this.generateMockData();
        }
        else {
            this._mockData = lodash_clonedeep_1.default(mockData);
            if (this._mockData.forEach) {
                this._mockData.forEach(function (mockLine) {
                    // We need to ensure that complex types are at least partially created
                    _this._entityType.entityProperties.forEach(function (prop) {
                        if (prop.targetType && !mockLine[prop.name]) {
                            mockLine[prop.name] = {};
                            prop.targetType.properties.forEach(function (subProp) {
                                mockLine[prop.name][subProp.name] = _this.getDefaultValueFromType(subProp.type, subProp.targetType, subProp.defaultValue);
                            });
                        }
                    });
                });
            }
        }
    }
    /**
     * @param mockEntry
     */
    FileBasedMockData.prototype.addEntry = function (mockEntry) {
        this._mockData.push(mockEntry);
    };
    /**
     * @param keyValues
     * @param updatedData
     */
    FileBasedMockData.prototype.updateEntry = function (keyValues, updatedData) {
        var dataIndex = this.getDataIndex(keyValues);
        this._mockData[dataIndex] = updatedData;
    };
    /**
     * @param keyValues
     */
    FileBasedMockData.prototype.fetchEntries = function (keyValues) {
        var _this = this;
        var keys = this._entityType.keys;
        return this._mockData.filter(function (mockData) {
            return Object.keys(keyValues).every(function (keyName) {
                return _this._mockDataEntitySet.checkKeyValue(mockData, keyValues, keyName, keys.find(function (keyProp) { return keyProp.name === keyName; }));
            });
        });
    };
    /**
     * @param keyValues
     */
    FileBasedMockData.prototype.hasEntry = function (keyValues) {
        return this.getDataIndex(keyValues) !== -1;
    };
    /**
     *
     */
    FileBasedMockData.prototype.hasEntries = function () {
        return this._mockData.length > 0;
    };
    /**
     *
     */
    FileBasedMockData.prototype.getAllEntries = function (dontClone) {
        if (dontClone === void 0) { dontClone = false; }
        if (dontClone) {
            return this._mockData;
        }
        return lodash_clonedeep_1.default(this._mockData);
    };
    /**
     * @param keyValues
     */
    FileBasedMockData.prototype.getDataIndex = function (keyValues) {
        var _this = this;
        var keys = this._entityType.keys;
        return this._mockData.findIndex(function (mockData) {
            return Object.keys(keyValues).every(function (keyName) {
                return _this._mockDataEntitySet.checkKeyValue(mockData, keyValues, keyName, keys.find(function (keyProp) { return keyProp.name === keyName; }));
            });
        });
    };
    /**
     * @param keyValues
     */
    FileBasedMockData.prototype.removeEntry = function (keyValues) {
        var dataIndex = this.getDataIndex(keyValues);
        if (dataIndex !== -1) {
            this._mockData.splice(dataIndex, 1);
        }
    };
    /**
     * @param type
     * @param complexType
     * @param defaultValue
     */
    FileBasedMockData.prototype.getDefaultValueFromType = function (type, complexType, defaultValue) {
        var _this = this;
        if (complexType) {
            var outData_1 = {};
            complexType.properties.forEach(function (subProp) {
                outData_1[subProp.name] = _this.getDefaultValueFromType(subProp.type, subProp.targetType, subProp.defaultValue);
            });
            return outData_1;
        }
        else {
            if (defaultValue !== undefined) {
                return defaultValue;
            }
            switch (type) {
                case 'Edm.Int16':
                case 'Edm.Byte':
                case 'Edm.Int32':
                case 'Edm.Int64':
                    return 0;
                case 'Edm.Boolean':
                    return false;
                case 'Edm.DateTimeOffset': {
                    var date = new Date();
                    return this._mockDataEntitySet.isV4() ? date.toISOString() : '/Date(' + date.getTime() + '+0000)/';
                }
                case 'Edm.Date':
                case 'Edm.DateTime': {
                    var date = new Date();
                    var dateOut = date.getUTCFullYear() +
                        '-' +
                        ('0' + (date.getUTCMonth() + 1)).slice(-2) +
                        '-' +
                        ('0' + date.getUTCDate()).slice(-2);
                    return this._mockDataEntitySet.isV4() ? dateOut : '/Date(' + date.getTime() + '+0000)/';
                }
                case 'Edm.Time':
                case 'Time': {
                    var date = new Date();
                    // ODataModel expects ISO8601 duration format
                    return 'PT' + date.getHours() + 'H' + date.getMinutes() + 'M' + date.getSeconds() + 'S';
                }
                default:
                    return '';
            }
        }
    };
    /**
     * @param type
     * @param complexType
     * @param propertyName
     * @param lineIndex
     */
    FileBasedMockData.prototype.getRandomValueFromType = function (type, complexType, propertyName, lineIndex) {
        var _this = this;
        if (complexType) {
            var outData_2 = {};
            complexType.properties.forEach(function (subProp) {
                outData_2[subProp.name] = _this.getRandomValueFromType(subProp.type, subProp.targetType, subProp.name, lineIndex);
            });
            return outData_2;
        }
        else {
            switch (type) {
                case 'Edm.Int16':
                case 'Edm.Int32':
                case 'Edm.Int64':
                    return Math.floor(Math.random() * 10000);
                case 'Edm.String':
                    return propertyName + "_" + lineIndex;
                case 'Edm.Boolean':
                    return Math.random() < 0.5;
                case 'Edm.Byte':
                    return Math.floor(Math.random() * 10);
                case 'Edm.Decimal':
                    return Math.floor(Math.random() * 100000) / 100;
                case 'Edm.Guid':
                    return id_1.uuidv4();
                case 'Edm.Date':
                case 'Edm.DateTime':
                case 'Edm.DateTimeOffset': {
                    var date = new Date();
                    date.setFullYear(2000 + Math.floor(Math.random() * 22));
                    date.setDate(Math.floor(Math.random() * 30));
                    date.setMonth(Math.floor(Math.random() * 12));
                    date.setMilliseconds(0);
                    if (type === 'Edm.Date') {
                        var dateOut = date.getUTCFullYear() +
                            '-' +
                            ('0' + (date.getUTCMonth() + 1)).slice(-2) +
                            '-' +
                            ('0' + date.getUTCDate()).slice(-2);
                        return this._mockDataEntitySet.isV4() ? dateOut : '/Date(' + date.getTime() + '+0000)/';
                    }
                    else {
                        return this._mockDataEntitySet.isV4()
                            ? date.toISOString()
                            : '/Date(' + date.getTime() + '+0000)/';
                    }
                }
                case 'Edm.Time':
                case 'Time':
                    // ODataModel expects ISO8601 duration format
                    return ('PT' +
                        Math.floor(Math.random() * 23) +
                        'H' +
                        Math.floor(Math.random() * 59) +
                        'M' +
                        Math.floor(Math.random() * 59) +
                        'S');
                case 'Edm.TimeOfDay':
                case 'Edm.Binary':
                default:
                    return '';
            }
        }
    };
    /**
     *
     */
    FileBasedMockData.prototype.getEmptyObject = function () {
        var _this = this;
        var outObj = {};
        this._entityType.entityProperties.forEach(function (property) {
            outObj[property.name] = _this.getDefaultValueFromType(property.type, property.targetType, property.defaultValue);
        });
        return outObj;
    };
    /**
     *
     */
    FileBasedMockData.prototype.getDefaultElement = function () {
        if (this._mockData && !this._mockData.length) {
            return this._mockData;
        }
        else if (this._mockData.length >= 1) {
            return lodash_clonedeep_1.default(this._mockData[0]);
        }
        else {
            return this.getEmptyObject();
        }
    };
    /**
     * @param property
     * @param lineIndex
     */
    FileBasedMockData.prototype.generateKey = function (property, lineIndex, mockData) {
        if (mockData === void 0) { mockData = []; }
        var currentMockData = this._mockData || mockData;
        var highestIndex;
        switch (property.type) {
            case 'Edm.Int32':
                highestIndex = 0;
                currentMockData.forEach(function (mockLine) {
                    var lineIndex = parseInt(mockLine[property.name], 10);
                    highestIndex = Math.max(highestIndex, lineIndex);
                });
                return highestIndex + 1;
            case 'Edm.Boolean':
                return Math.random() > 0.5;
            case 'Edm.Guid':
                return id_1.uuidv4();
            case 'Edm.String':
                if (lineIndex === undefined) {
                    lineIndex = currentMockData.length + 1;
                }
                return property.name + "_" + lineIndex;
            default:
                return id_1.generateId(12);
        }
    };
    /**
     * @param iIndex
     */
    FileBasedMockData.prototype.generateMockDataLine = function (iIndex, mockData) {
        var _this = this;
        var outObj = {};
        this._entityType.entityProperties.forEach(function (property) {
            if (property.isKey) {
                outObj[property.name] = _this.generateKey(property, iIndex, mockData);
            }
            else {
                outObj[property.name] = _this.getRandomValueFromType(property.type, property.targetType, property.name, iIndex);
            }
        });
        return outObj;
    };
    FileBasedMockData.prototype.getParentEntityInterface = function () {
        return this._mockDataEntitySet.getParentEntityInterface(this._contextId);
    };
    FileBasedMockData.prototype.getEntityInterface = function (entitySetName) {
        return this._mockDataEntitySet.getEntityInterface(entitySetName, this._contextId);
    };
    /**
     *
     */
    FileBasedMockData.prototype.generateMockData = function () {
        var mockData = [];
        for (var i = 0; i < 150; i++) {
            mockData.push(this.generateMockDataLine(i, mockData));
        }
        return mockData;
    };
    /**
     * Allow to modify the action data beforehand
     *
     * @param actionDefinition
     * @param actionData
     * @param keys
     */
    FileBasedMockData.prototype.onBeforeAction = function (actionDefinition, actionData, keys) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, actionData];
            });
        });
    };
    /**
     * Do something with the action
     *
     * @param actionDefinition
     * @param actionData
     * @param keys
     */
    FileBasedMockData.prototype.executeAction = function (actionDefinition, actionData, keys) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, actionData];
            });
        });
    };
    /**
     * Allow to modify the response data
     *
     * @param actionDefinition
     * @param actionData
     * @param keys
     * @param responseData
     */
    FileBasedMockData.prototype.onAfterAction = function (actionDefinition, actionData, keys, responseData) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, responseData];
            });
        });
    };
    //eslint-disable-next-line
    FileBasedMockData.prototype.onAfterUpdateEntry = function (keyValues, updatedData) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    //eslint-disable-next-line
    FileBasedMockData.prototype.onBeforeUpdateEntry = function (keyValues, updatedData) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    //eslint-disable-next-line
    FileBasedMockData.prototype.hasCustomAggregate = function (customAggregateName) {
        return false;
    };
    //eslint-disable-next-line
    FileBasedMockData.prototype.performCustomAggregate = function (customAggregateName, dataToAggregate) { };
    return FileBasedMockData;
}());
exports.FileBasedMockData = FileBasedMockData;


/***/ }),

/***/ 9215:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionBasedMockData = void 0;
var fileBasedMockData_1 = __webpack_require__(2769);
var common_1 = __webpack_require__(5650);
/**
 *
 */
var FunctionBasedMockData = /** @class */ (function (_super) {
    __extends(FunctionBasedMockData, _super);
    /**
     * @param mockDataFn
     * @param entityType
     * @param mockDataEntitySet
     * @param contextId
     */
    function FunctionBasedMockData(mockDataFn, entityType, mockDataEntitySet, contextId) {
        var _this = this;
        var noMock = [];
        noMock.__generateMockData = true;
        _this = _super.call(this, ((mockDataFn === null || mockDataFn === void 0 ? void 0 : mockDataFn.getInitialDataSet) ? mockDataFn.getInitialDataSet(contextId) : noMock) || noMock, entityType, mockDataEntitySet, contextId) || this;
        _this._mockDataFn = mockDataFn;
        _this._mockDataFn.base = {
            generateMockData: _super.prototype.generateMockData.bind(_this),
            generateKey: _super.prototype.generateKey.bind(_this),
            addEntry: _super.prototype.addEntry.bind(_this),
            updateEntry: function (keyValues, patchData) {
                var data = _this.fetchEntries(keyValues)[0];
                var updatedData = Object.assign(data, patchData);
                return _super.prototype.updateEntry.call(_this, keyValues, updatedData);
            },
            removeEntry: _super.prototype.removeEntry.bind(_this),
            fetchEntries: _super.prototype.fetchEntries.bind(_this),
            hasEntry: _super.prototype.hasEntry.bind(_this),
            hasEntries: _super.prototype.hasEntries.bind(_this),
            getAllEntries: _super.prototype.getAllEntries.bind(_this),
            getEmptyObject: _super.prototype.getEmptyObject.bind(_this),
            getDefaultElement: _super.prototype.getDefaultElement.bind(_this),
            getParentEntityInterface: _super.prototype.getParentEntityInterface.bind(_this),
            getEntityInterface: _super.prototype.getEntityInterface.bind(_this)
        };
        _this._mockDataFn.throwError = function (message, statusCode, messageData, isSAPMessage, headers) {
            if (statusCode === void 0) { statusCode = 500; }
            if (isSAPMessage === void 0) { isSAPMessage = false; }
            if (headers === void 0) { headers = {}; }
            var executionError = new common_1.ExecutionError(message, statusCode, messageData, isSAPMessage, headers);
            throw executionError;
        };
        return _this;
    }
    /**
     * @param mockEntry
     */
    FunctionBasedMockData.prototype.addEntry = function (mockEntry) {
        if (this._mockDataFn.addEntry) {
            return this._mockDataFn.addEntry(mockEntry);
        }
        return _super.prototype.addEntry.call(this, mockEntry);
    };
    /**
     * @param keyValues
     * @param updatedData
     */
    FunctionBasedMockData.prototype.updateEntry = function (keyValues, updatedData) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this._mockDataFn.updateEntry) {
                    return [2 /*return*/, this._mockDataFn.updateEntry(keyValues, updatedData)];
                }
                return [2 /*return*/, _super.prototype.updateEntry.call(this, keyValues, updatedData)];
            });
        });
    };
    /**
     * @param keyValues
     */
    FunctionBasedMockData.prototype.removeEntry = function (keyValues) {
        if (this._mockDataFn.removeEntry) {
            return this._mockDataFn.removeEntry(keyValues);
        }
        return _super.prototype.removeEntry.call(this, keyValues);
    };
    /**
     * @param keyValues
     */
    FunctionBasedMockData.prototype.fetchEntries = function (keyValues) {
        var _a;
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.fetchEntries) {
            return this._mockDataFn.fetchEntries(keyValues);
        }
        else {
            return _super.prototype.fetchEntries.call(this, keyValues);
        }
    };
    /**
     * @param keyValues
     */
    FunctionBasedMockData.prototype.hasEntry = function (keyValues) {
        if (this._mockDataFn.hasEntry) {
            return this._mockDataFn.hasEntry(keyValues);
        }
        return _super.prototype.hasEntry.call(this, keyValues);
    };
    /**
     *
     */
    FunctionBasedMockData.prototype.hasEntries = function () {
        if (this._mockDataFn.hasEntries) {
            return this._mockDataFn.hasEntries();
        }
        return _super.prototype.hasEntries.call(this);
    };
    /**
     *
     */
    FunctionBasedMockData.prototype.getEmptyObject = function () {
        var _a;
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.getEmptyObject) {
            return this._mockDataFn.getEmptyObject();
        }
        else {
            return _super.prototype.getEmptyObject.call(this);
        }
    };
    /**
     *
     */
    FunctionBasedMockData.prototype.getDefaultElement = function () {
        var _a;
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.getDefaultElement) {
            return this._mockDataFn.getDefaultElement();
        }
        else {
            return _super.prototype.getDefaultElement.call(this);
        }
    };
    /**
     * @param property
     * @param lineIndex
     */
    FunctionBasedMockData.prototype.generateKey = function (property, lineIndex) {
        var _a;
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.generateKey) {
            return this._mockDataFn.generateKey(property);
        }
        else {
            return _super.prototype.generateKey.call(this, property, lineIndex);
        }
    };
    /**
     *
     */
    FunctionBasedMockData.prototype.getAllEntries = function (dontClone) {
        var _a;
        if (dontClone === void 0) { dontClone = false; }
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.getAllEntries) {
            return this._mockDataFn.getAllEntries(dontClone);
        }
        else {
            return _super.prototype.getAllEntries.call(this, dontClone);
        }
    };
    /**
     * @param actionDefinition
     * @param actionData
     * @param keys
     */
    FunctionBasedMockData.prototype.onBeforeAction = function (actionDefinition, actionData, keys) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.onBeforeAction) {
                    return [2 /*return*/, this._mockDataFn.onBeforeAction(actionDefinition, actionData, keys)];
                }
                else {
                    return [2 /*return*/, _super.prototype.onBeforeAction.call(this, actionDefinition, actionData, keys)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param actionDefinition
     * @param actionData
     * @param keys
     */
    FunctionBasedMockData.prototype.executeAction = function (actionDefinition, actionData, keys) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.executeAction) {
                    return [2 /*return*/, this._mockDataFn.executeAction(actionDefinition, actionData, keys)];
                }
                else {
                    return [2 /*return*/, _super.prototype.executeAction.call(this, actionDefinition, actionData, keys)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param actionDefinition
     * @param actionData
     * @param keys
     * @param responseData
     */
    FunctionBasedMockData.prototype.onAfterAction = function (actionDefinition, actionData, keys, responseData) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.onAfterAction) {
                    return [2 /*return*/, this._mockDataFn.onAfterAction(actionDefinition, actionData, keys, responseData)];
                }
                else {
                    return [2 /*return*/, _super.prototype.onAfterAction.call(this, actionDefinition, actionData, keys, responseData)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param keyValues
     * @param updatedData
     */
    FunctionBasedMockData.prototype.onAfterUpdateEntry = function (keyValues, updatedData) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.onAfterUpdateEntry) {
                    return [2 /*return*/, this._mockDataFn.onAfterUpdateEntry(keyValues, updatedData)];
                }
                else {
                    return [2 /*return*/, _super.prototype.onAfterUpdateEntry.call(this, keyValues, updatedData)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param keyValues
     * @param updatedData
     */
    FunctionBasedMockData.prototype.onBeforeUpdateEntry = function (keyValues, updatedData) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.onBeforeUpdateEntry) {
                    return [2 /*return*/, this._mockDataFn.onBeforeUpdateEntry(keyValues, updatedData)];
                }
                else {
                    return [2 /*return*/, _super.prototype.onBeforeUpdateEntry.call(this, keyValues, updatedData)];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param customAggregateName
     */
    FunctionBasedMockData.prototype.hasCustomAggregate = function (customAggregateName) {
        var _a;
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.hasCustomAggregate) {
            return this._mockDataFn.hasCustomAggregate(customAggregateName);
        }
        else {
            return _super.prototype.hasCustomAggregate.call(this, customAggregateName);
        }
    };
    /**
     * @param customAggregateName
     * @param dataToAggregate
     */
    FunctionBasedMockData.prototype.performCustomAggregate = function (customAggregateName, dataToAggregate) {
        var _a;
        if ((_a = this._mockDataFn) === null || _a === void 0 ? void 0 : _a.performCustomAggregate) {
            return this._mockDataFn.performCustomAggregate(customAggregateName, dataToAggregate);
        }
        else {
            return _super.prototype.performCustomAggregate.call(this, customAggregateName, dataToAggregate);
        }
    };
    return FunctionBasedMockData;
}(fileBasedMockData_1.FileBasedMockData));
exports.FunctionBasedMockData = FunctionBasedMockData;


/***/ }),

/***/ 1016:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidv4 = exports.generateId = void 0;
var CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
/**
 * @param length
 */
function generateId(length) {
    var result = '';
    while (length--) {
        result += CHARS.charAt(Math.floor(Math.random() * CHARS.length));
    }
    return result;
}
exports.generateId = generateId;
/**
 *
 */
function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
exports.uuidv4 = uuidv4;


/***/ }),

/***/ 5273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ODataMetadata = void 0;
var edmx_parser_1 = __webpack_require__(1014);
var annotation_converter_1 = __webpack_require__(4350);
/**
 *
 */
var ODataMetadata = /** @class */ (function () {
    /**
     * @param metadata
     * @param parserMetadata
     */
    function ODataMetadata(metadata, parserMetadata) {
        this.typeToEntityMapping = {};
        this.metadata = metadata;
        this.parserMetadata = parserMetadata;
    }
    /**
     * @param edmx
     */
    ODataMetadata.parse = function (edmx) {
        return __awaiter(this, void 0, void 0, function () {
            var metadata, converterMetadata;
            return __generator(this, function (_a) {
                metadata = edmx_parser_1.parseEDMX(edmx);
                converterMetadata = annotation_converter_1.convertTypes(metadata);
                return [2 /*return*/, new ODataMetadata(converterMetadata, metadata)];
            });
        });
    };
    /**
     *
     */
    ODataMetadata.prototype.getVersion = function () {
        return this.metadata.version === '1.0' ? '2.0' : '4.0';
    };
    /**
     * @param entitySetName
     */
    ODataMetadata.prototype.getEntitySet = function (entitySetName) {
        return this.metadata.entitySets.find(function (entitySet) { return entitySet.name === entitySetName; });
    };
    /**
     *
     */
    ODataMetadata.prototype.getEntitySets = function () {
        return this.metadata.entitySets;
    };
    /**
     * @param entityTypeName
     */
    ODataMetadata.prototype.getEntityType = function (entityTypeName) {
        return this.metadata.entityTypes.find(function (entityType) { return entityType.name === entityTypeName; });
    };
    /**
     * @param entityTypeName
     */
    ODataMetadata.prototype.getEntitySetByType = function (entityTypeName) {
        return this.metadata.entitySets.find(function (entitySet) { return entitySet.entityTypeName === entityTypeName; });
    };
    /**
     * @param actionFQN
     */
    ODataMetadata.prototype.getActionByFQN = function (actionFQN) {
        return this.metadata.actions.find(function (action) { return action.fullyQualifiedName === actionFQN; });
    };
    /**
     *
     */
    ODataMetadata.prototype.getEntityContainerPath = function () {
        return this.parserMetadata.schema.entityContainer.fullyQualifiedName;
    };
    /**
     * @param entitySet
     */
    ODataMetadata.prototype.isDraftEntity = function (entitySet) {
        var _a, _b, _c, _d;
        return (((_b = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftRoot) !== undefined ||
            ((_d = (_c = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _c === void 0 ? void 0 : _c.Common) === null || _d === void 0 ? void 0 : _d.DraftNode) !== undefined);
    };
    /**
     * @param entitySet
     */
    ODataMetadata.prototype.isStickyEntity = function (entitySet) {
        var _a, _b;
        return ((_b = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _a === void 0 ? void 0 : _a.Session) === null || _b === void 0 ? void 0 : _b.StickySessionSupported) !== undefined;
    };
    ODataMetadata.prototype.isDraftRoot = function (entitySet) {
        var _a, _b;
        return ((_b = (_a = entitySet === null || entitySet === void 0 ? void 0 : entitySet.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.DraftRoot) !== undefined;
    };
    ODataMetadata.prototype.resolvePath = function (path) {
        return this.metadata.resolvePath(path);
    };
    ODataMetadata.prototype.findInDescendant = function (entitySet, targetEntitySet, path) {
        var _this = this;
        // Check if we are a descendent
        var found = false;
        Object.keys(entitySet.navigationPropertyBinding).forEach(function (navName) {
            var subET = entitySet.navigationPropertyBinding[navName];
            var navInvolved = entitySet.entityType.navigationProperties.find(function (nav) { return nav.name === navName; });
            var partnerNav;
            if (navInvolved.partner) {
                partnerNav = navInvolved.targetType.navigationProperties.find(function (nav) { return nav.name === navInvolved.partner; });
            }
            if (subET === targetEntitySet) {
                found = true;
                path.push({
                    name: navName,
                    entitySet: subET,
                    navigation: navInvolved,
                    partner: partnerNav
                });
            }
        });
        if (!found) {
            // Look into children
            Object.keys(entitySet.navigationPropertyBinding).forEach(function (navName) {
                var subET = entitySet.navigationPropertyBinding[navName];
                var navInvolved = entitySet.entityType.navigationProperties.find(function (nav) { return nav.name === navName; });
                var partnerNav;
                if (navInvolved.partner) {
                    partnerNav = navInvolved.targetType.navigationProperties.find(function (nav) { return nav.name === navInvolved.partner; });
                }
                var subPath = path.concat([
                    {
                        name: navName,
                        entitySet: subET,
                        navigation: navInvolved,
                        partner: partnerNav
                    }
                ]);
                if (_this.findInDescendant(subET, targetEntitySet, subPath)) {
                    // found it in descendent
                    found = true;
                    subPath.slice(path.length).forEach(function (subPathPart) {
                        path.push(subPathPart);
                    });
                }
            });
        }
        return found;
    };
    ODataMetadata.prototype.resolveDraftRoot = function (entitySet) {
        var _this = this;
        var found = false;
        var foundPath;
        var rootEntitySet;
        this.metadata.entitySets.find(function (et) {
            if (_this.isDraftRoot(et) && !found) {
                var resolvePath = [];
                found = _this.findInDescendant(et, entitySet, resolvePath);
                if (found) {
                    foundPath = resolvePath.concat();
                    rootEntitySet = et;
                }
            }
        });
        return {
            found: found,
            entitySet: rootEntitySet,
            path: foundPath
        };
    };
    ODataMetadata.prototype.resolveAncestors = function (entitySet) {
        var _this = this;
        var found = false;
        var foundPath;
        var rootEntitySet;
        this.metadata.entitySets.find(function (et) {
            if (!found) {
                var resolvePath = [];
                found = _this.findInDescendant(et, entitySet, resolvePath);
                if (found) {
                    foundPath = resolvePath.concat();
                    rootEntitySet = et;
                }
            }
        });
        return {
            found: found,
            entitySet: rootEntitySet,
            path: foundPath
        };
    };
    ODataMetadata.prototype.getParentEntitySetName = function (sourceEntitySet) {
        var _a = this.resolveAncestors(sourceEntitySet), found = _a.found, path = _a.path, entitySet = _a.entitySet;
        if (found) {
            if (path.length === 1) {
                return entitySet.name;
            }
            else {
                return path[path.length - 1].entitySet.name;
            }
        }
    };
    return ODataMetadata;
}());
exports.ODataMetadata = ODataMetadata;


/***/ }),

/***/ 1308:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockEntityContainer = void 0;
var path_1 = __webpack_require__(1017);
var fileLoader_1 = __webpack_require__(5352);
var common_1 = __webpack_require__(5650);
/**
 *
 */
var MockEntityContainer = /** @class */ (function () {
    function MockEntityContainer() {
    }
    /**
     * @param mockDataRootFolder
     * @returns Promise<MockEntityContainerContributer>
     */
    MockEntityContainer.read = function (mockDataRootFolder) {
        return __awaiter(this, void 0, void 0, function () {
            var jsPath, outData, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        jsPath = path_1.join(mockDataRootFolder, 'EntityContainer') + '.js';
                        return [4 /*yield*/, fileLoader_1.exists(jsPath)];
                    case 1:
                        if (!_a.sent()) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, fileLoader_1.loadJS(jsPath)];
                    case 3:
                        //eslint-disable-next-line
                        outData = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        outData = {};
                        console.error(e_1);
                        return [3 /*break*/, 5];
                    case 5:
                        if (!outData) {
                            outData = {
                                executeAction: function (actionDefinition, actionData, keys) {
                                    return __awaiter(this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            this.throwError('Unsupported Action', 501, {
                                                error: {
                                                    message: "FunctionImport or Action \"" + actionDefinition.name + "\" not mocked"
                                                }
                                            });
                                            return [2 /*return*/, []];
                                        });
                                    });
                                }
                            };
                        }
                        outData.throwError = function (message, statusCode, messageData, isSAPMessage) {
                            if (statusCode === void 0) { statusCode = 500; }
                            if (isSAPMessage === void 0) { isSAPMessage = false; }
                            var executionError = new common_1.ExecutionError(message, statusCode, messageData, isSAPMessage);
                            throw executionError;
                        };
                        return [2 /*return*/, outData];
                }
            });
        });
    };
    return MockEntityContainer;
}());
exports.MockEntityContainer = MockEntityContainer;


/***/ }),

/***/ 3968:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StickyMockEntitySet = void 0;
var entitySet_1 = __webpack_require__(4763);
var lodash_clonedeep_1 = __importDefault(__webpack_require__(9548));
var id_1 = __webpack_require__(1016);
/**
 *
 */
var StickyMockEntitySet = /** @class */ (function (_super) {
    __extends(StickyMockEntitySet, _super);
    /**
     * @param rootFolder
     * @param entitySetDefinition
     * @param dataAccess
     * @param generateMockData
     */
    function StickyMockEntitySet(rootFolder, entitySetDefinition, dataAccess, generateMockData) {
        var _this = _super.call(this, rootFolder, entitySetDefinition, dataAccess, generateMockData) || this;
        _this._currentSessionObject = {};
        _this.sessionTimeoutTime = 120;
        return _this;
    }
    /**
     * @param tenantId
     */
    StickyMockEntitySet.prototype.getSessionObject = function (tenantId) {
        return this._currentSessionObject[tenantId];
    };
    /**
     * @param tenantId
     * @param objectData
     */
    StickyMockEntitySet.prototype.setSessionObject = function (tenantId, objectData) {
        this._currentSessionObject[tenantId] = objectData;
    };
    /**
     * @param tenantId
     */
    StickyMockEntitySet.prototype.resetSessionTimeout = function (tenantId) {
        var _this = this;
        clearTimeout(this.sessionTimeoutRef);
        this.sessionTimeoutRef = setTimeout(function () {
            _this.currentUUID = null;
            _this.setSessionObject(tenantId, null);
        }, this.sessionTimeoutTime * 1000);
        return this.currentUUID;
    };
    /**
     * @param keyValues
     * @param patchData
     * @param tenantId
     */
    StickyMockEntitySet.prototype.performPATCH = function (keyValues, patchData, tenantId) {
        return __awaiter(this, void 0, void 0, function () {
            var data, currentMockData, updatedData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyValues = this.prepareKeys(keyValues);
                        data = this.performGET(keyValues, false, tenantId);
                        currentMockData = this.getMockData(tenantId);
                        updatedData = Object.assign(data, patchData);
                        return [4 /*yield*/, currentMockData.onBeforeUpdateEntry(keyValues, updatedData)];
                    case 1:
                        _a.sent();
                        if (!updatedData.__transient) return [3 /*break*/, 2];
                        this.setSessionObject(tenantId, updatedData);
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, currentMockData.updateEntry(keyValues, updatedData)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [4 /*yield*/, currentMockData.onAfterUpdateEntry(keyValues, updatedData)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/, updatedData];
                }
            });
        });
    };
    /**
     * @param actionDefinition
     * @param actionData
     * @param odataRequest
     * @param keys
     */
    StickyMockEntitySet.prototype.executeAction = function (actionDefinition, actionData, odataRequest, keys) {
        return __awaiter(this, void 0, void 0, function () {
            var currentMockData, responseObject, _a, data, duplicate, newObject_1, nonNullableProperties, uuid, newData;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        currentMockData = this.getMockData(odataRequest.tenantId);
                        keys = this.prepareKeys(keys);
                        return [4 /*yield*/, currentMockData.onBeforeAction(actionDefinition, actionData, keys)];
                    case 1:
                        actionData = _b.sent();
                        _a = actionDefinition.fullyQualifiedName;
                        switch (_a) {
                            case this.entitySetDefinition.annotations.Session.StickySessionSupported.EditAction + "(" + actionDefinition.sourceType + ")": return [3 /*break*/, 2];
                            case this.entitySetDefinition.annotations.Session.StickySessionSupported.NewAction + "(" + actionDefinition.sourceType + ")": return [3 /*break*/, 3];
                            case this.entitySetDefinition.annotations.Session.StickySessionSupported.DiscardAction + "(" + actionDefinition.sourceType + ")": return [3 /*break*/, 4];
                            case this.entitySetDefinition.annotations.Session.StickySessionSupported.SaveAction + "(" + actionDefinition.sourceType + ")": return [3 /*break*/, 5];
                        }
                        return [3 /*break*/, 9];
                    case 2:
                        {
                            data = this.performGET(keys, false, odataRequest.tenantId);
                            duplicate = Object.assign({}, data);
                            this.setSessionObject(odataRequest.tenantId, duplicate);
                            duplicate.__transient = true;
                            duplicate.__keys = keys;
                            responseObject = duplicate;
                            return [3 /*break*/, 9];
                        }
                        _b.label = 3;
                    case 3:
                        {
                            newObject_1 = Object.assign({}, actionData);
                            nonNullableProperties = actionDefinition.returnEntityType.entityProperties.filter(function (prop) { return prop.nullable === false; });
                            nonNullableProperties.forEach(function (nonNullableProperty) {
                                if (newObject_1[nonNullableProperty.name] === undefined) {
                                    if (Object.prototype.hasOwnProperty.call(nonNullableProperty, 'defaultValue')) {
                                        newObject_1[nonNullableProperty.name] = nonNullableProperty.defaultValue;
                                    }
                                    else {
                                        switch (nonNullableProperty.type) {
                                            case 'Edm.String':
                                                newObject_1[nonNullableProperty.name] = '';
                                                break;
                                            case 'Edm.Guid':
                                                newObject_1[nonNullableProperty.name] = '';
                                                break;
                                        }
                                    }
                                }
                            });
                            this.setSessionObject(odataRequest.tenantId, newObject_1);
                            newObject_1.__transient = true;
                            odataRequest.context = "../$metadata#" + this.entitySetDefinition.name + "()/$entity";
                            uuid = id_1.generateId(16);
                            this.currentUUID = uuid;
                            odataRequest.setResponseHeader('sap-contextid', 'SID:ANON:localMock' + uuid);
                            odataRequest.setResponseHeader('sap-http-session-timeout', this.sessionTimeoutTime);
                            this.resetSessionTimeout(odataRequest.tenantId);
                            responseObject = newObject_1;
                            return [3 /*break*/, 9];
                        }
                        _b.label = 4;
                    case 4:
                        // Discard
                        this.setSessionObject(odataRequest.tenantId, null);
                        responseObject = null;
                        return [3 /*break*/, 9];
                    case 5:
                        newData = this.getSessionObject(odataRequest.tenantId);
                        if (!newData.__keys) return [3 /*break*/, 6];
                        // Key needs to be filled now
                        currentMockData.updateEntry(newData.__keys, newData);
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, this.performPOST({}, newData, odataRequest.tenantId)];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8:
                        this.setSessionObject(odataRequest.tenantId, null);
                        responseObject = newData;
                        return [3 /*break*/, 9];
                    case 9: return [4 /*yield*/, currentMockData.onAfterAction(actionDefinition, actionData, keys, responseObject)];
                    case 10:
                        responseObject = _b.sent();
                        return [2 /*return*/, responseObject];
                }
            });
        });
    };
    /**
     * @param keyValues
     * @param asArray
     * @param tenantId
     * @param dontClone
     */
    StickyMockEntitySet.prototype.performGET = function (keyValues, asArray, tenantId, dontClone) {
        if (dontClone === void 0) { dontClone = false; }
        var currentSessionObject = this.getSessionObject(tenantId);
        if (currentSessionObject && keyValues && Object.keys(keyValues).length) {
            if ((Object.prototype.hasOwnProperty.call(keyValues, "''") && keyValues["''"] === undefined) ||
                this.checkKeys(keyValues, currentSessionObject, this.entityTypeDefinition.keys)) {
                // odataRequest.setResponseHeader('sap-contextid', this.currentUUID);
                // odataRequest.setResponseHeader('sap-http-session-timeout', this.sessionTimeoutTime.toString());
                this.resetSessionTimeout(tenantId);
                return lodash_clonedeep_1.default(currentSessionObject);
            }
        }
        return _super.prototype.performGET.call(this, keyValues, asArray, tenantId);
    };
    return StickyMockEntitySet;
}(entitySet_1.MockDataEntitySet));
exports.StickyMockEntitySet = StickyMockEntitySet;


/***/ }),

/***/ 6822:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oDataHandler = void 0;
var router_1 = __importDefault(__webpack_require__(1071));
var logger_1 = __webpack_require__(2787);
var batch_1 = __webpack_require__(710);
var simpleHttpResponse_1 = __webpack_require__(7158);
var odataV2Request_1 = __webpack_require__(4493);
var metadata_1 = __webpack_require__(5273);
var dataAccess_1 = __webpack_require__(7235);
var odataV4Request_1 = __webpack_require__(5205);
var odataRequest_1 = __webpack_require__(8506);
var fileLoader_1 = __webpack_require__(5352);
var simpleHttpRequest_1 = __webpack_require__(285);
var etag_1 = __importDefault(__webpack_require__(8046));
/**
 * @param service
 */
function oDataHandler(service) {
    return __awaiter(this, void 0, void 0, function () {
        var router, log, edmx, cdsContent, stringToCds, metadata, dataAccess, watchPath, chokidar;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    router = router_1.default();
                    log = logger_1.getLogger('server:ux-fe-mockserver');
                    if (!service.metadataCdsPath) return [3 /*break*/, 4];
                    return [4 /*yield*/, fileLoader_1.loadFile(service.metadataCdsPath)];
                case 1:
                    cdsContent = _a.sent();
                    return [4 /*yield*/, Promise.resolve().then(function () { return __importStar(__webpack_require__(4087)); })];
                case 2:
                    stringToCds = _a.sent();
                    return [4 /*yield*/, stringToCds.compileCDS(cdsContent, service.cdsServiceName)];
                case 3:
                    edmx = _a.sent();
                    return [3 /*break*/, 6];
                case 4: return [4 /*yield*/, fileLoader_1.loadFile(service.metadataXmlPath)];
                case 5:
                    edmx = _a.sent();
                    _a.label = 6;
                case 6: return [4 /*yield*/, metadata_1.ODataMetadata.parse(edmx)];
                case 7:
                    metadata = _a.sent();
                    dataAccess = new dataAccess_1.DataAccess(service.mockdataRootPath, metadata, !!service.strictKeyMode, !!service.contextBasedIsolation, !!service.generateMockData, !!service.debug);
                    if (!(service.watch && !fileLoader_1.isInBrowser())) return [3 /*break*/, 9];
                    watchPath = [service.mockdataRootPath];
                    if (service.metadataXmlPath) {
                        watchPath.push(service.metadataXmlPath);
                    }
                    if (service.metadataCdsPath) {
                        watchPath.push(service.metadataCdsPath);
                    }
                    return [4 /*yield*/, Promise.resolve().then(function () { return __importStar(__webpack_require__(2408)); })];
                case 8:
                    chokidar = _a.sent();
                    chokidar
                        .watch(watchPath, {
                        ignoreInitial: true
                    })
                        .on('all', function (event, path) {
                        return __awaiter(this, void 0, void 0, function () {
                            var cdsContent, stringToCds;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        log.info("Change detected for service " + service.urlPath + "... restarting");
                                        if (service.debug) {
                                            log.info(event + " on " + path);
                                        }
                                        if (!service.metadataCdsPath) return [3 /*break*/, 3];
                                        return [4 /*yield*/, fileLoader_1.loadFile(service.metadataCdsPath)];
                                    case 1:
                                        cdsContent = _a.sent();
                                        return [4 /*yield*/, Promise.resolve().then(function () { return __importStar(__webpack_require__(4087)); })];
                                    case 2:
                                        stringToCds = _a.sent();
                                        edmx = stringToCds.compileCDS(cdsContent, service.cdsServiceName);
                                        return [3 /*break*/, 5];
                                    case 3: return [4 /*yield*/, fileLoader_1.loadFile(service.metadataXmlPath)];
                                    case 4:
                                        edmx = _a.sent();
                                        _a.label = 5;
                                    case 5: return [4 /*yield*/, metadata_1.ODataMetadata.parse(edmx)];
                                    case 6:
                                        metadata = _a.sent();
                                        dataAccess.reloadData(metadata);
                                        log.info("Service " + service.urlPath + " restarted");
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                    _a.label = 9;
                case 9:
                    router.post('/\\$metadata/reload', function (req, res) {
                        dataAccess.reloadData(metadata);
                        res.setHeader('Content-Type', 'application/json');
                        res.write(JSON.stringify({ message: 'Reload success' }));
                        res.end();
                    });
                    router.get('/\\$metadata', function (req, res) {
                        res.setHeader('Content-Type', 'application/xml');
                        if (!fileLoader_1.isInBrowser() && !service.noETag) {
                            res.setHeader('ETag', etag_1.default(edmx, { weak: true }));
                        }
                        res.write(edmx);
                        res.end();
                    });
                    router.use('/\\$batch', batch_1.batchRequestHandler(metadata, dataAccess, service));
                    router.get('/', function (req, res) {
                        var data = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <app:service xml:lang=\"en\" xml:base=\"" + service.urlPath + "/\"\n            xmlns:app=\"http://www.w3.org/2007/app\"\n            xmlns:atom=\"http://www.w3.org/2005/Atom\"\n            xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\"\n            xmlns:sap=\"http://www.sap.com/Protocols/SAPData\">\n            <app:workspace>\n            </app:workspace>\n            <atom:link rel=\"self\" href=\"" + service.urlPath + "/\"/>\n            <atom:link rel=\"latest-version\" href=\"" + service.urlPath + "/\"/>\n        </app:service>";
                        res.setHeader('Content-Type', 'application/xml');
                        res.write(data);
                        res.end();
                    });
                    router.head('/*', function (req, res) {
                        var tenantId = req.originalUrl.indexOf('/tenant-') === 0 ? req.originalUrl.split('/')[1] : 'tenant-default';
                        res.setHeader('sap-tenantId', tenantId);
                        var contextId = req.header('sap-contextid');
                        if (contextId) {
                            dataAccess.resetStickySessionTimeout(res, tenantId);
                        }
                    });
                    router.get('/*', function (req, res, next) { return __awaiter(_this, void 0, void 0, function () {
                        var odataReq, actionResponse, response, data, e_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 5, , 6]);
                                    odataReq = metadata.getVersion() === '2.0'
                                        ? new odataV2Request_1.ODataV2Request(req.baseUrl, req.url.substring(1), metadata)
                                        : new odataV4Request_1.ODataV4Request(req.baseUrl, req.url.substring(1), metadata);
                                    res.setHeader('sap-tenantId', odataReq.tenantId);
                                    res.setHeader('Content-Type', 'application/json');
                                    return [4 /*yield*/, dataAccess.performAction(odataReq)];
                                case 1:
                                    actionResponse = _a.sent();
                                    response = void 0;
                                    if (!(actionResponse === null)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, dataAccess.getData(odataReq)];
                                case 2:
                                    data = _a.sent();
                                    response = odataReq.createResponse(data);
                                    return [3 /*break*/, 4];
                                case 3:
                                    response = odataReq.createResponse(actionResponse);
                                    _a.label = 4;
                                case 4:
                                    response.writeToResponse(res);
                                    return [3 /*break*/, 6];
                                case 5:
                                    e_1 = _a.sent();
                                    next(odataRequest_1.ODataRequest.createErrorResponse(e_1));
                                    return [3 /*break*/, 6];
                                case 6: return [2 /*return*/];
                            }
                        });
                    }); });
                    router.post('/*', function (req, res, next) { return __awaiter(_this, void 0, void 0, function () {
                        var odataReq_1, request;
                        var _this = this;
                        return __generator(this, function (_a) {
                            try {
                                odataReq_1 = metadata.getVersion() === '2.0'
                                    ? new odataV2Request_1.ODataV2Request(req.baseUrl, req.url.substring(1), metadata)
                                    : new odataV4Request_1.ODataV4Request(req.baseUrl, req.url.substring(1), metadata);
                                res.setHeader('sap-tenantId', odataReq_1.tenantId);
                                res.setHeader('Content-Type', 'application/json');
                                request = simpleHttpRequest_1.createRequest(req, '/');
                                request.getBodyAsString(function (body) { return __awaiter(_this, void 0, void 0, function () {
                                    var postData, actionResponse, response, createdData;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                postData = body ? JSON.parse(body) : {};
                                                return [4 /*yield*/, dataAccess.performAction(odataReq_1, postData)];
                                            case 1:
                                                actionResponse = _a.sent();
                                                if (!(actionResponse === null)) return [3 /*break*/, 3];
                                                return [4 /*yield*/, dataAccess.createData(odataReq_1, postData)];
                                            case 2:
                                                createdData = _a.sent();
                                                response = odataReq_1.createResponse(createdData, true, createdData);
                                                return [3 /*break*/, 4];
                                            case 3:
                                                response = odataReq_1.createResponse(actionResponse);
                                                _a.label = 4;
                                            case 4:
                                                response.writeToResponse(res);
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                            }
                            catch (e) {
                                next(odataRequest_1.ODataRequest.createErrorResponse(e));
                            }
                            return [2 /*return*/];
                        });
                    }); });
                    router.patch('/*', function (req, res, next) { return __awaiter(_this, void 0, void 0, function () {
                        var odataReq_2, request;
                        var _this = this;
                        return __generator(this, function (_a) {
                            try {
                                odataReq_2 = metadata.getVersion() === '2.0'
                                    ? new odataV2Request_1.ODataV2Request(req.baseUrl, req.url.substring(1), metadata)
                                    : new odataV4Request_1.ODataV4Request(req.baseUrl, req.url.substring(1), metadata);
                                res.setHeader('sap-tenantId', odataReq_2.tenantId);
                                res.setHeader('Content-Type', 'application/json');
                                request = simpleHttpRequest_1.createRequest(req, '/');
                                request.getBodyAsString(function (body) { return __awaiter(_this, void 0, void 0, function () {
                                    var data, response, e_2;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                return [4 /*yield*/, dataAccess.updateData(odataReq_2, JSON.parse(body))];
                                            case 1:
                                                data = _a.sent();
                                                response = odataReq_2.createResponse(data);
                                                response.writeToResponse(res);
                                                return [3 /*break*/, 3];
                                            case 2:
                                                e_2 = _a.sent();
                                                next(odataRequest_1.ODataRequest.createErrorResponse(e_2));
                                                return [3 /*break*/, 3];
                                            case 3: return [2 /*return*/];
                                        }
                                    });
                                }); });
                            }
                            catch (e) {
                                next(odataRequest_1.ODataRequest.createErrorResponse(e));
                            }
                            return [2 /*return*/];
                        });
                    }); });
                    router.use('*', function (err, req, res, next) {
                        if (res.headersSent) {
                            return next(err);
                        }
                        if (err instanceof simpleHttpResponse_1.SimpleResponse) {
                            err.writeToResponse(res);
                        }
                        else {
                            return next(err);
                        }
                    });
                    return [2 /*return*/, router];
            }
        });
    });
}
exports.oDataHandler = oDataHandler;


/***/ }),

/***/ 5144:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseFilter = exports.FilterParser = exports.FilterLexer = void 0;
var chevrotain_1 = __webpack_require__(8154);
// ----------------- Lexer -----------------
var OPEN = chevrotain_1.createToken({ name: 'OPEN', pattern: /(:?\(|%28)/ });
var CLOSE = chevrotain_1.createToken({ name: 'CLOSE', pattern: /(:?\)|%29)/ });
var COMMA = chevrotain_1.createToken({ name: 'COMMA', pattern: /(:?,|%2C)/ });
var SLASH = chevrotain_1.createToken({ name: 'SLASH', pattern: /\// });
var ANYALL = chevrotain_1.createToken({ name: 'COMMA', pattern: /(:?any|all)/ });
var COLON = chevrotain_1.createToken({ name: 'COLON', pattern: /(:?:|%3A)/ });
var SIMPLEIDENTIFIER = chevrotain_1.createToken({ name: 'SimpleIdentifier', pattern: /[a-zA-Z0-9_]{1,128}/ });
var SIMPLE_METHOD = chevrotain_1.createToken({
    name: 'SIMPLE_METHOD',
    pattern: /(:?length|tolower|toupper|trim|round|floor|ceiling)/
});
var COMPLEX_METHOD = chevrotain_1.createToken({
    name: 'COMPLEX_METHOD',
    pattern: /(:?concat|contains|endswith|indexof|matchesPattern|startswith|substring|cast)/
});
var BOOL_METHOD = chevrotain_1.createToken({
    name: 'BOOL_METHOD',
    pattern: /(:?contains|endswith|startswith)/
});
var TYPEDEF = chevrotain_1.createToken({ name: 'Typedef', pattern: /Edm\.[a-zA-Z]+/ });
// null, boolean, guid, dateTimeInOffset / dateValue / timeOfDay / decimalValue / doubleValue / singleValue / string / duration / enum / binary
var LITERAL = chevrotain_1.createToken({
    name: 'Literal',
    pattern: /(:?null|true|false|[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}|guid(:?'|%27)[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(:?'|%27)|datetime'[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}'|[0-9]{4}-[0-9]{2}-[0-9]{2}|-?(:?0|[1-9]\d*)(\.\d+)?(:?[eE][+-]?\d+)?|'[^\\"\n\r\']*')/
});
//ee1a9172-f3c3-47ce-b0f7-dd28c740210c
var LOGICAL_OPERATOR = chevrotain_1.createToken({ name: 'Logical', pattern: /(:?eq|ne|lt|le|gt|ge)/ });
var ANDOR = chevrotain_1.createToken({ name: 'AndOr', pattern: /(:?and|or)/ });
var WS = chevrotain_1.createToken({ name: 'Whitespace', pattern: /\s+/ });
var filterTokens = [
    OPEN,
    CLOSE,
    COMMA,
    COLON,
    SLASH,
    ANYALL,
    ANDOR,
    WS,
    SIMPLE_METHOD,
    BOOL_METHOD,
    COMPLEX_METHOD,
    LOGICAL_OPERATOR,
    TYPEDEF,
    LITERAL,
    SIMPLEIDENTIFIER
];
exports.FilterLexer = new chevrotain_1.Lexer(filterTokens, {
    // Less position info tracked, reduces verbosity of the playground output.
    positionTracking: 'onlyStart'
});
/**
 *
 */
var FilterParser = /** @class */ (function (_super) {
    __extends(FilterParser, _super);
    function FilterParser() {
        var _this = _super.call(this, filterTokens, {
            recoveryEnabled: true
        }) || this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var $ = _this;
        $.filterExpr = $.RULE('filterExpr', function () {
            var expression = $.SUBRULE($.boolCommonExpr);
            return expression;
        });
        $.literalOrIdentifier = $.RULE('literalOrIdentifier', function () {
            var result = $.OR([
                {
                    ALT: function () { return $.CONSUME(TYPEDEF); }
                },
                {
                    ALT: function () { return $.CONSUME(LITERAL); }
                },
                {
                    ALT: function () { return $.SUBRULE($.memberExpr); }
                }
            ]);
            return result;
        });
        $.boolMethodCallExpr = $.RULE('boolMethodCallExpr', function () {
            var methodNode = $.CONSUME(BOOL_METHOD);
            $.OPTION(function () { return $.CONSUME(WS); });
            $.CONSUME2(OPEN);
            $.OPTION2(function () { return $.CONSUME2(WS); });
            var literal1Node = $.SUBRULE2($.literalOrIdentifier);
            $.OPTION3(function () { return $.CONSUME3(WS); });
            $.CONSUME(COMMA);
            $.OPTION4(function () { return $.CONSUME4(WS); });
            var literal2Node = $.SUBRULE3($.literalOrIdentifier);
            $.OPTION5(function () { return $.CONSUME5(WS); });
            $.CONSUME2(CLOSE);
            var methodArgs = [literal1Node.image ? literal1Node.image : literal1Node];
            if (literal2Node) {
                methodArgs.push(literal2Node.image ? literal2Node.image : literal2Node);
            }
            return {
                method: methodNode.image,
                methodArgs: methodArgs
            };
        });
        $.methodCallExpr = $.RULE('methodCallExpr', function () {
            var methodNode;
            var literal1Node;
            var literal2Node;
            $.OR([
                {
                    ALT: function () {
                        methodNode = $.CONSUME(SIMPLE_METHOD);
                        $.CONSUME(OPEN);
                        literal1Node = $.SUBRULE($.literalOrIdentifier);
                        $.CONSUME(CLOSE);
                    }
                },
                {
                    ALT: function () {
                        methodNode = $.CONSUME(COMPLEX_METHOD);
                        $.OPTION(function () { return $.CONSUME(WS); });
                        $.CONSUME2(OPEN);
                        $.OPTION2(function () { return $.CONSUME2(WS); });
                        literal1Node = $.SUBRULE2($.literalOrIdentifier);
                        $.OPTION3(function () { return $.CONSUME3(WS); });
                        $.CONSUME(COMMA);
                        $.OPTION4(function () { return $.CONSUME4(WS); });
                        literal2Node = $.SUBRULE3($.literalOrIdentifier);
                        $.OPTION5(function () { return $.CONSUME5(WS); });
                        $.CONSUME2(CLOSE);
                    }
                }
            ]);
            var methodArgs = [literal1Node.image ? literal1Node.image : literal1Node];
            if (literal2Node) {
                methodArgs.push(literal2Node.image ? literal2Node.image : literal2Node);
            }
            return {
                method: methodNode.image,
                methodArgs: methodArgs
            };
        });
        $.lambdaOperator = $.RULE('lambdaOperator', function () {
            var anyAll = $.CONSUME(ANYALL);
            $.CONSUME(OPEN);
            var key = $.CONSUME(SIMPLEIDENTIFIER);
            $.CONSUME(COLON);
            var subExpr = $.SUBRULE($.boolCommonExpr);
            $.OPTION(function () {
                $.CONSUME(CLOSE);
            });
            return {
                type: 'lambda',
                operator: anyAll.image.toUpperCase(),
                key: key.image,
                expression: subExpr.expressions && subExpr.expressions[0]
            };
        });
        $.memberExpr = $.RULE('memberExpr', function () {
            var memberDef = '';
            var identifier = $.CONSUME(SIMPLEIDENTIFIER);
            memberDef += identifier.image;
            $.OPTION(function () {
                $.CONSUME(SLASH);
                var outMember = $.OR([
                    {
                        ALT: function () { return $.SUBRULE($.memberExpr); }
                    },
                    {
                        ALT: function () { return $.SUBRULE($.lambdaOperator); }
                    }
                ]);
                if (outMember.expression) {
                    // Lamba
                    outMember.target = memberDef;
                    memberDef = outMember;
                }
                else {
                    memberDef += '/';
                    memberDef += outMember;
                }
            });
            return memberDef;
        });
        $.boolCommonExpr = $.RULE('boolCommonExpr', function (isExprOpenIn) {
            var operator;
            var literal;
            var subExpr = $.OR([
                {
                    ALT: function () {
                        // boolParenExpr
                        $.CONSUME(OPEN);
                        var expression = $.SUBRULE($.boolCommonExpr);
                        $.CONSUME(CLOSE);
                        return {
                            isGroup: true,
                            operator: expression.operator,
                            expressions: expression.expressions
                        };
                    }
                },
                {
                    ALT: function () {
                        return { identifier: $.SUBRULE($.boolMethodCallExpr) };
                    }
                },
                // {
                //   ALT: () => {
                //     return $.SUBRULE($.notExpr);
                //   }
                // }
                {
                    ALT: function () {
                        var expression = {};
                        var identifier = $.OR2([
                            {
                                ALT: function () { return $.SUBRULE($.memberExpr); }
                            },
                            {
                                ALT: function () { return $.SUBRULE($.methodCallExpr); }
                            }
                        ]);
                        $.OPTION(function () {
                            $.CONSUME(WS);
                            operator = $.CONSUME(LOGICAL_OPERATOR);
                            $.CONSUME2(WS);
                            literal = $.OR3([
                                {
                                    ALT: function () { return $.CONSUME(LITERAL); }
                                },
                                {
                                    ALT: function () { return $.SUBRULE2($.methodCallExpr); }
                                }
                            ]);
                            expression.operator = operator.image;
                            expression.literal = literal.image ? literal.image : literal;
                        });
                        expression.identifier = identifier;
                        return expression;
                    }
                }
            ]);
            $.OPTION2(function () {
                $.CONSUME3(WS);
                var operator = $.CONSUME(ANDOR);
                $.CONSUME4(WS);
                var subsubExpr = $.SUBRULE2($.boolCommonExpr);
                var expressions;
                var currentOperator = operator.image.toUpperCase();
                if (!subsubExpr.expressions && subExpr.expressions) {
                    expressions = [subExpr].concat([subsubExpr]);
                }
                else if (currentOperator === subsubExpr.operator ||
                    subsubExpr.operator === '' ||
                    subsubExpr.operator === undefined) {
                    expressions = [subExpr].concat(subsubExpr.expressions);
                }
                else {
                    if (currentOperator === 'AND' && !subsubExpr.isGroup) {
                        //AND has priority
                        expressions = [subExpr].concat(subsubExpr.expressions.shift());
                        var subObject = {
                            expressions: expressions,
                            operator: currentOperator
                        };
                        expressions = [subObject].concat(subsubExpr.expressions);
                        currentOperator = subsubExpr.operator;
                    }
                    else {
                        expressions = [subExpr].concat([subsubExpr]);
                    }
                }
                subExpr = {
                    operator: currentOperator,
                    expressions: expressions
                };
            });
            if (subExpr && Array.isArray(subExpr.expressions)) {
                return subExpr;
            }
            return { expressions: [subExpr] };
        });
        _this.performSelfAnalysis();
        return _this;
    }
    return FilterParser;
}(chevrotain_1.EmbeddedActionsParser));
exports.FilterParser = FilterParser;
/**
 * @param text
 */
function parseFilter(text) {
    var parser = new FilterParser();
    var lexingResult = exports.FilterLexer.tokenize(text);
    // "input" is a setter which will reset the parser's state.
    parser.input = lexingResult.tokens;
    var output = parser.filterExpr();
    if (parser.errors.length > 0) {
        parser.errors.forEach(console.error);
        throw new Error('Parsing errors detected');
    }
    return output;
}
exports.parseFilter = parseFilter;


/***/ }),

/***/ 8506:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ODataRequest = void 0;
var querystring_1 = __webpack_require__(3477);
var simpleHttpResponse_1 = __webpack_require__(7158);
var filterParser_1 = __webpack_require__(5144);
var searchParser_1 = __webpack_require__(3741);
/**
 * Abstract class representing an OData request
 */
var ODataRequest = /** @class */ (function () {
    /**
     * @param baseUrl
     * @param url
     * @param metadata
     */
    function ODataRequest(baseUrl, url, metadata) {
        this.headers = {};
        this.metadata = metadata;
        url = decodeURIComponent(url);
        var _a = url.split('?'), path = _a[0], params = _a[1];
        this.baseUrl = baseUrl;
        this.query = this.parseUrl(path, params ? querystring_1.parse(params) : {});
        this.tenantId = this.baseUrl.indexOf('/tenant-') === 0 ? this.baseUrl.split('/')[1] : 'tenant-default';
    }
    /**
     * @param headerName
     * @param headerValue
     */
    ODataRequest.prototype.setResponseHeader = function (headerName, headerValue) {
        this.headers[headerName] = headerValue;
    };
    /**
     * @param res
     */
    ODataRequest.prototype.applyResponseHeaders = function (res) {
        for (var headerName in this.headers) {
            res.setHeader(headerName, this.headers[headerName]);
        }
        this.headers = {};
    };
    /**
     * @param path
     */
    ODataRequest.prototype.parsePath = function (path) {
        var pathSplit = path.split('/');
        return pathSplit.reduce(function (pathArr, pathPart) {
            var keysStart = pathPart.indexOf('(');
            var keysEnd = pathPart.indexOf(')');
            var entity;
            var keys;
            if (keysStart > -1) {
                entity = pathPart.substring(0, keysStart) + pathPart.substring(keysEnd + 1);
                var keysList = pathPart.substring(keysStart + 1, keysEnd).split(',');
                keys = {};
                keysList.forEach(function (keyValue) {
                    var _a = keyValue.split('='), key = _a[0], value = _a[1];
                    if (value) {
                        keys[key] = value.replace(/^'|'$/g, '');
                    }
                    else {
                        keys[key] = undefined;
                    }
                });
            }
            else {
                entity = pathPart;
            }
            pathArr.push({ path: entity, keys: keys });
            return pathArr;
        }, []);
    };
    /**
     * Version specific parsing of the input url
     *
     * @param path
     * @param params
     */
    ODataRequest.prototype.parseUrl = function (path, params) {
        var query = { properties: {} };
        query.queryPath = this.parsePath(path);
        query.rawParams = params;
        query.searchQuery = params['$search'] ? searchParser_1.parseSearch(params['$search']) : undefined;
        if (params['$select']) {
            var props = params['$select'].split(',');
            props.forEach(function (property) {
                query.properties[property.split('/')[0]] = true;
            });
        }
        else {
            query.properties['*'] = true;
        }
        if (params['$expand']) {
            var expandParameters = this.parseExpand(params['$expand']);
            query.expand = expandParameters.expand;
            query.properties = Object.assign(query.properties, expandParameters.properties || {});
        }
        if (params['$orderby']) {
            var orderByParameters = this.parseOrderBy(params['$orderby']);
            query.orderBy = orderByParameters;
        }
        if (params['$apply']) {
            var applyParameters = this.parseApply(params['$apply']);
            query.aggregateDefinition = applyParameters;
        }
        if (params['$filter']) {
            var filterParams = decodeURIComponent(params['$filter']);
            var thisFilters = filterParser_1.parseFilter(filterParams); //this.parseFilter(filterParams);
            query.filter = thisFilters;
        }
        query.startIndex = params['$skip'] ? parseInt(params['$skip'], 10) : 0;
        query.maxElements = params['$top'] ? parseInt(params['$top'], 10) : Number.POSITIVE_INFINITY;
        query.format = 'json';
        return query;
    };
    /**
     * @param filterParams
     */
    ODataRequest.prototype.parseFilter = function (filterParams) {
        var filterSplit = filterParams.split(' ');
        filterSplit = filterSplit.reduce(function (outSplit, currentValue) {
            if (currentValue.indexOf('tolower') === 0) {
                outSplit.push(currentValue);
            }
            else if (currentValue.indexOf('(') !== -1) {
                var parentSplit = currentValue.split('(');
                parentSplit.forEach(function (subValue) {
                    if (subValue.length === 0) {
                        outSplit.push('(');
                    }
                    else {
                        outSplit.push(subValue);
                    }
                });
            }
            else if (currentValue.indexOf(')') !== -1) {
                var parentSplit = currentValue.split(')');
                parentSplit.forEach(function (subValue) {
                    if (subValue.length === 0) {
                        outSplit.push(')');
                    }
                    else {
                        outSplit.push(subValue);
                    }
                });
            }
            else {
                outSplit.push(currentValue);
            }
            return outSplit;
        }, []);
        var char = filterSplit[0];
        var filterIdx = 0;
        var filters = [];
        var childStack = [];
        var thisFilters = filters;
        filters.operator = 'AND';
        while (filterIdx < filterSplit.length) {
            if (char[0] === '(') {
                var childFilters = [];
                childStack.push(thisFilters);
                thisFilters = childFilters;
                filterIdx++;
                char = filterSplit[filterIdx];
            }
            else if (char[char.length - 1] === ')' && char.indexOf('tolower') !== 0) {
                var parentFilter = childStack.pop();
                parentFilter.push(thisFilters);
                thisFilters = parentFilter;
                filterIdx++;
                char = filterSplit[filterIdx];
            }
            else if (char === 'and') {
                filterIdx++;
                thisFilters.operator = 'AND';
                char = filterSplit[filterIdx];
            }
            else if (char === 'or') {
                var currentFilters = thisFilters;
                thisFilters = [currentFilters];
                thisFilters.operator = 'OR';
                filterIdx++;
                char = filterSplit[filterIdx];
            }
            else {
                var filterProperty = char;
                var filterOperator = filterSplit[++filterIdx];
                var eqValue = filterSplit[++filterIdx];
                thisFilters.push({
                    prop: filterProperty,
                    operator: filterOperator,
                    eqValue: eqValue
                });
                char = filterSplit[++filterIdx];
            }
        }
        return thisFilters;
    };
    /**
     * @param orderByParameters
     */
    ODataRequest.prototype.parseOrderBy = function (orderByParameters) {
        var orderByParams = orderByParameters.split(',');
        var orderByDefinition = [];
        orderByParams.forEach(function (param) {
            var _a = param.split(' '), paramName = _a[0], direction = _a[1];
            orderByDefinition.push({ name: paramName, direction: direction !== undefined ? direction : 'asc' });
        });
        return orderByDefinition;
    };
    /**
     * @param applyParameters
     */
    ODataRequest.prototype.parseApply = function (applyParameters) {
        var filterRegEx = /^filter\(([^)]+)\)\/(.*)$/;
        var filterMatches = applyParameters.match(filterRegEx);
        var groupByText = applyParameters;
        var filterParams;
        if (filterMatches) {
            var filterExpr = filterMatches[1];
            filterParams = filterParser_1.parseFilter(filterExpr);
            groupByText = filterMatches[2];
        }
        var groupByRegEx = /^groupby\(\(([^)]+)\),([^)]+\))\)$/;
        var groupByMatches = groupByText.match(groupByRegEx);
        if (groupByMatches) {
            return {
                filter: filterParams,
                groupBy: groupByMatches[1].split(','),
                aggregates: this.parseAggregateDefinition(groupByMatches[2])
            };
        }
    };
    /**
     * @param aggregationDefinition
     */
    ODataRequest.prototype.parseAggregateDefinition = function (aggregationDefinition) {
        var aggregateRegEx = /^aggregate\(([^)]+)\)$/;
        var aggregateMatches = aggregationDefinition.match(aggregateRegEx);
        if (aggregateMatches) {
            return aggregateMatches[1].split(',').map(function (aggregateMatch) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var _a = aggregateMatch.split(' '), property = _a[0], withOp = _a[1], operator = _a[2], asStr = _a[3], targetName = _a[4];
                return {
                    name: targetName || property,
                    operator: operator,
                    sourceProperty: property
                };
            });
        }
    };
    /**
     * @param entity
     * @param element
     */
    ODataRequest.prototype.enrichElement = function (entity, element) {
        // method can be overwritten by enhancing classes
    };
    // /**
    //  * Select only the properties that the client requested
    //  * @param element element to be modified
    //  */
    // protected selectProperties(element: object, properties: object): void {
    //     if (properties) {
    //         for (const property in element) {
    //             if (!properties[property]) {
    //                 delete element[property];
    //             }
    //         }
    //     }
    // }
    //
    // protected expandProperties(element: object, expand: object): void {
    //     if (expand) {
    //         for (const property in expand) {
    //             const target = this.metadata.getTarget(this.query.entitySet, property);
    //             if (target) {
    //                 const data = this.dataAccess.read(target);
    //
    //                 let keys;
    //                 const keyMap = this.metadata.getTargetPropertyMap(this.query.entitySet, property);
    //                 if (keyMap) {
    //                     keys = {};
    //                     for (const key in keyMap) {
    //                         if (element[key] !== undefined) {
    //                             keys[keyMap[key]] = element[key];
    //                         }
    //                     }
    //                 } else {
    //                     if (this.query.keys) {
    //                         keys = this.query.keys;
    //                     } else {
    //                         keys = {};
    //                         const keyIds = this.metadata.getKeys(this.query.entitySet);
    //                         keyIds.forEach((key) => {
    //                             keys[key] = element[key];
    //                         });
    //                     }
    //                 }
    //
    //                 const subElements = this.selectElements(data, keys);
    //                 for (const subElement of subElements) {
    //                     this.enrichElement(target, subElement);
    //                 }
    //                 element[property] = subElements.length === 1 ? subElements[0] : subElements;
    //             } else {
    //                 element[property] = null;
    //             }
    //         }
    //     }
    // }
    // protected selectElements(elements: object[], keys: object): object[] {
    //     if (!keys) {
    //         return elements;
    //     }
    //     const selected = elements.filter((element: object) => {
    //         for (const key in keys) {
    //             if (!!element[key] && element[key] + '' !== keys[key] + '') {
    //                 return false;
    //             }
    //         }
    //         return true;
    //     });
    //     return selected;
    // }
    /**
     * @param errorInformation
     */
    ODataRequest.createErrorResponse = function (errorInformation) {
        var response = new simpleHttpResponse_1.SimpleResponse();
        response.setHeader('odata-version', '4.0');
        if (errorInformation.isCustomError) {
            if (errorInformation.messageData) {
                response.setHeader('content-type', 'application/json;odata.metadata=minimal;IEEE754Compatible=true');
                if (errorInformation.isSAPMessage) {
                    response.setHeader('sap-messages', JSON.stringify(errorInformation.messageData));
                }
                else {
                    response.write(JSON.stringify(errorInformation.messageData));
                }
            }
            else {
                response.setHeader('content-type', 'text/plain');
                response.write(errorInformation.message);
            }
            if (Object.keys(errorInformation.headers).length > 0) {
                Object.keys(errorInformation.headers).forEach(function (headerName) {
                    response.setHeader(headerName, errorInformation.headers[headerName]);
                });
            }
            response.status(errorInformation.statusCode);
        }
        else {
            response.setHeader('content-type', 'text/plain');
            response.write(errorInformation.message);
            response.status(500);
        }
        return response;
    };
    /**
     * @param data
     * @param bCreated
     * @param key
     */
    ODataRequest.prototype.createResponse = function (data, bCreated, key) {
        if (bCreated === void 0) { bCreated = false; }
        if (key === void 0) { key = undefined; }
        var response = new simpleHttpResponse_1.SimpleResponse();
        if (data !== null) {
            response.write(this.toJSON(data));
            response.status(200);
        }
        else {
            response.status(204);
        }
        return response;
    };
    return ODataRequest;
}());
exports.ODataRequest = ODataRequest;


/***/ }),

/***/ 4493:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ODataV2Request = void 0;
var odataRequest_1 = __webpack_require__(8506);
/**
 *
 */
var ODataV2Request = /** @class */ (function (_super) {
    __extends(ODataV2Request, _super);
    function ODataV2Request() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param expandParameters
     */
    ODataV2Request.prototype.parseExpand = function (expandParameters) {
        var props = expandParameters.split(',');
        return props.reduce(function (reducer, property) {
            reducer.expand[property] = {
                select: { '*': true },
                expand: {}
            };
            reducer.properties[property.split('/')[0]] = true;
            return reducer;
        }, { expand: {}, properties: {} });
    };
    // protected enrichElement(entity: string, element: object): void {
    //     const keyValues: string[] = [];
    //     const keys = this.metadata.getKeys(entity);
    //     keys.forEach((key) => {
    //         keyValues.push(`${key}='${element[key]}'`);
    //     });
    //     const uri = `${this.baseUrl}/${entity}(${keyValues.join(',')})`;
    //     element['__metadata'] = {
    //         id: uri,
    //         uri: uri,
    //         type: this.metadata.getEntitySet(this.query.entitySet).EntityType
    //     };
    // }
    /**
     * @param data
     * @param bCreated
     */
    ODataV2Request.prototype.createResponse = function (data, bCreated) {
        if (bCreated === void 0) { bCreated = false; }
        var response = _super.prototype.createResponse.call(this, data);
        response.setHeader('Content-Type', 'application/json');
        response.setHeader('dataserviceversion', '2.0');
        response.setHeader('sap-metadata-last-modified', 'Tue, 01 Oct 2019 15:02:44 GMT');
        response.setHeader('cache-control', 'no-store, no-cache');
        if (data && data.__metadata && data.__metadata.id) {
            response.setHeader('location', data.__metadata.id);
        }
        return response;
    };
    /**
     * @param data
     */
    ODataV2Request.prototype.toJSON = function (data) {
        if (data.length !== undefined) {
            return JSON.stringify({
                d: {
                    __count: data.length + '',
                    results: data
                }
            });
        }
        else {
            return JSON.stringify({ d: data || {} });
        }
    };
    return ODataV2Request;
}(odataRequest_1.ODataRequest));
exports.ODataV2Request = ODataV2Request;


/***/ }),

/***/ 5205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ODataV4Request = void 0;
var common_1 = __webpack_require__(5650);
var odataRequest_1 = __webpack_require__(8506);
var simpleHttpResponse_1 = __webpack_require__(7158);
var query_string_1 = __webpack_require__(9103);
var balanced_match_1 = __importDefault(__webpack_require__(8342));
/**
 *
 */
var ODataV4Request = /** @class */ (function (_super) {
    __extends(ODataV4Request, _super);
    /**
     * @param baseUrl
     * @param url
     * @param metadata
     */
    function ODataV4Request(baseUrl, url, metadata, isMinimalRepresentation) {
        if (isMinimalRepresentation === void 0) { isMinimalRepresentation = false; }
        var _this = _super.call(this, baseUrl, url, metadata) || this;
        _this.isMinimalRepresentation = isMinimalRepresentation;
        _this.context = url.split('?')[0];
        return _this;
    }
    /**
     * Split a list of properties that can contain sub-requests into an array.
     *
     * @param propertiesQuery OData properties request
     * @param delimiter Property delimiter
     */
    ODataV4Request.prototype.splitProperties = function (propertiesQuery, delimiter) {
        if (delimiter === void 0) { delimiter = ','; }
        var properties = [];
        var nestingDepth = 0, startIndex = 0, index = 0;
        for (; index < propertiesQuery.length; index++) {
            var char = propertiesQuery[index];
            if (char === delimiter && nestingDepth === 0) {
                // top-level delimiter  end of property
                if (index - startIndex > 0) {
                    properties.push(propertiesQuery.substring(startIndex, index));
                }
                startIndex = index + 1;
            }
            else if (char === '(') {
                nestingDepth++;
            }
            else if (char === ')') {
                nestingDepth--;
            }
        }
        if (index - startIndex > 0) {
            properties.push(propertiesQuery.substring(startIndex));
        }
        if (nestingDepth !== 0) {
            throw new common_1.ExecutionError("Too many " + (nestingDepth > 0 ? 'opening' : 'closing') + " parentheses: " + propertiesQuery, 400, undefined, false);
        }
        return properties;
    };
    /**
     * @param expandParameters
     */
    ODataV4Request.prototype.parseExpand = function (expandParameters) {
        var _this = this;
        var props = this.splitProperties(expandParameters);
        return props.reduce(function (reducer, property) {
            var _a;
            var _b = (_a = balanced_match_1.default('(', ')', property)) !== null && _a !== void 0 ? _a : { pre: property, body: '' }, name = _b.pre, parameters = _b.body;
            var parameterSplit = _this.splitProperties(parameters, ';');
            var queryPart = parameterSplit.reduce(function (acc, split) { return Object.assign(acc, query_string_1.parse(split)); }, {});
            var expand = queryPart['$expand']
                ? _this.parseExpand(queryPart['$expand'])
                : { expand: {}, properties: {} };
            var selectProperties = {};
            if (queryPart['$select']) {
                // explicit $select
                queryPart['$select'].split(',').forEach(function (propertyName) { return (selectProperties[propertyName] = true); });
            }
            else {
                selectProperties['*'] = true;
            }
            Object.keys(expand.properties).forEach(function (expandName) {
                selectProperties[expandName] = true;
            });
            reducer.expand[name] = {
                expand: expand.expand,
                select: selectProperties
            };
            reducer.properties[name] = true;
            return reducer;
        }, { expand: {}, properties: {} });
    };
    /**
     * @param entity
     * @param element
     */
    ODataV4Request.prototype.enrichElement = function (entity, element) {
        // nothing to do in v4
    };
    /**
     * @param data
     * @param bCreated
     * @param key
     */
    ODataV4Request.prototype.createResponse = function (data, bCreated, key) {
        if (bCreated === void 0) { bCreated = false; }
        if (key === void 0) { key = undefined; }
        var response = new simpleHttpResponse_1.SimpleResponse();
        if (data !== null) {
            if (!this.isMinimalRepresentation) {
                response.write(this.toJSON(data));
                response.status(bCreated ? 201 : 200);
            }
            else {
                response.status(204);
                response.setHeader('preference-applied', 'return=minimal');
            }
        }
        else {
            response.status(404);
        }
        response.setHeader('content-type', 'application/json;odata.metadata=minimal;IEEE754Compatible=true');
        response.setHeader('odata-version', '4.0');
        if (bCreated) {
            response.setHeader('location', this.location);
        }
        return response;
    };
    /**
     * @param data
     */
    ODataV4Request.prototype.toJSON = function (data) {
        // Header sap-contextid: SID:ANON:ldcicf6_CF6_00:PfxM66KUqPqnTLsyxAgp1J2aQJHbISjdfAQTi6e_-ATT
        // TODO: generate context based on this.uri
        //'@odata.context': `$metadata#${this.uri.entitySet}(${this.uri.query['$select']},${this.uri.query['$expand']})`
        var outContext = this.context;
        var dataLength = this.dataLength;
        if (outContext.indexOf('$metadata') === -1) {
            outContext = "$metadata#" + this.context;
        }
        if (Array.isArray(data)) {
            var result = {
                '@odata.context': "" + outContext,
                '@odata.count': dataLength,
                value: data
            };
            return JSON.stringify(result);
        }
        else {
            var result = {
                '@odata.context': "" + outContext,
                '@odata.metadataEtag': 'W/"2DWIhBAR9jvPhquo53N+7tW+t3A5axeT11Xw3lkjcRY="'
            };
            return JSON.stringify(Object.assign(result, data));
        }
    };
    return ODataV4Request;
}(odataRequest_1.ODataRequest));
exports.ODataV4Request = ODataV4Request;


/***/ }),

/***/ 3741:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSearch = exports.SearchParser = exports.SearchLexer = void 0;
var chevrotain_1 = __webpack_require__(8154);
// ----------------- Lexer -----------------
var OPEN = chevrotain_1.createToken({ name: 'OPEN', pattern: /(:?\(|%28)/ });
var CLOSE = chevrotain_1.createToken({ name: 'CLOSE', pattern: /(:?\)|%29)/ });
var QUOTE = chevrotain_1.createToken({ name: 'QUOTE', pattern: /(:?"|%22)/ });
var STRINGLITERAL = chevrotain_1.createToken({
    name: 'SimpleIdentifier',
    pattern: /(:?[^\\"\n\r\s]+|\\(:?[bfnrtv"\\/]|u[0-9a-fA-F]{4}))+/
});
// null, boolean, guid, dateTimeInOffset / dateValue / timeOfDay / decimalValue / doubleValue / singleValue / string / duration / enum / binary
var ANDOR = chevrotain_1.createToken({ name: 'AndOr', pattern: /(:?AND|OR)/ });
var WS = chevrotain_1.createToken({ name: 'Whitespace', pattern: /\s+/ });
var searchTokens = [OPEN, CLOSE, QUOTE, ANDOR, WS, STRINGLITERAL];
exports.SearchLexer = new chevrotain_1.Lexer(searchTokens, {
    // Less position info tracked, reduces verbosity of the playground output.
    positionTracking: 'onlyStart'
});
/**
 *
 */
var SearchParser = /** @class */ (function (_super) {
    __extends(SearchParser, _super);
    function SearchParser() {
        var _this = _super.call(this, searchTokens, {
            recoveryEnabled: true
        }) || this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var $ = _this;
        $.searchExpression = $.RULE('searchExpression', function () {
            var expression = $.SUBRULE($.expression);
            return expression;
        });
        $.expression = $.RULE('expression', function () {
            var searchTerms = [];
            //const isExprOpen = $.OPTION1(() => $.CONSUME(OPEN));
            var hasQuote = $.OPTION2(function () { return $.CONSUME(QUOTE); });
            if (hasQuote) {
                // String literal including WS
                var stringLit_1 = '';
                $.MANY_SEP({
                    SEP: WS,
                    DEF: function () {
                        var stringToken = $.CONSUME(STRINGLITERAL);
                        if (stringLit_1.length > 0) {
                            stringLit_1 += ' ';
                        }
                        stringLit_1 += stringToken.image;
                    }
                });
                searchTerms.push(stringLit_1);
                $.CONSUME2(QUOTE);
            }
            else {
                searchTerms.push($.CONSUME(STRINGLITERAL).image);
            }
            $.OPTION3(function () {
                $.CONSUME(WS);
                var otherExpression = $.SUBRULE($.expression);
                searchTerms = searchTerms.concat(otherExpression);
            });
            return searchTerms;
        });
        _this.performSelfAnalysis();
        return _this;
    }
    return SearchParser;
}(chevrotain_1.EmbeddedActionsParser));
exports.SearchParser = SearchParser;
/**
 * @param text
 */
function parseSearch(text) {
    var parser = new SearchParser();
    var lexingResult = exports.SearchLexer.tokenize(text);
    // "input" is a setter which will reset the parser's state.
    parser.input = lexingResult.tokens;
    var output = parser.searchExpression();
    if (parser.errors.length > 0) {
        parser.errors.forEach(console.error);
        throw new Error('Parsing errors detected');
    }
    return output;
}
exports.parseSearch = parseSearch;


/***/ }),

/***/ 5352:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvePath = exports.loadJS = exports.exists = exports.loadFile = exports.isInBrowser = void 0;
var graceful_fs_1 = __webpack_require__(5740);
var util_1 = __webpack_require__(3837);
var path_1 = __importDefault(__webpack_require__(1017));
var isBrowser = false;
var readFileP;
var existsP;
if (!graceful_fs_1.readFileSync) {
    isBrowser = true;
}
else {
    readFileP = util_1.promisify(graceful_fs_1.readFile);
    existsP = util_1.promisify(graceful_fs_1.exists);
}
/**
 *
 */
function isInBrowser() {
    return isBrowser;
}
exports.isInBrowser = isInBrowser;
/**
 * @param filePath
 */
function loadFile(filePath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!isBrowser) {
                return [2 /*return*/, readFileP(filePath, 'utf-8')];
            }
            else {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                filePath = sap.ui.loader._.resolveURL(sap.ui.loader._.toUrl(filePath));
                return [2 /*return*/, fetch(filePath).then(function (res) {
                        return res.text();
                    })];
            }
            return [2 /*return*/];
        });
    });
}
exports.loadFile = loadFile;
/**
 * @param filePath
 */
function exists(filePath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!isBrowser) {
                return [2 /*return*/, existsP(filePath)];
            }
            else {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                filePath = sap.ui.loader._.resolveURL(sap.ui.loader._.toUrl(filePath));
                return [2 /*return*/, fetch(filePath, { method: 'HEAD' }).then(function (res) {
                        return res.status === 200;
                    })];
            }
            return [2 /*return*/];
        });
    });
}
exports.exists = exists;
/**
 * @param filePath
 */
function loadJS(filePath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!isBrowser) {
                delete __webpack_require__.c[filePath];
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                return [2 /*return*/, Promise.resolve(require(/* webpackIgnore: true */ filePath))];
            }
            else {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        sap.ui.require([path_1.default.dirname(filePath) + '/' + path_1.default.basename(filePath, '.js')], function (fileContent) {
                            resolve(fileContent);
                        });
                    })];
            }
            return [2 /*return*/];
        });
    });
}
exports.loadJS = loadJS;
/**
 * @param basePath
 * @param targetPath
 */
function resolvePath(basePath, targetPath) {
    if (!isBrowser) {
        return path_1.default.resolve(basePath, targetPath);
    }
    else {
        return targetPath;
    }
}
exports.resolvePath = resolvePath;


/***/ }),

/***/ 4087:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileCDS = void 0;
var commonContent = "type Language : Association to sap.common.Languages;\ntype Currency : Association to sap.common.Currencies;\ntype Country : Association to sap.common.Countries;\n\n/**\n * Entities to serve the reuse types with extensible code lists\n * including built-in support for value lists in Fiori.\n */\ncontext sap.common {\n  entity Languages : CodeList {\n    key code : String(14) @(title : '{i18n>LanguageCode}');\n    //> length=14 is to accommodate values like these:\n    // en_US_x_saptrc - (1Q) used as a technical SAP language code\n    // en_US_x_sappsd - (2Q) used as a technical SAP language code\n  }\n\n  entity Countries : CodeList {\n    key code : String(3) @(title : '{i18n>CountryCode}');\n  }\n\n  entity Currencies : CodeList {\n    key code   : String(3) @(title : '{i18n>CurrencyCode}');\n        symbol : String(5) @(title : '{i18n>CurrencySymbol}');\n  }\n\n  aspect CodeList @(\n    cds.autoexpose,\n    cds.persistence.skip : 'if-unused'\n  ) {\n    name  : localized String(255)  @title : '{i18n>Name}';\n    descr : localized String(1000) @title : '{i18n>Description}';\n  }\n}\n\n\n/*\n * Aspect for entities with canonical universal IDs.\n */\naspect cuid {\n  key ID : UUID; //> automatically filled in\n}\n\n/*\n * Aspect to capture changes by user and name.\n */\naspect managed {\n  createdAt  : Timestamp @cds.on.insert : $now;\n  createdBy  : User      @cds.on.insert : $user;\n  modifiedAt : Timestamp @cds.on.insert : $now  @cds.on.update : $now;\n  modifiedBy : User      @cds.on.insert : $user @cds.on.update : $user;\n}\n\n/*\n * Aspects for entities with temporal data.\n */\naspect temporal {\n  validFrom : Timestamp @cds.valid.from;\n  validTo   : Timestamp @cds.valid.to;\n}\n\n\n/**\n * Canonical user ID\n */\ntype User : String(255);\n\n\n//---------------------------------------------------------------------------\n// Annotations for Fiori UIs...\n\nannotate sap.common.CodeList with @UI.Identification : [{Value:name}];\nannotate sap.common.CodeList with @cds.odata.valuelist;\n\nannotate managed with {\n  createdAt  @UI.HiddenFilter;\n  createdBy  @UI.HiddenFilter;\n  modifiedAt @UI.HiddenFilter;\n  modifiedBy @UI.HiddenFilter;\n}\n\nannotate managed with {\n  createdAt  @Core.Immutable;\n  createdBy  @Core.Immutable;\n}\n\nannotate sap.common.Countries  with { code @Common.Text:name; }\nannotate sap.common.Currencies with { code @Common.Text:name; }\nannotate sap.common.Languages  with { code @Common.Text:name; }\n\n\n//---------------------------------------------------------------------------\n// Common Annotations...\n\nannotate Language with @(\n  title       : '{i18n>Language}',\n  description : '{i18n>LanguageCode.Description}'\n);\n\nannotate Currency with @(\n  title       : '{i18n>Currency}',\n  description : '{i18n>CurrencyCode.Description}'\n);\n\nannotate Country with @(\n  title       : '{i18n>Country}',\n  description : '{i18n>CountryCode.Description}'\n);\n\nannotate User with @(\n  title       : '{i18n>UserID}',\n  description : '{i18n>UserID.Description}'\n);\n\nannotate managed with {\n  createdAt  @title : '{i18n>CreatedAt}';\n  createdBy  @title : '{i18n>CreatedBy}';\n  modifiedAt @title : '{i18n>ChangedAt}';\n  modifiedBy @title : '{i18n>ChangedBy}';\n}\n\n\n//---------------------------------------------------------------------------\n// Temporary Workarounds...\n\n// REVISIT: change @odata.on... to @cds.on...\n// REVISIT: @cds.on... should automatically result in @readonly @Core.Computed\n\nannotate managed with {\n  modifiedAt @readonly  @odata.on.update : #now;\n  createdAt  @readonly  @odata.on.insert : #now;\n  createdBy  @readonly  @odata.on.insert : #user;\n  modifiedBy @readonly  @odata.on.update : #user;\n}\n\n//---------------------------------------------------------------------------\n";
var compileCDS = function (cdsString, serviceName) {
    if (serviceName === void 0) { serviceName = 'sap.ux.TestService'; }
    return __awaiter(void 0, void 0, void 0, function () {
        var _a, compactModel, compileSources, to, commonCSN, csn, csnModel, edmxContent;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, Promise.resolve().then(function () { return __importStar(require(/* webpackIgnore: true */ '@sap/cds-compiler')); })];
                case 1:
                    _a = _b.sent(), compactModel = _a.compactModel, compileSources = _a.compileSources, to = _a.to;
                    commonCSN = compileSources({ 'string.cds': commonContent }, {});
                    csn = compileSources({ 'string.cds': cdsString }, {});
                    csn.definitions = Object.assign(commonCSN.definitions, csn.definitions);
                    csnModel = compactModel(csn);
                    edmxContent = to.edmx(csnModel, { service: serviceName });
                    return [2 /*return*/, edmxContent];
            }
        });
    });
};
exports.compileCDS = compileCDS;


/***/ }),

/***/ 2787:
/***/ ((module) => {

"use strict";
module.exports = require("@ui5/logger");

/***/ }),

/***/ 8342:
/***/ ((module) => {

"use strict";
module.exports = require("balanced-match");

/***/ }),

/***/ 3986:
/***/ ((module) => {

"use strict";
module.exports = require("body-parser");

/***/ }),

/***/ 8154:
/***/ ((module) => {

"use strict";
module.exports = require("chevrotain");

/***/ }),

/***/ 2408:
/***/ ((module) => {

"use strict";
module.exports = require("chokidar");

/***/ }),

/***/ 8046:
/***/ ((module) => {

"use strict";
module.exports = require("etag");

/***/ }),

/***/ 5740:
/***/ ((module) => {

"use strict";
module.exports = require("graceful-fs");

/***/ }),

/***/ 9548:
/***/ ((module) => {

"use strict";
module.exports = require("lodash.clonedeep");

/***/ }),

/***/ 3255:
/***/ ((module) => {

"use strict";
module.exports = require("nise");

/***/ }),

/***/ 9103:
/***/ ((module) => {

"use strict";
module.exports = require("query-string");

/***/ }),

/***/ 1071:
/***/ ((module) => {

"use strict";
module.exports = require("router");

/***/ }),

/***/ 4269:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 3477:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 1576:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(7300);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=index.js.map