import { EntityType, Property } from '@sap-ux/annotation-converter';
import { FileBasedMockData, KeyDefinitions } from './fileBasedMockData';
import { Action } from '@sap-ux/vocabularies-types';
import { EntitySetInterface } from './common';
export declare type MockDataContributor = {
    getInitialDataSet?: (contextId: string) => object[];
    addEntry?: (mockEntry: object) => void;
    updateEntry?: (keyValues: KeyDefinitions, newData: object) => Promise<void>;
    removeEntry?: (keyValues: KeyDefinitions) => void;
    hasEntry?: (keyValues: KeyDefinitions) => boolean;
    hasEntries?: () => boolean;
    fetchEntries?: (keyValues: KeyDefinitions) => object[];
    getAllEntries?: (dontClone?: boolean) => object[];
    getEmptyObject?: () => object;
    getDefaultElement?: () => object;
    generateKey?: (property: Property) => any;
    onBeforeAction?(actionDefinition: Action, actionData: any, keys: Record<string, any>): Promise<object>;
    executeAction?(actionDefinition: Action, actionData: any, keys: Record<string, any>): Promise<object>;
    onAfterAction?(actionDefinition: Action, actionData: any, keys: Record<string, any>, responseData: any): Promise<any>;
    onAfterUpdateEntry?(keyValues: KeyDefinitions, updatedData: object): Promise<void>;
    onBeforeUpdateEntry?(keyValues: KeyDefinitions, updatedData: object): Promise<void>;
    hasCustomAggregate?(customAggregateName: string): boolean;
    performCustomAggregate?(customAggregateName: string, dataToAggregate: any[]): any;
    throwError?(message: string, statusCode?: number, messageData?: object): any;
    base?: {
        generateMockData: () => void;
        generateKey: (property: Property, lineIndex?: number, mockData?: any) => any;
        addEntry: (mockEntry: object) => void;
        updateEntry: (keyValues: KeyDefinitions, newData: object) => void;
        removeEntry: (keyValues: KeyDefinitions) => void;
        hasEntry: (keyValues: KeyDefinitions) => boolean;
        fetchEntries: (keyValues: KeyDefinitions) => object[];
        hasEntries: () => boolean;
        getAllEntries: () => object[];
        getEmptyObject: () => object;
        getDefaultElement: () => object;
        getParentEntityInterface: () => MockDataContributor | undefined;
        getEntityInterface: (entityName: string) => MockDataContributor | undefined;
    };
};
/**
 *
 */
export declare class FunctionBasedMockData extends FileBasedMockData {
    private _mockDataFn;
    /**
     * @param mockDataFn
     * @param entityType
     * @param mockDataEntitySet
     * @param contextId
     */
    constructor(mockDataFn: MockDataContributor, entityType: EntityType, mockDataEntitySet: EntitySetInterface, contextId: string);
    /**
     * @param mockEntry
     */
    addEntry(mockEntry: any): void;
    /**
     * @param keyValues
     * @param updatedData
     */
    updateEntry(keyValues: KeyDefinitions, updatedData: object): Promise<void>;
    /**
     * @param keyValues
     */
    removeEntry(keyValues: KeyDefinitions): void;
    /**
     * @param keyValues
     */
    fetchEntries(keyValues: KeyDefinitions): object[];
    /**
     * @param keyValues
     */
    hasEntry(keyValues: KeyDefinitions): boolean;
    /**
     *
     */
    hasEntries(): boolean;
    /**
     *
     */
    getEmptyObject(): object;
    /**
     *
     */
    getDefaultElement(): object;
    /**
     * @param property
     * @param lineIndex
     */
    generateKey(property: Property, lineIndex: number): any;
    /**
     *
     */
    getAllEntries(dontClone?: boolean): object[];
    /**
     * @param actionDefinition
     * @param actionData
     * @param keys
     */
    onBeforeAction(actionDefinition: Action, actionData: any, keys: Record<string, any>): Promise<object>;
    /**
     * @param actionDefinition
     * @param actionData
     * @param keys
     */
    executeAction(actionDefinition: Action, actionData: any, keys: Record<string, any>): Promise<object>;
    /**
     * @param actionDefinition
     * @param actionData
     * @param keys
     * @param responseData
     */
    onAfterAction(actionDefinition: Action, actionData: any, keys: Record<string, any>, responseData: any): Promise<any>;
    /**
     * @param keyValues
     * @param updatedData
     */
    onAfterUpdateEntry(keyValues: KeyDefinitions, updatedData: object): Promise<void>;
    /**
     * @param keyValues
     * @param updatedData
     */
    onBeforeUpdateEntry(keyValues: KeyDefinitions, updatedData: object): Promise<void>;
    /**
     * @param customAggregateName
     */
    hasCustomAggregate(customAggregateName: string): boolean;
    /**
     * @param customAggregateName
     * @param dataToAggregate
     */
    performCustomAggregate(customAggregateName: string, dataToAggregate: any[]): any;
}
